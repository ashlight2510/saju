<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ê¶í•© Â· ì˜¤ëŠ˜ìš´ì„¸ Â· ì‹ ë…„ìš´ì„¸</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Adsense (ìš”ì²­ ë°˜ì˜) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;600;800&family=Playfair+Display:wght@700;800&display=swap");

      :root {
        --bg1: #0b1621;
        --bg2: #101f2e;
        --bg3: #14273b;
        --card: rgba(255, 255, 255, 0.94);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.65);
        --line: rgba(15, 23, 42, 0.12);
        --accent: #2563eb;
        --accent2: #f59e0b;
        --shadow: 0 16px 40px rgba(0, 0, 0, 0.25);
        --radius: 18px;
        --font-body: "IBM Plex Sans KR", "Apple SD Gothic Neo", sans-serif;
        --font-title: "Playfair Display", "Nanum Myeongjo", serif;
      }

      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: radial-gradient(1200px 600px at 10% -10%, #1f3a4d 0%, transparent 60%),
          radial-gradient(900px 500px at 90% 0%, #1a2b3b 0%, transparent 55%),
          linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        color: rgba(255, 255, 255, 0.92);
        font-size: 16px;
      }
      .wrap {
        max-width: 1040px;
        margin: 0 auto;
        padding: 28px 18px 48px;
      }
      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }
      h1 {
        font-family: var(--font-title);
        font-weight: 800;
        letter-spacing: 0.02em;
        font-size: 30px;
      }
      h2 {
        font-size: 22px;
      }
      h3 {
        font-size: 18px;
      }
      .hero {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 14px;
      }
      .badge {
        font-size: 12px;
        font-weight: 800;
        letter-spacing: 0.14em;
        text-transform: uppercase;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .card {
        background: rgba(255, 255, 255, 0.98);
        color: var(--text);
        border-radius: var(--radius);
        padding: 24px;
        margin-bottom: 16px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: var(--shadow);
      }
      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .score {
        font-size: 32px;
        font-weight: 800;
        color: var(--accent);
      }
      .lead {
        font-size: 1.15rem;
        font-weight: 800;
        line-height: 1.65;
      }
      .mini {
        font-size: 0.95rem;
        color: var(--muted);
        font-weight: 700;
        line-height: 1.6;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .btn {
        padding: 12px 16px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        cursor: pointer;
        background: var(--text);
        color: #fff;
        font-size: 15px;
      }
      .btn.outline {
        background: #fff;
        color: var(--text);
        border: 1px solid var(--text);
      }
      .btn.ghost {
        background: rgba(15, 23, 42, 0.08);
        color: var(--text);
        border: 1px solid rgba(15, 23, 42, 0.1);
      }
      select,
      input[type="range"],
      input[type="date"],
      input[type="time"],
      input[type="number"] {
        padding: 12px 12px;
        border-radius: 12px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        font-weight: 700;
        font-size: 15px;
      }
      .rule-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 14px;
        margin-bottom: 10px;
        background: rgba(255, 255, 255, 0.96);
      }
      .rule-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .like-btn {
        border: none;
        background: rgba(37, 99, 235, 0.12);
        color: #1e40af;
        border-radius: 10px;
        padding: 4px 8px;
        cursor: pointer;
        font-weight: 800;
      }
      .radar {
        width: 100%;
        max-width: 420px;
        margin: 12px auto 0;
        display: block;
      }
      .elements-radar {
        max-width: 360px;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }
      .pill-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 800;
        padding: 8px 12px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        border: 1px solid rgba(15, 23, 42, 0.1);
      }
      .section-title {
        font-weight: 800;
        font-size: 1rem;
      }
      .share-note {
        margin-top: 10px;
      }
      .pdf-area {
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        padding: 18px 18px 8px;
        border-radius: 16px;
      }
      .step {
        display: none;
      }
      .step.active {
        display: block;
      }
      .menu-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
      }
      .menu-btn {
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: #f8fafc;
        color: var(--text);
        border-radius: 18px;
        padding: 18px 16px;
        text-align: left;
        cursor: pointer;
        font-weight: 800;
        box-shadow: 0 12px 28px rgba(15, 23, 42, 0.12);
      }
      .menu-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 32px rgba(15, 23, 42, 0.16);
        border-color: rgba(37, 99, 235, 0.3);
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 18, 26, 0.82);
        backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .loading-overlay.active {
        display: flex;
      }
      .loading-card {
        background: rgba(255, 255, 255, 0.96);
        color: var(--text);
        border-radius: 18px;
        padding: 22px 24px;
        min-width: 280px;
        text-align: center;
        box-shadow: var(--shadow);
      }
      .spinner {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 4px solid rgba(37, 99, 235, 0.2);
        border-top-color: var(--accent);
        margin: 0 auto 12px;
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .menu-btn small {
        display: block;
        margin-top: 6px;
        font-size: 13px;
        font-weight: 700;
        color: rgba(15, 23, 42, 0.6);
      }
      .hidden {
        display: none !important;
      }

      @media (max-width: 720px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }
        .card-head {
          flex-direction: column;
          align-items: flex-start;
        }
        .menu-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <div class="badge">ì‚¬ ì£¼ íŒ” ì</div>
        <div class="badge" id="todayBadge"></div>
      </div>

      <!-- Step 1: ë©”ë‰´ -->
      <section id="stepMenu" class="step active">
        <div class="card">
          <div class="card-head">
            <div>
              <h1>ğŸ”® ì˜¤ëŠ˜ ë­ ë³¼ë˜?</h1>
              <p class="mini">
                ê¶í•©/ì‹ ë…„ìš´ì„¸/ì˜¤ëŠ˜ìš´ì„¸ ì¤‘ ì„ íƒí•˜ë©´ ë‹¨ê³„ë³„ë¡œ ì…ë ¥ë°›ê³  ê²°ê³¼ë¥¼
                ë³´ì—¬ì¤„ê²Œ.
              </p>
            </div>
          </div>
          <div class="menu-grid" style="margin-top: 14px">
            <button class="menu-btn" data-mode="compat">
              ê¶í•© ë³´ê¸°
              <small>ë‘ ì‚¬ëŒ ì…ë ¥ â†’ ê¶í•©/ì˜¤ëŠ˜ìš´ì„¸/ê³µìœ </small>
            </button>
            <button class="menu-btn" data-mode="newyear">
              ì‹ ë…„ìš´ì„¸
              <small>í•œ ì‚¬ëŒ ì…ë ¥ â†’ ì›”ë³„ íë¦„</small>
            </button>
            <button class="menu-btn" data-mode="today">
              ì˜¤ëŠ˜ìš´ì„¸
              <small>í•œ ì‚¬ëŒ ì…ë ¥ â†’ ì˜¤ëŠ˜ í•œ ì¤„</small>
            </button>
          </div>
        </div>
      </section>

      <!-- Step 2: ì…ë ¥ -->
      <section id="stepInput" class="step">
        <div class="card" id="inputCard">
          <div class="card-head">
            <div>
              <h1 id="inputTitle">ì…ë ¥</h1>
              <p class="mini" id="inputDesc">ì¶œìƒ ì •ë³´ ì…ë ¥ â†’ ë¡œì»¬ ê³„ì‚°</p>
            </div>
            <div class="row">
              <button class="btn outline" id="backToMenu">ë©”ë‰´ë¡œ</button>
              <button class="btn ghost" id="clearSaved">ì €ì¥ ì´ˆê¸°í™”</button>
              <button class="btn" id="calcBtn">ê³„ì‚°í•˜ê¸°</button>
            </div>
          </div>

          <div class="grid-2" style="margin-top: 12px">
            <div class="rule-card" id="panelA">
              <h3>A ì •ë³´</h3>
              <div class="row">
                <input id="aDate" type="date" />
                <select id="aHourBranch">
                  <option value="ì">ì (00:00-01:30)</option>
                  <option value="ì¶•">ì¶• (01:31-03:30)</option>
                  <option value="ì¸">ì¸ (03:31-05:30)</option>
                  <option value="ë¬˜">ë¬˜ (05:31-07:30)</option>
                  <option value="ì§„">ì§„ (07:31-09:30)</option>
                  <option value="ì‚¬">ì‚¬ (09:31-11:30)</option>
                  <option value="ì˜¤">ì˜¤ (11:31-13:30)</option>
                  <option value="ë¯¸">ë¯¸ (13:31-15:30)</option>
                  <option value="ì‹ ">ì‹  (15:31-17:30)</option>
                  <option value="ìœ ">ìœ  (17:31-19:30)</option>
                  <option value="ìˆ ">ìˆ  (19:31-21:30)</option>
                  <option value="í•´">í•´ (21:31-23:30)</option>
                </select>
              </div>
              <p class="mini">ì‹œê°„ì€ 12ê°„ì§€ë§Œ ì„ íƒí•˜ë©´ ë¼. í•´ë‹¹ êµ¬ê°„ì˜ ì¤‘ê°„ ì‹œê°ìœ¼ë¡œ ê³„ì‚°í•œë‹¤.</p>
              <div class="row" style="margin-top: 8px">
                <select id="aHiddenMode">
                  <option value="on" selected>ì¥ê°„ ë°˜ì˜</option>
                  <option value="off">ì¥ê°„ ë¯¸ë°˜ì˜</option>
                </select>
              </div>
              <div class="row" style="margin-top: 8px">
                <input
                  id="aTzOffset"
                  type="number"
                  min="-12"
                  max="14"
                  step="0.5"
                  value="9"
                  placeholder="UTC+9"
                />
                <select id="aDstMode">
                  <option value="off" selected>DST ë¯¸ë°˜ì˜</option>
                  <option value="kr1988">í•œêµ­ DST(1988) ë°˜ì˜</option>
                </select>
              </div>
              <p class="mini">
                ì¥ê°„ì€ ì§€ì§€ ì•ˆì— ì„ì—¬ ìˆëŠ” ë³´ì¡° ê¸°ìš´ê¹Œì§€ ê°™ì´ ë”í•´ì„œ, ì˜¤í–‰ ë¶„í¬ë¥¼ í˜„ì‹¤ì ìœ¼ë¡œ ë§ì¶”ëŠ” ì˜µì…˜ì´ì•¼.
              </p>
              <p class="mini">ì¶œìƒ ì‹œê°„ëŒ€(UTC ì˜¤í”„ì…‹)ì™€ DST ì—¬ë¶€ë¥¼ ì„ íƒí•˜ë©´ í˜„ì§€ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°í•´.</p>
            </div>

            <div class="rule-card" id="panelB">
              <h3>B ì •ë³´</h3>
              <div class="row">
                <input id="bDate" type="date" />
                <select id="bHourBranch">
                  <option value="ì">ì (00:00-01:30)</option>
                  <option value="ì¶•">ì¶• (01:31-03:30)</option>
                  <option value="ì¸">ì¸ (03:31-05:30)</option>
                  <option value="ë¬˜">ë¬˜ (05:31-07:30)</option>
                  <option value="ì§„">ì§„ (07:31-09:30)</option>
                  <option value="ì‚¬">ì‚¬ (09:31-11:30)</option>
                  <option value="ì˜¤">ì˜¤ (11:31-13:30)</option>
                  <option value="ë¯¸">ë¯¸ (13:31-15:30)</option>
                  <option value="ì‹ ">ì‹  (15:31-17:30)</option>
                  <option value="ìœ ">ìœ  (17:31-19:30)</option>
                  <option value="ìˆ ">ìˆ  (19:31-21:30)</option>
                  <option value="í•´">í•´ (21:31-23:30)</option>
                </select>
              </div>
              <p class="mini">ì‹œê°„ì€ 12ê°„ì§€ë§Œ ì„ íƒí•˜ë©´ ë¼. í•´ë‹¹ êµ¬ê°„ì˜ ì¤‘ê°„ ì‹œê°ìœ¼ë¡œ ê³„ì‚°í•œë‹¤.</p>
              <div class="row" style="margin-top: 8px">
                <select id="bHiddenMode">
                  <option value="on" selected>ì¥ê°„ ë°˜ì˜</option>
                  <option value="off">ì¥ê°„ ë¯¸ë°˜ì˜</option>
                </select>
              </div>
              <div class="row" style="margin-top: 8px">
                <input
                  id="bTzOffset"
                  type="number"
                  min="-12"
                  max="14"
                  step="0.5"
                  value="9"
                  placeholder="UTC+9"
                />
                <select id="bDstMode">
                  <option value="off" selected>DST ë¯¸ë°˜ì˜</option>
                  <option value="kr1988">í•œêµ­ DST(1988) ë°˜ì˜</option>
                </select>
              </div>
              <p class="mini">
                ì¥ê°„ì€ ì§€ì§€ ì•ˆì— ì„ì—¬ ìˆëŠ” ë³´ì¡° ê¸°ìš´ê¹Œì§€ ê°™ì´ ë”í•´ì„œ, ì˜¤í–‰ ë¶„í¬ë¥¼ í˜„ì‹¤ì ìœ¼ë¡œ ë§ì¶”ëŠ” ì˜µì…˜ì´ì•¼.
              </p>
              <p class="mini">ì¶œìƒ ì‹œê°„ëŒ€(UTC ì˜¤í”„ì…‹)ì™€ DST ì—¬ë¶€ë¥¼ ì„ íƒí•˜ë©´ í˜„ì§€ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°í•´.</p>
            </div>
          </div>

          <div class="row" style="margin-top: 12px" id="toneRow">
            <span class="mini">í†¤</span>
            <select id="toneSelect">
              <option value="couple" selected>ì»¤í”Œ ëª¨ë“œ</option>
              <option value="biz">ë™ì—…ì ëª¨ë“œ</option>
            </select>
            <span class="mini">* ì‹œê°„ëŒ€ ì„ íƒ ê°€ëŠ¥ Â· 1988 í•œêµ­ DST ì˜µì…˜ ì œê³µ</span>
          </div>
        </div>
      </section>

      <!-- Step 3: ê²°ê³¼ -->
      <section id="stepResult" class="step">
        <div class="row" style="margin-bottom: 12px">
          <button class="btn outline" id="backToInput">ì…ë ¥ ìˆ˜ì •</button>
          <button class="btn outline" id="restartFlow">ë©”ë‰´ë¡œ</button>
        </div>

        <div id="pdfArea" class="pdf-area">
          <div class="card" id="resultElementsCard">
            <h2>ì˜¤í–‰ ê¸°ìš´ ë¶„ì„</h2>
            <p class="lead" id="elementsSummary">â€”</p>
            <svg
              id="elementsRadarSvg"
              class="radar elements-radar"
              viewBox="0 0 320 320"
            ></svg>
            <p class="mini" id="elementsDetail">â€”</p>
          </div>
          <div class="card" id="resultDeepCard">
            <h2>ì‹¬í™” ë¶„ì„ (ê°„ì´)</h2>
            <div id="deepAnalysis"></div>
          </div>
          <div class="card" id="resultLuckCard">
            <h2>ëŒ€ìš´ Â· ì„¸ìš´ (ê°„ì´)</h2>
            <div id="luckFlow"></div>
          </div>
          <div class="card" id="resultSummaryCard">
            <div class="card-head">
              <div>
                <h2 id="resultTitle">ê¶í•© ìš”ì•½</h2>
                <p class="mini" id="summarySub">
                  ì…ë ¥ ì‹œê°„ëŒ€ ê¸°ì¤€ Â· ì ˆê¸°/ì˜¤í–‰ ê·œì¹™
                </p>
              </div>
              <div class="score" id="totalScore">â€”</div>
            </div>
            <p class="lead" id="summaryMain">â€”</p>
            <div class="pill-row" id="summaryPills"></div>
          </div>

          <div class="card" id="resultTodayCard">
            <div class="row" style="justify-content: space-between">
              <div>
                <h2>ì˜¤ëŠ˜ ìš´ì„¸</h2>
                <p class="lead" id="todayCoupleLine">â€”</p>
                <p class="mini" id="todayCoupleMeta">â€”</p>
              </div>
              <button class="btn ghost" id="todayLuckBtn">
                ì˜¤ëŠ˜ ë‹¤ì‹œ ë³´ê¸°
              </button>
            </div>
          </div>

          <div class="grid-2" id="resultCompatGrid">
            <div class="card" id="resultRadarCard">
              <h2>ì„¹ì…˜ë³„ ê· í˜•</h2>
              <svg
                id="sectionRadarSvg"
                class="radar"
                viewBox="0 0 320 320"
              ></svg>
              <p class="mini" id="sectionRadarLegend">ê´€ê³„ì˜ ì „ì²´ ë°¸ëŸ°ìŠ¤</p>
            </div>

            <div class="card" id="resultABCard">
              <h2>A/B ì‚¬ì£¼ ìš”ì•½</h2>
              <div class="grid-2" style="gap: 8px">
                <div>
                  <div class="section-title">A</div>
                  <div id="aPillars" class="mini"></div>
                </div>
                <div>
                  <div class="section-title">B</div>
                  <div id="bPillars" class="mini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="card" id="resultRulesCard">
            <h2>ê¶í•© í¬ì¸íŠ¸</h2>
            <div id="ruleList"></div>
          </div>

          <div class="card" id="resultMonthlyCard">
            <h2>2026 ì‹ ë…„ìš´ì„¸ (ì›”ë³„)</h2>
            <div id="monthlyList"></div>
          </div>
        </div>

        <div class="card" id="tuningCard">
          <h2>íŠœë‹ (í•™ìŠµ ëŠë‚Œ)</h2>
          <div class="row">
            <span class="mini">íŠœë‹ ê°•ë„</span>
            <input
              type="range"
              min="0"
              max="2"
              step="0.1"
              value="1"
              id="tuneStrength"
            />
            <span id="tuneLabel" class="mini">1.0</span>
            <button class="btn outline" id="tuneReset">ì´ˆê¸°í™”</button>
          </div>
          <p class="mini" id="tuneStatus"></p>
        </div>

        <div class="card" id="shareCard">
          <h2>ê³µìœ  Â· PDF</h2>
          <div class="row">
            <button class="btn" id="shareBtn">ê³µìœ  ì¹´ë“œ ë§Œë“¤ê¸°</button>
            <button class="btn outline" id="pdfBtn">PDF ì €ì¥</button>
          </div>
          <p class="mini share-note" id="shareStatus"></p>
          <canvas
            id="shareCanvas"
            width="1080"
            height="1350"
            style="display: none"
          ></canvas>
        </div>
      </section>
    </div>

    <div class="loading-overlay" id="loadingOverlay" aria-hidden="true">
      <div class="loading-card">
        <div class="spinner"></div>
        <div class="lead" style="margin-bottom: 6px">ì˜¤í–‰ ê· í˜• ê³„ì‚° ì¤‘</div>
        <div class="mini">ì ˆê¸° ê¸°ì¤€ìœ¼ë¡œ ì •ë°€í•˜ê²Œ ë§ì¶”ëŠ” ì¤‘ì´ì•¼â€¦</div>
      </div>
    </div>

    <script src="./vendor/html2canvas.min.js"></script>
    <script src="./vendor/jspdf.umd.min.js"></script>

    <script>
      /* ======================================================
  0. ê¸°ë³¸ DOM
====================================================== */
      const todayBadge = document.getElementById("todayBadge");
      todayBadge.textContent = new Date().toISOString().slice(0, 10);

      const stepMenu = document.getElementById("stepMenu");
      const stepInput = document.getElementById("stepInput");
      const stepResult = document.getElementById("stepResult");

      const inputTitle = document.getElementById("inputTitle");
      const inputDesc = document.getElementById("inputDesc");
      const panelA = document.getElementById("panelA");
      const panelB = document.getElementById("panelB");
      const toneRow = document.getElementById("toneRow");

      const aDate = document.getElementById("aDate");
      const aHourBranch = document.getElementById("aHourBranch");
      const aHiddenMode = document.getElementById("aHiddenMode");
      const aTzOffset = document.getElementById("aTzOffset");
      const aDstMode = document.getElementById("aDstMode");
      const bDate = document.getElementById("bDate");
      const bHourBranch = document.getElementById("bHourBranch");
      const bHiddenMode = document.getElementById("bHiddenMode");
      const bTzOffset = document.getElementById("bTzOffset");
      const bDstMode = document.getElementById("bDstMode");
      const toneSelect = document.getElementById("toneSelect");
      const calcBtn = document.getElementById("calcBtn");
      const backToMenu = document.getElementById("backToMenu");
      const clearSaved = document.getElementById("clearSaved");
      const backToInput = document.getElementById("backToInput");
      const restartFlow = document.getElementById("restartFlow");

      const resultTitle = document.getElementById("resultTitle");
      const resultElementsCard = document.getElementById("resultElementsCard");
      const resultDeepCard = document.getElementById("resultDeepCard");
      const resultLuckCard = document.getElementById("resultLuckCard");
      const elementsSummary = document.getElementById("elementsSummary");
      const elementsRadarSvg = document.getElementById("elementsRadarSvg");
      const elementsDetail = document.getElementById("elementsDetail");
      const deepAnalysis = document.getElementById("deepAnalysis");
      const luckFlow = document.getElementById("luckFlow");
      const todayCoupleLine = document.getElementById("todayCoupleLine");
      const todayCoupleMeta = document.getElementById("todayCoupleMeta");
      const sectionRadarSvg = document.getElementById("sectionRadarSvg");
      const summaryMain = document.getElementById("summaryMain");
      const summarySub = document.getElementById("summarySub");
      const totalScoreEl = document.getElementById("totalScore");
      const summaryPills = document.getElementById("summaryPills");
      const ruleList = document.getElementById("ruleList");
      const monthlyList = document.getElementById("monthlyList");
      const tuneStrength = document.getElementById("tuneStrength");
      const tuneLabel = document.getElementById("tuneLabel");
      const tuneReset = document.getElementById("tuneReset");
      const tuneStatus = document.getElementById("tuneStatus");
      const todayLuckBtn = document.getElementById("todayLuckBtn");
      const shareBtn = document.getElementById("shareBtn");
      const shareStatus = document.getElementById("shareStatus");
      const pdfBtn = document.getElementById("pdfBtn");
      const aPillarsEl = document.getElementById("aPillars");
      const bPillarsEl = document.getElementById("bPillars");

      const resultTodayCard = document.getElementById("resultTodayCard");
      const resultRadarCard = document.getElementById("resultRadarCard");
      const resultABCard = document.getElementById("resultABCard");
      const resultRulesCard = document.getElementById("resultRulesCard");
      const resultMonthlyCard = document.getElementById("resultMonthlyCard");
      const tuningCard = document.getElementById("tuningCard");
      const loadingOverlay = document.getElementById("loadingOverlay");

      /* ======================================================
  1. ìƒíƒœ
====================================================== */
      const INPUT_KEY = "compat:inputs:v2";
      const state = {
        mode: "compat",
        A: null,
        B: null,
        aResult: null,
        bResult: null,
      };

      /* ======================================================
  2. ìœ í‹¸
====================================================== */
      const STEM_ELEM = {
        ê°‘: "ëª©",
        ì„: "ëª©",
        ë³‘: "í™”",
        ì •: "í™”",
        ë¬´: "í† ",
        ê¸°: "í† ",
        ê²½: "ê¸ˆ",
        ì‹ : "ê¸ˆ",
        ì„: "ìˆ˜",
        ê³„: "ìˆ˜",
      };
      const BRANCH_ELEM = {
        ì: "ìˆ˜",
        ì¶•: "í† ",
        ì¸: "ëª©",
        ë¬˜: "ëª©",
        ì§„: "í† ",
        ì‚¬: "í™”",
        ì˜¤: "í™”",
        ë¯¸: "í† ",
        ì‹ : "ê¸ˆ",
        ìœ : "ê¸ˆ",
        ìˆ : "í† ",
        í•´: "ìˆ˜",
      };
      const GENERATE = { ëª©: "í™”", í™”: "í† ", í† : "ê¸ˆ", ê¸ˆ: "ìˆ˜", ìˆ˜: "ëª©" };
      const OVERCOME = { ëª©: "í† ", í™”: "ê¸ˆ", í† : "ìˆ˜", ê¸ˆ: "ëª©", ìˆ˜: "í™”" };
      const CLASH = { ëª©: "ê¸ˆ", ê¸ˆ: "ëª©", í™”: "ìˆ˜", ìˆ˜: "í™”", í† : null };

      const LIUHE = [
        ["ì", "ì¶•"],
        ["ì¸", "í•´"],
        ["ë¬˜", "ìˆ "],
        ["ì§„", "ìœ "],
        ["ì‚¬", "ì‹ "],
        ["ì˜¤", "ë¯¸"],
      ];
      const CHUNG = [
        ["ì", "ì˜¤"],
        ["ì¶•", "ë¯¸"],
        ["ì¸", "ì‹ "],
        ["ë¬˜", "ìœ "],
        ["ì§„", "ìˆ "],
        ["ì‚¬", "í•´"],
      ];
      const HAE = [
        ["ì", "ë¯¸"],
        ["ì¶•", "ì˜¤"],
        ["ì¸", "ì‚¬"],
        ["ë¬˜", "ì§„"],
        ["ì‹ ", "í•´"],
        ["ìœ ", "ìˆ "],
      ];
      const SAMHAP = [
        ["ì‹ ", "ì", "ì§„"],
        ["í•´", "ë¬˜", "ë¯¸"],
        ["ì¸", "ì˜¤", "ìˆ "],
        ["ì‚¬", "ìœ ", "ì¶•"],
      ];
      const SELF_PUNISH = ["ì", "ì˜¤", "ìœ ", "í•´"];

      const MONTH_FLOW = {
        1: { monthBranch: "ì¶•", seasonTop: "í† " },
        2: { monthBranch: "ì¸", seasonTop: "ëª©" },
        3: { monthBranch: "ë¬˜", seasonTop: "ëª©" },
        4: { monthBranch: "ì§„", seasonTop: "í† " },
        5: { monthBranch: "ì‚¬", seasonTop: "í™”" },
        6: { monthBranch: "ì˜¤", seasonTop: "í™”" },
        7: { monthBranch: "ë¯¸", seasonTop: "í† " },
        8: { monthBranch: "ì‹ ", seasonTop: "ê¸ˆ" },
        9: { monthBranch: "ìœ ", seasonTop: "ê¸ˆ" },
        10: { monthBranch: "ìˆ ", seasonTop: "í† " },
        11: { monthBranch: "í•´", seasonTop: "ìˆ˜" },
        12: { monthBranch: "ì", seasonTop: "ìˆ˜" },
      };

      function hasPair(a, b, table) {
        return table.some(
          ([x, y]) => (a === x && b === y) || (a === y && b === x)
        );
      }
      function isLiuhe(a, b) {
        return hasPair(a, b, LIUHE);
      }
      function isChung(a, b) {
        return hasPair(a, b, CHUNG);
      }
      function isHae(a, b) {
        return hasPair(a, b, HAE);
      }
      function isSamhap(a, b) {
        return SAMHAP.some((g) => g.includes(a) && g.includes(b));
      }
      function isSelfPunish(b) {
        return SELF_PUNISH.includes(b);
      }
      function isSeasonClash(seasonElem, topElem) {
        return CLASH[seasonElem] === topElem;
      }
      function relationElem(a, b) {
        if (GENERATE[a] === b) return "ìƒ";
        if (OVERCOME[a] === b) return "ê·¹";
        if (GENERATE[b] === a) return "ë°›ìŒ";
        if (OVERCOME[b] === a) return "ëˆŒë¦¼";
        if (a === b) return "ë™";
        return "ì¤‘ë¦½";
      }
      function getTopWeak(elementsRaw) {
        const entries = Object.entries(elementsRaw).sort((a, b) => b[1] - a[1]);
        return { top: entries[0][0], weak: entries[entries.length - 1][0] };
      }
      function calcBalance(elementsRaw) {
        const vals = Object.values(elementsRaw);
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        return max ? (max - min) / max : 0;
      }
      function combineElements(a, b) {
        const keys = Object.keys(a);
        const out = {};
        keys.forEach((k) => {
          out[k] = (a[k] + b[k]) / 2;
        });
        return out;
      }
      function round1(x) {
        return Math.round(x * 10) / 10;
      }
      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function parseTzOffsetMinutes(v, fallback = 540) {
        const num = Number(v);
        if (!Number.isFinite(num)) return fallback;
        return Math.round(num * 60);
      }
      function hashToIndex(str, mod) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        h >>>= 0;
        return mod ? h % mod : 0;
      }
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function fillTokens(text, tokens) {
        return text.replace(/\{([^}]+)\}/g, (_, key) => tokens[key] ?? "");
      }
      function hourBranchToTime(branch) {
        const map = {
          ì: "00:45",
          ì¶•: "02:30",
          ì¸: "04:30",
          ë¬˜: "06:30",
          ì§„: "08:30",
          ì‚¬: "10:30",
          ì˜¤: "12:30",
          ë¯¸: "14:30",
          ì‹ : "16:30",
          ìœ : "18:30",
          ìˆ : "20:30",
          í•´: "22:30",
        };
        return map[branch] || "00:30";
      }

      /* ======================================================
  3. ì¼ì§„(ì˜¤ëŠ˜ ìš´ì„¸)
====================================================== */
      const STEMS = [
        "ê°‘",
        "ì„",
        "ë³‘",
        "ì •",
        "ë¬´",
        "ê¸°",
        "ê²½",
        "ì‹ ",
        "ì„",
        "ê³„",
      ];
      const BRANCHES = [
        "ì",
        "ì¶•",
        "ì¸",
        "ë¬˜",
        "ì§„",
        "ì‚¬",
        "ì˜¤",
        "ë¯¸",
        "ì‹ ",
        "ìœ ",
        "ìˆ ",
        "í•´",
      ];
      const GANJI_60 = (() => {
        const arr = [];
        for (let i = 0; i < 60; i++) {
          arr.push({ stem: STEMS[i % 10], branch: BRANCHES[i % 12] });
        }
        return arr;
      })();

      const BASE_GAPJA_DAY = new Date("1984-02-02T00:00:00+09:00");
      const KOREA_DST = [
        {
          start: "1988-05-08T00:00:00+09:00",
          end: "1988-10-09T23:59:59+09:00",
          offsetHours: 1,
        },
      ];

      function applyDST(dateKST) {
        const t = dateKST.getTime();
        for (const d of KOREA_DST) {
          const s = new Date(d.start).getTime();
          const e = new Date(d.end).getTime();
          if (t >= s && t <= e) {
            return new Date(t + d.offsetHours * 3600 * 1000);
          }
        }
        return dateKST;
      }

      function getTodayGanji(date = new Date()) {
        const kst = new Date(
          date.toLocaleString("en-US", { timeZone: "Asia/Seoul" })
        );
        const adj = applyDST(kst);
        const days = Math.floor((adj - BASE_GAPJA_DAY) / (24 * 3600 * 1000));
        const idx = ((days % 60) + 60) % 60;
        return { index: idx, ...GANJI_60[idx] };
      }

      function getTodayElementFlow(date = new Date()) {
        const g = getTodayGanji(date);
        return {
          ganji: g,
          stemElem: STEM_ELEM[g.stem],
          branchElem: BRANCH_ELEM[g.branch],
        };
      }

      function todayAdvantage(aPerson, bPerson, date = new Date()) {
        const flow = getTodayElementFlow(date);
        const key1 = flow.stemElem;
        const key2 = flow.branchElem;
        const scoreA =
          aPerson.elements[key1] * 1.0 + aPerson.elements[key2] * 0.7;
        const scoreB =
          bPerson.elements[key1] * 1.0 + bPerson.elements[key2] * 0.7;
        const diff = scoreA - scoreB;
        const TH = 0.35;

        let winner = "even";
        if (diff > TH) winner = "A";
        else if (diff < -TH) winner = "B";

        const line = makeTodayCoupleLine(winner, key1, key2);
        return {
          winner,
          keys: [key1, key2],
          scoreA: round1(scoreA),
          scoreB: round1(scoreB),
          line,
        };
      }

      function makeTodayCoupleLine(winner, k1, k2) {
        if (winner === "A") {
          return `ì˜¤ëŠ˜ íë¦„ì€ ${k1}/${k2} ìª½ì´ ê°•í•´ì„œ, Aê°€ ì¡°ê¸ˆ ë” ìœ ë¦¬í•´. ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” Aê°€ ë¨¼ì € êº¼ë‚´ë©´ ì¢‹ì•„.`;
        }
        if (winner === "B") {
          return `ì˜¤ëŠ˜ íë¦„ì€ ${k1}/${k2} ìª½ì´ ê°•í•´ì„œ, Bê°€ ì¡°ê¸ˆ ë” ìœ ë¦¬í•´. ì•½ì†/ê²°ì •ì€ B ì»¨ë””ì…˜ì— ë§ì¶”ë©´ ë¶€ë“œëŸ½ê²Œ ê°„ë‹¤.`;
        }
        return `ì˜¤ëŠ˜ì€ ${k1}/${k2} íë¦„ì¸ë°, A/B ë‘˜ ë‹¤ ë¹„ìŠ·í•˜ê²Œ ë°›ëŠ”ë‹¤. ë§ì¶°ê°€ëŠ” ê²Œ ì´ë“ì´ì•¼.`;
      }

      function todayLuckLine(person) {
        const flow = getTodayElementFlow();
        const myTop = person.topElem;
        if (myTop === flow.stemElem || myTop === flow.branchElem) {
          return "ì˜¤ëŠ˜ì€ ë„¤ ê¸°ìš´ì´ ì˜ ë°›ì³ì£¼ëŠ” ë‚ ì´ì•¼. ì¤‘ìš”í•œ ê±´ ì˜¤ëŠ˜ ì²˜ë¦¬í•˜ëŠ” ê²Œ ì¢‹ì•„.";
        }
        return "ì˜¤ëŠ˜ì€ ë¬´ë¦¬í•˜ë©´ ì†í•´ ë³´ëŠ” ë‚ . ì†ë„ ì¤„ì´ê³  í™•ì¸ë¶€í„° í•˜ë©´ ì´ë“ì´ì•¼.";
      }

      function renderTodayCoupleBox(aPerson, bPerson) {
        const t = todayAdvantage(aPerson, bPerson);
        todayCoupleLine.textContent = t.line;
        todayCoupleMeta.textContent = `A ${t.scoreA} vs B ${
          t.scoreB
        } (ì˜¤ëŠ˜ ì˜¤í–‰: ${t.keys.join("/")})`;
      }

      /* ======================================================
  4. ì‚¬ì£¼ ê³„ì‚° (ì •ë°€ ì ˆê¸° ê¸°ë°˜)
====================================================== */
      const STEMS_H = [
        "ê°‘",
        "ì„",
        "ë³‘",
        "ì •",
        "ë¬´",
        "ê¸°",
        "ê²½",
        "ì‹ ",
        "ì„",
        "ê³„",
      ];
      const BRANCHES_H = [
        "ì",
        "ì¶•",
        "ì¸",
        "ë¬˜",
        "ì§„",
        "ì‚¬",
        "ì˜¤",
        "ë¯¸",
        "ì‹ ",
        "ìœ ",
        "ìˆ ",
        "í•´",
      ];

      const BRANCH_MAIN_ELEM = {
        ì: "ìˆ˜",
        ì¶•: "í† ",
        ì¸: "ëª©",
        ë¬˜: "ëª©",
        ì§„: "í† ",
        ì‚¬: "í™”",
        ì˜¤: "í™”",
        ë¯¸: "í† ",
        ì‹ : "ê¸ˆ",
        ìœ : "ê¸ˆ",
        ìˆ : "í† ",
        í•´: "ìˆ˜",
      };

      const HIDDEN_STEMS = {
        ì: [["ê³„", 1.0]],
        ì¶•: [
          ["ê¸°", 0.6],
          ["ê³„", 0.2],
          ["ì‹ ", 0.2],
        ],
        ì¸: [
          ["ê°‘", 0.6],
          ["ë³‘", 0.2],
          ["ë¬´", 0.2],
        ],
        ë¬˜: [["ì„", 1.0]],
        ì§„: [
          ["ë¬´", 0.6],
          ["ì„", 0.2],
          ["ê³„", 0.2],
        ],
        ì‚¬: [
          ["ë³‘", 0.6],
          ["ê²½", 0.2],
          ["ë¬´", 0.2],
        ],
        ì˜¤: [
          ["ì •", 0.7],
          ["ê¸°", 0.3],
        ],
        ë¯¸: [
          ["ê¸°", 0.6],
          ["ì •", 0.2],
          ["ì„", 0.2],
        ],
        ì‹ : [
          ["ê²½", 0.6],
          ["ì„", 0.2],
          ["ë¬´", 0.2],
        ],
        ìœ : [["ì‹ ", 1.0]],
        ìˆ : [
          ["ë¬´", 0.6],
          ["ì‹ ", 0.2],
          ["ì •", 0.2],
        ],
        í•´: [
          ["ì„", 0.7],
          ["ê°‘", 0.3],
        ],
      };

      const MONTH_BOUNDARIES = [
        { name: "ì…ì¶˜", lon: 315, branch: "ì¸" },
        { name: "ê²½ì¹©", lon: 345, branch: "ë¬˜" },
        { name: "ì²­ëª…", lon: 15, branch: "ì§„" },
        { name: "ì…í•˜", lon: 45, branch: "ì‚¬" },
        { name: "ë§ì¢…", lon: 75, branch: "ì˜¤" },
        { name: "ì†Œì„œ", lon: 105, branch: "ë¯¸" },
        { name: "ì…ì¶”", lon: 135, branch: "ì‹ " },
        { name: "ë°±ë¡œ", lon: 165, branch: "ìœ " },
        { name: "í•œë¡œ", lon: 195, branch: "ìˆ " },
        { name: "ì…ë™", lon: 225, branch: "í•´" },
        { name: "ëŒ€ì„¤", lon: 255, branch: "ì" },
        { name: "ì†Œí•œ", lon: 285, branch: "ì¶•" },
      ];

      function sunApparentEclipticLongitudeDeg(jd) {
        const T = (jd - 2451545.0) / 36525.0;
        let L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
        L0 = normalizeDeg(L0);
        let M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
        M = normalizeDeg(M);
        const Mr = deg2rad(M);
        const C =
          (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(Mr) +
          (0.019993 - 0.000101 * T) * Math.sin(2 * Mr) +
          0.000289 * Math.sin(3 * Mr);
        let trueLon = L0 + C;
        const omega = deg2rad(125.04 - 1934.136 * T);
        let lambda = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
        return normalizeDeg(lambda);
      }

      function findSolarLongitudeTimeUTC(year, targetLonDeg) {
        const approx = approximateDateForLon(year, targetLonDeg);
        let t0 = approx.getTime() - 3 * 86400e3;
        let t1 = approx.getTime() + 3 * 86400e3;

        const f = (t) => {
          const jd = toJulianDay(new Date(t));
          const lon = sunApparentEclipticLongitudeDeg(jd);
          return shortestAngleDiffDeg(lon, targetLonDeg);
        };

        let a = t0,
          b = t1;
        let fa = f(a),
          fb = f(b);
        let tries = 0;
        while (fa * fb > 0 && tries < 12) {
          a -= 2 * 86400e3;
          b += 2 * 86400e3;
          fa = f(a);
          fb = f(b);
          tries++;
        }
        if (fa * fb > 0) {
          return new Date(approx.getTime());
        }

        for (let i = 0; i < 60; i++) {
          const m = (a + b) / 2;
          const fm = f(m);
          if (Math.abs(fm) < 1e-6) {
            a = b = m;
            break;
          }
          if (fa * fm <= 0) {
            b = m;
            fb = fm;
          } else {
            a = m;
            fa = fm;
          }
        }
        return new Date((a + b) / 2);
      }

      function approximateDateForLon(year, lon) {
        const map = {
          315: [2, 4],
          345: [3, 6],
          15: [4, 5],
          45: [5, 6],
          75: [6, 6],
          105: [7, 7],
          135: [8, 7],
          165: [9, 7],
          195: [10, 8],
          225: [11, 7],
          255: [12, 7],
          285: [1, 6],
        };
        const [mm, dd] = map[lon] || [2, 4];
        return new Date(Date.UTC(year, mm - 1, dd, 12, 0, 0));
      }

      function computeMonthBoundaryTimesUTC(year) {
        return MONTH_BOUNDARIES.map((b) => ({
          ...b,
          timeUTC: findSolarLongitudeTimeUTC(year, b.lon),
        }));
      }

      function computeSajuFiveElements(
        birthUTCDate,
        { ziMode, hiddenMode, tzOffsetMinutes, dstMode }
      ) {
        const birthLocal = toLocalDateParts(
          birthUTCDate,
          tzOffsetMinutes,
          dstMode
        );
        const year = birthLocal.y;
        const boundariesThisYearUTC = computeMonthBoundaryTimesUTC(year);
        const boundariesPrevYearUTC = computeMonthBoundaryTimesUTC(year - 1);

        const ipchunThisLocal = toLocalMillis(
          boundariesThisYearUTC[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        const birthMillisLocal = localMillisFromParts(birthLocal);

        const sajuYear = birthMillisLocal >= ipchunThisLocal ? year : year - 1;
        const bdsUTC =
          sajuYear === year ? boundariesThisYearUTC : boundariesPrevYearUTC;
        const bdsLocal = bdsUTC.map((x) => ({
          ...x,
          local: toLocalMillis(x.timeUTC, tzOffsetMinutes, dstMode),
        }));

        let monthBranch = "ì¸";
        let monthStartName = "ì…ì¶˜";
        let monthStartLocal = bdsLocal[0].local;
        for (let i = 0; i < bdsLocal.length; i++) {
          const cur = bdsLocal[i];
          const next = bdsLocal[(i + 1) % bdsLocal.length];
          const nextLocal =
            i === bdsLocal.length - 1
              ? toLocalMillis(
                  computeMonthBoundaryTimesUTC(sajuYear + 1)[0].timeUTC,
                  tzOffsetMinutes,
                  dstMode
                )
              : next.local;

          if (birthMillisLocal >= cur.local && birthMillisLocal < nextLocal) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
            break;
          }
          if (i === bdsLocal.length - 1 && birthMillisLocal >= cur.local) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
          }
          if (i === bdsLocal.length - 1 && birthMillisLocal < bdsLocal[0].local) {
            monthBranch = "ì¶•";
            monthStartName = "ì†Œí•œ";
            monthStartLocal = cur.local;
          }
        }

        const yearPillar = ganzhiYear(sajuYear);
        const monthPillar = ganzhiMonth(yearPillar.stem, monthBranch);
        const adjustedForDay = adjustForZiDayBoundary(birthLocal, ziMode);
        const dayPillar = ganzhiDayFromGregorian(
          adjustedForDay.y,
          adjustedForDay.m,
          adjustedForDay.d
        );
        const hourBranch = getHourBranch(birthLocal.hh, birthLocal.mm, ziMode);
        const hourPillar = ganzhiHour(dayPillar.stem, hourBranch);

        const elements = tallyElements(
          { yearPillar, monthPillar, dayPillar, hourPillar },
          { hiddenMode }
        );

        return {
          input: {
            local: `${pad2(birthLocal.y)}-${pad2(birthLocal.m)}-${pad2(
              birthLocal.d
            )} ${pad2(birthLocal.hh)}:${pad2(birthLocal.mm)}`,
            ziMode,
            hiddenMode,
            tzOffsetMinutes,
            dstMode,
            sajuYear,
            monthStartName,
          },
          pillars: {
            year: yearPillar,
            month: monthPillar,
            day: dayPillar,
            hour: hourPillar,
            monthMeta: {
              start: new Date(monthStartLocal).toISOString(),
              startName: monthStartName,
            },
          },
          elements,
        };
      }

      function ganzhiYear(year) {
        const baseYear = 1984;
        const idx = mod(year - baseYear, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiMonth(yearStem, monthBranch) {
        const startStemByYearStem = {
          ê°‘: "ë³‘",
          ê¸°: "ë³‘",
          ì„: "ë¬´",
          ê²½: "ë¬´",
          ë³‘: "ê²½",
          ì‹ : "ê²½",
          ì •: "ì„",
          ì„: "ì„",
          ë¬´: "ê°‘",
          ê³„: "ê°‘",
        };
        const startStem = startStemByYearStem[yearStem] || "ë³‘";
        const order = [
          "ì¸",
          "ë¬˜",
          "ì§„",
          "ì‚¬",
          "ì˜¤",
          "ë¯¸",
          "ì‹ ",
          "ìœ ",
          "ìˆ ",
          "í•´",
          "ì",
          "ì¶•",
        ];
        const mIdx = order.indexOf(monthBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + mIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: monthBranch,
          text: `${STEMS_H[stemIdx]}${monthBranch}`,
        };
      }

      function ganzhiDayFromGregorian(y, m, d) {
        const jd = toJulianDayFromGregorian(y, m, d, 12, 0, 0);
        const jdJiaZi = toJulianDayFromGregorian(1984, 2, 2, 12, 0, 0);
        const idx = mod(Math.round(jd - jdJiaZi), 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiHour(dayStem, hourBranch) {
        const startStemByDayStem = {
          ê°‘: "ê°‘",
          ê¸°: "ê°‘",
          ì„: "ë³‘",
          ê²½: "ë³‘",
          ë³‘: "ë¬´",
          ì‹ : "ë¬´",
          ì •: "ê²½",
          ì„: "ê²½",
          ë¬´: "ì„",
          ê³„: "ì„",
        };
        const startStem = startStemByDayStem[dayStem] || "ê°‘";
        const order = [
          "ì",
          "ì¶•",
          "ì¸",
          "ë¬˜",
          "ì§„",
          "ì‚¬",
          "ì˜¤",
          "ë¯¸",
          "ì‹ ",
          "ìœ ",
          "ìˆ ",
          "í•´",
        ];
        const hIdx = order.indexOf(hourBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + hIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: hourBranch,
          text: `${STEMS_H[stemIdx]}${hourBranch}`,
        };
      }

      function ganzhiFromIndex(idx) {
        const stem = STEMS_H[idx % 10];
        const branch = BRANCHES_H[idx % 12];
        return { stem, branch, text: `${stem}${branch}` };
      }

      function getHourBranch(hh, mm, ziMode) {
        const minutes = hh * 60 + mm;
        const ziStart = ziMode === "2330" ? 23 * 60 + 30 : 23 * 60;
        if (minutes >= ziStart || minutes < (ziMode === "2330" ? 90 : 60)) {
          return "ì";
        }
        const base = ziMode === "2330" ? 90 : 60;
        const order = [
          "ì¶•",
          "ì¸",
          "ë¬˜",
          "ì§„",
          "ì‚¬",
          "ì˜¤",
          "ë¯¸",
          "ì‹ ",
          "ìœ ",
          "ìˆ ",
          "í•´",
        ];
        const delta = minutes - base;
        const idx = Math.floor(delta / 120);
        return order[Math.max(0, Math.min(order.length - 1, idx))] || "ì¶•";
      }

      function adjustForZiDayBoundary(kstParts, ziMode) {
        if (ziMode !== "2330") return kstParts;
        const minutes = kstParts.hh * 60 + kstParts.mm;
        if (minutes < 23 * 60 + 30) return kstParts;
        const dt = new Date(
          Date.UTC(kstParts.y, kstParts.m - 1, kstParts.d, 12, 0, 0)
        );
        dt.setUTCDate(dt.getUTCDate() + 1);
        return {
          y: dt.getUTCFullYear(),
          m: dt.getUTCMonth() + 1,
          d: dt.getUTCDate(),
          hh: kstParts.hh,
          mm: kstParts.mm,
        };
      }

      function tallyElements(pillars, { hiddenMode }) {
        const base = { ëª©: 0, í™”: 0, í† : 0, ê¸ˆ: 0, ìˆ˜: 0 };
        function addElem(elem, w = 1) {
          base[elem] = (base[elem] || 0) + w;
        }
        const list = [
          pillars.yearPillar,
          pillars.monthPillar,
          pillars.dayPillar,
          pillars.hourPillar,
        ];
        list.forEach((p) => addElem(STEM_ELEM[p.stem], 1));
        list.forEach((p) => addElem(BRANCH_MAIN_ELEM[p.branch], 1));
        if (hiddenMode === "on") {
          list.forEach((p) => {
            const arr = HIDDEN_STEMS[p.branch] || [];
            arr.forEach(([hs, w]) => addElem(STEM_ELEM[hs], w));
          });
        }
        const sorted = Object.entries(base).sort((a, b) => b[1] - a[1]);
        return { raw: base, sorted };
      }

      function parseLocalDateTime(dateStr, timeStr, baseOffsetMin, dstMode) {
        const [y, m, d] = dateStr.split("-").map(Number);
        const [hh, mm] = timeStr.split(":").map(Number);
        const offsetMin = getLocalOffsetMinutes(
          y,
          m,
          d,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        const utcMillis =
          Date.UTC(y, m - 1, d, hh, mm, 0) - offsetMin * 60 * 1000;
        return new Date(utcMillis);
      }

      function getLocalOffsetMinutes(
        y,
        m,
        d,
        hh,
        mm,
        baseOffsetMin,
        dstMode
      ) {
        let offset = baseOffsetMin;
        if (dstMode === "kr1988" && y === 1988) {
          const t = Date.UTC(y, m - 1, d, hh, mm, 0);
          const start = Date.UTC(1988, 4, 8, 2, 0, 0);
          const end = Date.UTC(1988, 9, 9, 3, 0, 0);
          if (t >= start && t < end) {
            offset = baseOffsetMin + 60;
          }
        }
        return offset;
      }

      function toLocalDateParts(utcDate, baseOffsetMin, dstMode) {
        let ms = utcDate.getTime() + baseOffsetMin * 60 * 1000;
        let d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth() + 1;
        const dd = d.getUTCDate();
        const hh = d.getUTCHours();
        const mm = d.getUTCMinutes();

        const off = getLocalOffsetMinutes(
          y,
          m,
          dd,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        ms = utcDate.getTime() + off * 60 * 1000;
        d = new Date(ms);

        return {
          y: d.getUTCFullYear(),
          m: d.getUTCMonth() + 1,
          d: d.getUTCDate(),
          hh: d.getUTCHours(),
          mm: d.getUTCMinutes(),
        };
      }

      function toLocalMillis(utcDate, baseOffsetMin, dstMode) {
        const parts = toLocalDateParts(utcDate, baseOffsetMin, dstMode);
        return Date.UTC(parts.y, parts.m - 1, parts.d, parts.hh, parts.mm, 0);
      }

      function localMillisFromParts(p) {
        return Date.UTC(p.y, p.m - 1, p.d, p.hh, p.mm, 0);
      }

      function toJulianDay(dateUTC) {
        const y = dateUTC.getUTCFullYear();
        const m = dateUTC.getUTCMonth() + 1;
        const d = dateUTC.getUTCDate();
        const hh = dateUTC.getUTCHours();
        const mm = dateUTC.getUTCMinutes();
        const ss = dateUTC.getUTCSeconds();
        return toJulianDayFromGregorian(y, m, d, hh, mm, ss);
      }

      function toJulianDayFromGregorian(y, m, d, hh, mm, ss) {
        let Y = y,
          M = m;
        if (M <= 2) {
          Y -= 1;
          M += 12;
        }
        const A = Math.floor(Y / 100);
        const B = 2 - A + Math.floor(A / 4);
        const dayFrac = (hh + (mm + ss / 60) / 60) / 24;
        const JD =
          Math.floor(365.25 * (Y + 4716)) +
          Math.floor(30.6001 * (M + 1)) +
          d +
          dayFrac +
          B -
          1524.5;
        return JD;
      }

      function normalizeDeg(x) {
        x = x % 360;
        if (x < 0) x += 360;
        return x;
      }
      function deg2rad(d) {
        return (d * Math.PI) / 180;
      }
      function shortestAngleDiffDeg(a, b) {
        let d = normalizeDeg(a) - normalizeDeg(b);
        d = ((d + 540) % 360) - 180;
        return d;
      }
      function mod(a, b) {
        return ((a % b) + b) % b;
      }
      function pad2(n) {
        return String(n).padStart(2, "0");
      }
      function formatTzOffset(mins) {
        const sign = mins >= 0 ? "+" : "-";
        const abs = Math.abs(mins);
        const hh = Math.floor(abs / 60);
        const mm = abs % 60;
        return `${sign}${pad2(hh)}:${pad2(mm)}`;
      }

      /* ======================================================
  5. ë£° + íŠœë‹ + ìš”ì•½ (50ê°œ)
====================================================== */
      const SECTION_WEIGHT = {
        ì„±í–¥: 0.25,
        ê´€ê³„: 0.25,
        ëˆ: 0.15,
        ì¼: 0.2,
        ê±´ê°•: 0.15,
      };

      const RULES = [
        {
          id: "ELEM_TOP_SAME",
          section: "ì„±í–¥",
          priority: 88,
          when: (a, b) =>
            a.topElem === b.topElem && a.topScore >= 1.2 && b.topScore >= 1.2,
          evidence: "ë‘˜ ë‹¤ {topElem}ê°€ ê°€ì¥ ê°•í•´ ê²°ì • ê¸°ì¤€ì´ ë¹„ìŠ·í•´.",
          copies: [
            "ì‹œì‘ ì†ë„ì™€ íŒë‹¨ì´ ì˜ ë§ì•„.",
            "ê³ ì§‘ ë¶™ì„ ë• ì‹ í˜¸ í•˜ë‚˜ë§Œ ë§ì¶”ì.",
          ],
        },
        {
          id: "ELEM_TOP_COMPLEMENT",
          section: "ê´€ê³„",
          priority: 82,
          when: (a, b) =>
            GENERATE[a.topElem] === b.topElem ||
            GENERATE[b.topElem] === a.topElem,
          evidence: "ìƒìƒ ê´€ê³„ì¸ ì˜¤í–‰ì´ ì„œë¡œì˜ ìµœê³ ì ì´ì•¼.",
          copies: [
            "ì„œë¡œ ë°€ì–´ì£¼ê³  ë°›ì³ì£¼ëŠ” êµ¬ì¡°.",
            "ì—­í•  ë¶„ë‹´ì´ ì˜ ë˜ë©´ ì„±ê³¼ê°€ í¬ë‹¤.",
          ],
        },
        {
          id: "ELEM_TOP_CLASH",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) =>
            OVERCOME[a.topElem] === b.topElem ||
            OVERCOME[b.topElem] === a.topElem,
          evidence: "ìƒê·¹ ê´€ê³„ì˜ ê°•ì ì´ ë¶€ë”ªíˆëŠ” í¸ì´ì•¼.",
          copies: [
            "ì˜ê²¬ì´ ê°ˆë¦´ ë• ìˆœì„œë§Œ ì •í•˜ë©´ ëœë‹¤.",
            "ê°ì • ì˜¬ë¼ì˜¬ ë• ì ê¹ ë©ˆì¶”ê³  ë‹¤ì‹œ.",
          ],
        },
        {
          id: "ELEM_WEAK_SAME",
          section: "ê±´ê°•",
          priority: 60,
          when: (a, b) =>
            a.weakElem === b.weakElem &&
            a.weakScore <= 0.7 &&
            b.weakScore <= 0.7,
          evidence: "ë‘˜ ë‹¤ {weakElem}ê°€ ì•½í•´ì„œ ê°™ì€ ì§€ì ì—ì„œ í”ë“¤ë ¤.",
          copies: [
            "ì•½ì ì´ ê²¹ì³ì„œ ì´í•´ëŠ” ë¹ ë¥´ë‹¤.",
            "ì´ êµ¬ê°„ì€ ë£¨í‹´ìœ¼ë¡œ ë³´ì™„í•˜ì.",
          ],
        },
        {
          id: "ELEM_WEAK_COMPLEMENT",
          section: "ê±´ê°•",
          priority: 70,
          when: (a, b) => a.weakElem === b.topElem || b.weakElem === a.topElem,
          evidence: "í•œìª½ ì•½ì ì„ ë‹¤ë¥¸ ìª½ ê°•ì ì´ ë©”ì›Œì¤„ ìˆ˜ ìˆì–´.",
          copies: ["ì„œë¡œ ë¹ˆì¹¸ì„ ì±„ìš°ëŠ” íƒ€ì….", "í˜ ë¹ ì§ˆ ë•Œ ë³´ì™„ì´ ì˜ ëœë‹¤."],
        },
        {
          id: "BALANCE_SIMILAR",
          section: "ì„±í–¥",
          priority: 78,
          when: (a, b) => Math.abs(a.balance - b.balance) <= 0.15,
          evidence: "ì˜¤í–‰ ë¶„í¬ ê· í˜•ë„ê°€ ë¹„ìŠ·í•œ í¸ì´ì•¼.",
          copies: ["ìƒí™œ ë¦¬ë“¬ì´ ì˜ ë§ëŠ” í¸.", "ì¼ìƒ ê¶í•©ì´ ë¶€ë“œëŸ½ë‹¤."],
        },
        {
          id: "BALANCE_DIFF",
          section: "ì„±í–¥",
          priority: 60,
          when: (a, b) => Math.abs(a.balance - b.balance) >= 0.45,
          evidence: "í•œìª½ì€ ì¹˜ìš°ì¹˜ê³  í•œìª½ì€ ì•ˆì •í˜•ì´ì•¼.",
          copies: [
            "ë°©ì‹ì€ ë‹¬ë¼ë„ ëª©ì ì€ ê°™ë‹¤.",
            "ì„¤ëª…ë§Œ ì¡°ê¸ˆ ë” í•˜ë©´ ì¥ì ì´ ëœë‹¤.",
          ],
        },
        {
          id: "BALANCE_BOTH_STABLE",
          section: "ì„±í–¥",
          priority: 76,
          when: (a, b) => a.balance <= 0.25 && b.balance <= 0.25,
          evidence: "ë‘˜ ë‹¤ ê· í˜•í˜•ì´ë¼ ê¸°ë³µì´ í¬ì§€ ì•Šì•„.",
          copies: ["ì¥ê¸°ì ìœ¼ë¡œ í¸í•œ ì¡°í•©.", "ë¬´ë¦¬ë§Œ ì•ˆ í•˜ë©´ ì•ˆì •ì ì´ì•¼."],
        },
        {
          id: "BALANCE_BOTH_SPIKY",
          section: "ì„±í–¥",
          priority: 60,
          when: (a, b) => a.balance >= 0.6 && b.balance >= 0.6,
          evidence: "ë‘˜ ë‹¤ ì¹˜ìš°ì¹œ í¸ì´ë¼ ë³€ìˆ˜ê°€ ë§ì„ ìˆ˜ ìˆì–´.",
          copies: [
            "ì§‘ì¤‘ë ¥ì€ ì¢‹ì§€ë§Œ ê³¼ì—´ë§Œ ì¡°ì‹¬.",
            "ë¦¬ë“¬ì„ ê°™ì´ ë§ì¶”ë©´ í›¨ì”¬ ì¢‹ì•„.",
          ],
        },
        {
          id: "A_DOMINANT",
          section: "ê´€ê³„",
          priority: 64,
          when: (a, b) => a.balance - b.balance >= 0.25,
          evidence: "Aì˜ ì—ë„ˆì§€ê°€ ì „ë°˜ì ìœ¼ë¡œ ë” ê°•í•´.",
          copies: [
            "Aê°€ ë°©í–¥ì„ ì¡ê³  Bê°€ ë³´ì™„í•˜ë©´ ì•ˆì •ì .",
            "ì£¼ë„ê¶Œë§Œ ê³¼í•˜ê²Œ ì¹˜ìš°ì¹˜ì§€ ì•Šê²Œ.",
          ],
        },
        {
          id: "B_DOMINANT",
          section: "ê´€ê³„",
          priority: 64,
          when: (a, b) => b.balance - a.balance >= 0.25,
          evidence: "Bì˜ ì—ë„ˆì§€ê°€ ì „ë°˜ì ìœ¼ë¡œ ë” ê°•í•´.",
          copies: [
            "Bê°€ ë°©í–¥ì„ ì¡ê³  Aê°€ ë³´ì™„í•˜ë©´ ì•ˆì •ì .",
            "ì£¼ë„ê¶Œë§Œ ê³¼í•˜ê²Œ ì¹˜ìš°ì¹˜ì§€ ì•Šê²Œ.",
          ],
        },
        {
          id: "SEASON_SUPPORT",
          section: "ê´€ê³„",
          priority: 80,
          when: (a, b) =>
            a.seasonTopElem === b.topElem || b.seasonTopElem === a.topElem,
          evidence: "ê³„ì ˆ íë¦„ì´ ìƒëŒ€ ê°•ì ì„ ë°€ì–´ì£¼ëŠ” êµ¬ì¡°ì•¼.",
          copies: [
            "ìš”ì¦˜ ê¶í•©ì´ íŠ¹íˆ ì˜ ë§ëŠ” í¸.",
            "ê°™ì´ ì›€ì§ì¼ìˆ˜ë¡ íë¦„ì„ íƒ„ë‹¤.",
          ],
        },
        {
          id: "SEASON_CLASH",
          section: "ê´€ê³„",
          priority: 58,
          when: (a, b) =>
            isSeasonClash(a.seasonTopElem, b.topElem) ||
            isSeasonClash(b.seasonTopElem, a.topElem),
          evidence: "ê³„ì ˆ íë¦„ì´ ìƒëŒ€ ê°•ì ê³¼ ìƒê·¹ì´ì•¼.",
          copies: ["ìš”ì¦˜ í…ì…˜ì´ ìƒê¸¸ ìˆ˜ ìˆì–´.", "ì‹œê¸° ì§€ë‚˜ë©´ ì™„í™”ëœë‹¤."],
        },
        {
          id: "SEASON_SAME",
          section: "ê´€ê³„",
          priority: 72,
          when: (a, b) =>
            a.seasonTopElem && a.seasonTopElem === b.seasonTopElem,
          evidence: "ë‘˜ ë‹¤ ê°™ì€ ê³„ì ˆ ì˜¤í–‰ ì˜í–¥ì´ë¼ í…œí¬ê°€ ë¹„ìŠ·í•´.",
          copies: ["ì§€ê¸ˆ ì‹œê¸°ì— í˜¸í¡ì´ ì˜ ë§ì•„.", "ê³„íšì„ ê°™ì´ ì¡ìœ¼ë©´ ë¹ ë¥´ë‹¤."],
        },
        {
          id: "BOTH_STRONG_MOK",
          section: "ì„±í–¥",
          priority: 76,
          when: (a, b) => a.elements["ëª©"] >= 1.4 && b.elements["ëª©"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ëª© ê¸°ìš´ì´ ê°•í•´ í™•ì¥/ì‹œë„ê°€ ë¹ ë¥¸ í¸ì´ì•¼.",
          copies: [
            "ì•„ì´ë””ì–´ê°€ ë§ì•„ì§€ê¸° ì‰¬ì›Œ.",
            "ìš°ì„ ìˆœìœ„ë§Œ ì¡ìœ¼ë©´ ì˜ êµ´ëŸ¬ê°„ë‹¤.",
          ],
        },
        {
          id: "BOTH_STRONG_HWA",
          section: "ì¼",
          priority: 76,
          when: (a, b) => a.elements["í™”"] >= 1.4 && b.elements["í™”"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ í™” ê¸°ìš´ì´ ê°•í•´ ì¶”ì§„ë ¥ì´ ì„¸ë‹¤.",
          copies: ["ê²°ì •ì€ ë¹ ë¥´ë‹¤.", "ê³¼ì—´ë§Œ ì¡°ì‹¬í•˜ë©´ ì„±ê³¼ê°€ í¬ë‹¤."],
        },
        {
          id: "BOTH_STRONG_TO",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => a.elements["í† "] >= 1.4 && b.elements["í† "] >= 1.4,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ê°•í•´ ì•ˆì •ê°ì´ ìˆë‹¤.",
          copies: ["ê¾¸ì¤€íˆ ìŒ“ëŠ” ë° ê°•í•˜ë‹¤.", "ì¥ê¸° ê³„íšì— ìœ ë¦¬."],
        },
        {
          id: "BOTH_STRONG_GEUM",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => a.elements["ê¸ˆ"] >= 1.4 && b.elements["ê¸ˆ"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ê°•í•´ ê´€ë¦¬ ê°ê°ì´ ì¢‹ë‹¤.",
          copies: ["ì§€ì¶œ ê¸°ì¤€ì´ ì˜ ë§ëŠ”ë‹¤.", "ì›ì¹™ í•©ì˜ê°€ ì‰¬ìš´ í¸."],
        },
        {
          id: "BOTH_STRONG_SU",
          section: "ê±´ê°•",
          priority: 74,
          when: (a, b) => a.elements["ìˆ˜"] >= 1.4 && b.elements["ìˆ˜"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ìˆ˜ ê¸°ìš´ì´ ê°•í•´ íšŒë³µ íƒ„ë ¥ì´ ì¢‹ë‹¤.",
          copies: ["ì‰¬ëŠ” íƒ€ì´ë°ë§Œ ë§ì¶”ë©´ í¸í•˜ë‹¤.", "ì»¨ë””ì…˜ íšŒë³µì´ ë¹ ë¥´ë‹¤."],
        },
        {
          id: "BOTH_WEAK_MOK",
          section: "ì„±í–¥",
          priority: 60,
          when: (a, b) => a.elements["ëª©"] <= 0.7 && b.elements["ëª©"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ëª© ê¸°ìš´ì´ ì•½í•´ ì‹œì‘ì´ ëŠë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì²« ë‹¨ì¶”ë§Œ ì¡ìœ¼ë©´ ì•ˆì •.", "ì´ˆë°˜ ì¶”ì§„ì„ ì„œë¡œ ë°€ì."],
        },
        {
          id: "BOTH_WEAK_HWA",
          section: "ì¼",
          priority: 60,
          when: (a, b) => a.elements["í™”"] <= 0.7 && b.elements["í™”"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ í™” ê¸°ìš´ì´ ì•½í•´ ì‹¤í–‰ ì†ë„ê°€ ë‚®ì„ ìˆ˜ ìˆì–´.",
          copies: ["ì‘ê²Œ ì‹œì‘í•˜ë©´ ì†ë„ ë¶™ëŠ”ë‹¤.", "ì¼ë‹¨ ì°©ìˆ˜í•˜ëŠ” ì•½ì†ì´ í•„ìš”."],
        },
        {
          id: "BOTH_WEAK_TO",
          section: "ê±´ê°•",
          priority: 60,
          when: (a, b) => a.elements["í† "] <= 0.7 && b.elements["í† "] <= 0.7,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ì•½í•´ ë¦¬ë“¬ì´ í”ë“¤ë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ë£¨í‹´ ê³ ì •í•˜ë©´ ì•ˆì •.", "ì‹ì‚¬/ìˆ˜ë©´ë§Œ ì§€í‚¤ì."],
        },
        {
          id: "BOTH_WEAK_GEUM",
          section: "ëˆ",
          priority: 58,
          when: (a, b) => a.elements["ê¸ˆ"] <= 0.7 && b.elements["ê¸ˆ"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ì•½í•´ ê¸°ì¤€ì´ ëŠìŠ¨í•´ì§ˆ ìˆ˜ ìˆì–´.",
          copies: ["ì§€ì¶œ ê¸°ì¤€ë¶€í„° ë§ì¶”ì.", "í°ëˆì€ í•©ì˜ë¡œ."],
        },
        {
          id: "BOTH_WEAK_SU",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => a.elements["ìˆ˜"] <= 0.7 && b.elements["ìˆ˜"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ìˆ˜ ê¸°ìš´ì´ ì•½í•´ íšŒë³µì´ ëŠë¦´ ìˆ˜ ìˆì–´.",
          copies: ["íœ´ì‹ ì¼ì •ì„ ê³µìœ í•˜ì.", "ì»¨ë””ì…˜ ê´€ë¦¬ê°€ í•µì‹¬."],
        },
        {
          id: "A_STRONG_MOK",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => a.elements["ëª©"] >= 1.5 && b.elements["ëª©"] <= 0.8,
          evidence: "Aì˜ ëª© ê¸°ìš´ì´ ê°•í•´ ë°©í–¥ì„ ì œì‹œí•˜ëŠ” ìª½ì´ì•¼.",
          copies: ["Aê°€ ì‹œì‘, Bê°€ ì •ë¦¬í•˜ë©´ ì¢‹ë‹¤.", "ì—­í• ë§Œ ë‚˜ëˆ„ë©´ í¸í•˜ë‹¤."],
        },
        {
          id: "A_STRONG_HWA",
          section: "ì¼",
          priority: 62,
          when: (a, b) => a.elements["í™”"] >= 1.5 && b.elements["í™”"] <= 0.8,
          evidence: "Aì˜ ì¶”ì§„ë ¥ì´ ë” ê°•í•´.",
          copies: ["Aê°€ ì†ë„, Bê°€ ì•ˆì •.", "íƒ€ì´ë°ë§Œ ë§ì¶”ë©´ ëœë‹¤."],
        },
        {
          id: "A_STRONG_TO",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => a.elements["í† "] >= 1.5 && b.elements["í† "] <= 0.8,
          evidence: "Aê°€ ì•ˆì •ê³¼ ê´€ë¦¬ ìª½ì„ ì¡ì•„ì£¼ê¸° ì¢‹ì•„.",
          copies: ["ê³„íšì€ Aê°€ ì¡ê³  Bê°€ ì‹¤í–‰.", "ì¥ê¸° ìš´ì˜ì— ìœ ë¦¬."],
        },
        {
          id: "B_STRONG_MOK",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => b.elements["ëª©"] >= 1.5 && a.elements["ëª©"] <= 0.8,
          evidence: "Bì˜ ëª© ê¸°ìš´ì´ ê°•í•´ ë°©í–¥ì„ ì œì‹œí•˜ëŠ” ìª½ì´ì•¼.",
          copies: ["Bê°€ ì‹œì‘, Aê°€ ì •ë¦¬í•˜ë©´ ì¢‹ë‹¤.", "ì—­í• ë§Œ ë‚˜ëˆ„ë©´ í¸í•˜ë‹¤."],
        },
        {
          id: "B_STRONG_HWA",
          section: "ì¼",
          priority: 62,
          when: (a, b) => b.elements["í™”"] >= 1.5 && a.elements["í™”"] <= 0.8,
          evidence: "Bì˜ ì¶”ì§„ë ¥ì´ ë” ê°•í•´.",
          copies: ["Bê°€ ì†ë„, Aê°€ ì•ˆì •.", "íƒ€ì´ë°ë§Œ ë§ì¶”ë©´ ëœë‹¤."],
        },
        {
          id: "B_STRONG_TO",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => b.elements["í† "] >= 1.5 && a.elements["í† "] <= 0.8,
          evidence: "Bê°€ ì•ˆì •ê³¼ ê´€ë¦¬ ìª½ì„ ì¡ì•„ì£¼ê¸° ì¢‹ì•„.",
          copies: ["ê³„íšì€ Bê°€ ì¡ê³  Aê°€ ì‹¤í–‰.", "ì¥ê¸° ìš´ì˜ì— ìœ ë¦¬."],
        },
        {
          id: "BRANCH_LIUHE",
          section: "ê´€ê³„",
          priority: 90,
          when: (a, b) => isLiuhe(a.dayBranch, b.dayBranch),
          evidence: "ì¼ì§€ ê¸°ì¤€ ìœ¡í•©ì´ ì„±ë¦½ë¼ ê¸°ë³¸ í˜¸í¡ì´ í¸í•´.",
          copies: ["ê°™ì´ ìˆìœ¼ë©´ ì´ìœ  ì—†ì´ í¸í•˜ë‹¤.", "ìƒí™œ í…œí¬ê°€ ì˜ ë§ëŠ”ë‹¤."],
        },
        {
          id: "BRANCH_SAMHAP",
          section: "ì¼",
          priority: 80,
          when: (a, b) => isSamhap(a.dayBranch, b.dayBranch),
          evidence: "ì‚¼í•© êµ¬ì¡°ë¼ ëª©í‘œë¥¼ í–¥í•´ í˜ì´ ëª¨ì—¬.",
          copies: ["ê°™ì€ ëª©í‘œì¼ ë•Œ í­ë°œë ¥ì´ ì¢‹ë‹¤.", "íŒ€í”Œì— ê°•í•œ ì¡°í•©."],
        },
        {
          id: "BRANCH_CHUNG",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => isChung(a.dayBranch, b.dayBranch),
          evidence: "ì§€ì§€ ì¶©ìœ¼ë¡œ íƒ€ì´ë°ì´ ìì£¼ ì—‡ê°ˆë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” ì»¨ë””ì…˜ ì¢‹ì„ ë•Œ.", "ì†ë„ë³´ë‹¤ íƒ€ì´ë° ë§ì¶”ì."],
        },
        {
          id: "BRANCH_HAE",
          section: "ì„±í–¥",
          priority: 58,
          when: (a, b) => isHae(a.dayBranch, b.dayBranch),
          evidence: "í•´ ê´€ê³„ê°€ ìˆì–´ ì˜¤í•´ê°€ ìŒ“ì¼ ìˆ˜ ìˆì–´.",
          copies: ["í™•ì¸ í•œ ë²ˆ ë” í•˜ë©´ í•´ê²°.", "ë¬¸ì¥ë³´ë‹¤ ì–¼êµ´ ë³´ê³ ."],
        },
        {
          id: "BRANCH_SELF_PUNISH",
          section: "ê±´ê°•",
          priority: 55,
          when: (a, b) =>
            a.dayBranch === b.dayBranch && isSelfPunish(a.dayBranch),
          evidence: "ê°™ì€ ì§€ì§€ë¼ ê°ì •ì„ ì•ˆìœ¼ë¡œ ìŒ“ê¸° ì‰¬ìš´ êµ¬ì¡°ì•¼.",
          copies: ["ê¸°ë¶„ì„ ë°”ë¡œ í’€ì.", "ì°¸ëŠ” ê²Œ ë¬¸ì œ í¬ì¸íŠ¸."],
        },
        {
          id: "BRANCH_SAME",
          section: "ê´€ê³„",
          priority: 70,
          when: (a, b) => a.dayBranch === b.dayBranch,
          evidence: "ì¼ì§€ê°€ ê°™ì•„ì„œ ê°ì • ì½”ë“œê°€ ë¹„ìŠ·í•´.",
          copies: ["ë§ì´ ì¤„ì–´ë„ í†µí•˜ëŠ” í¸.", "ê³ ì§‘ ë¶™ìœ¼ë©´ ì ê¹ ë©ˆì¶”ì."],
        },
        {
          id: "BRANCH_ELEM_SAME",
          section: "ì„±í–¥",
          priority: 66,
          when: (a, b) => BRANCH_ELEM[a.dayBranch] === BRANCH_ELEM[b.dayBranch],
          evidence: "ì¼ì§€ ì˜¤í–‰ì´ ê°™ì•„ í‘œí˜„ ë°©ì‹ì´ ìœ ì‚¬í•´.",
          copies: ["ì†Œí†µ ìŠ¤íƒ€ì¼ì´ ë§ëŠ”ë‹¤.", "ì˜¤í•´ê°€ ì ì€ í¸."],
        },
        {
          id: "BRANCH_ELEM_CLASH",
          section: "ê´€ê³„",
          priority: 60,
          when: (a, b) =>
            OVERCOME[BRANCH_ELEM[a.dayBranch]] === BRANCH_ELEM[b.dayBranch],
          evidence: "ì¼ì§€ ì˜¤í–‰ì´ ìƒê·¹ì´ë¼ ê¸°ë¶„ì´ ë¶€ë”ªí ìˆ˜ ìˆì–´.",
          copies: ["ê°ì • ì˜¬ë¼ì˜¤ë©´ ì†ë„ ì¤„ì´ì.", "ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” ì¤€ë¹„ëœ ë‚ ."],
        },
        {
          id: "BRANCH_ELEM_SUPPORT",
          section: "ê´€ê³„",
          priority: 70,
          when: (a, b) =>
            BRANCH_ELEM[a.dayBranch] === b.topElem ||
            BRANCH_ELEM[b.dayBranch] === a.topElem,
          evidence: "í•œìª½ì˜ ì¼ì§€ ê¸°ìš´ì´ ìƒëŒ€ ê°•ì ì„ ë°›ì³ì¤˜.",
          copies: [
            "ìƒëŒ€ ì¥ì ì„ ì˜ ì‚´ë ¤ì£¼ëŠ” ì¡°í•©.",
            "ì„œë¡œì˜ í˜ì´ìŠ¤ë¥¼ ì‚´ë¦¬ë©´ ì¢‹ë‹¤.",
          ],
        },
        {
          id: "MONEY_STYLE_MATCH",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) <= 0.4,
          evidence: "ëˆ ì“°ëŠ” ê¸°ì¤€ì´ ë¹„ìŠ·í•´ì„œ ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì ì–´.",
          copies: ["ê³µë™ ì§€ì¶œ ê¸°ì¤€ë§Œ ì •í•˜ë©´ ëœë‹¤.", "ê¸ˆì „ ê°ˆë“±ì´ ì ì€ ì¡°í•©."],
        },
        {
          id: "MONEY_STYLE_DIFF",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) >= 1.0,
          evidence: "ëˆ ì“°ëŠ” ê¸°ì¤€ì´ ê½¤ ë‹¤ë¥¼ ìˆ˜ ìˆì–´.",
          copies: ["ì•½ì†ë§Œ ì •í•˜ë©´ ë¬¸ì œ ì—†ë‹¤.", "í°ëˆì€ í•¨ê»˜, ì‘ì€ ê±´ ê°ì."],
        },
        {
          id: "MONEY_SAVING_GOOD",
          section: "ëˆ",
          priority: 76,
          when: (a, b) => a.elements["í† "] >= 1.2 && b.elements["í† "] >= 1.2,
          evidence: "ë‘˜ ë‹¤ í† ê°€ ë°›ì³ì„œ ì•ˆì •í˜• ì €ì¶•ì— ê°•í•´.",
          copies: ["ì¥ê¸° ê³„íš ì„¸ìš°ê¸° ì¢‹ë‹¤.", "ë¹„ìƒê¸ˆ ê´€ë¦¬ì— ê°•í•œ ì¡°í•©."],
        },
        {
          id: "MONEY_LEAK_RISK",
          section: "ëˆ",
          priority: 58,
          when: (a, b) => a.elements["ê¸ˆ"] <= 0.7 && b.elements["ê¸ˆ"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ì•½í•´ ì§€ì¶œ í†µì œê°€ ëŠìŠ¨í•´ì§ˆ ìˆ˜ ìˆì–´.",
          copies: [
            "ìë™ì´ì²´/í•œë„ ì„¤ì •ì´ ë‹µì´ì•¼.",
            "ì†Œì•¡ì´ë¼ë„ ê¸°ë¡í•´ë‘ë©´ ì•ˆì •ë¼.",
          ],
        },
        {
          id: "WORK_SPEED_MATCH",
          section: "ì¼",
          priority: 74,
          when: (a, b) => Math.abs(a.elements["í™”"] - b.elements["í™”"]) <= 0.3,
          evidence: "ì¼ ì²˜ë¦¬ ì†ë„ê°€ ë¹„ìŠ·í•´ í˜‘ì—…ì´ í¸í•´.",
          copies: ["ì†ë„ ì¡°ì ˆ ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì ì–´.", "ê°™ì€ í˜ì´ìŠ¤ë¡œ ë‹¬ë¦¬ë©´ ìµœê³ ."],
        },
        {
          id: "WORK_SPEED_DIFF",
          section: "ì¼",
          priority: 62,
          when: (a, b) => Math.abs(a.elements["í™”"] - b.elements["í™”"]) >= 0.8,
          evidence: "ì¼ ì²˜ë¦¬ ì†ë„ ì°¨ì´ê°€ ì»¤ì„œ ë§ˆì°°ì´ ìƒê¸¸ ìˆ˜ ìˆì–´.",
          copies: [
            "ê¸°í•œë§Œ ë¶„ëª…í•˜ê²Œ ë§ì¶”ì.",
            "ì†ë„ ì°¨ì´ëŠ” ì—­í•  ë¶„ë‹´ìœ¼ë¡œ í•´ê²°ëœë‹¤.",
          ],
        },
        {
          id: "WORK_IDEA_SUPPORT",
          section: "ì¼",
          priority: 72,
          when: (a, b) =>
            (a.elements["ëª©"] >= 1.3 && b.elements["í™”"] >= 1.3) ||
            (b.elements["ëª©"] >= 1.3 && a.elements["í™”"] >= 1.3),
          evidence: "í•œìª½ì€ ì•„ì´ë””ì–´, í•œìª½ì€ ì‹¤í–‰ì— ê°•í•´.",
          copies: [
            "ê¸°íšê³¼ ì‹¤í–‰ì´ ì˜ ë§ëŠ” ì¡°í•©.",
            "ì—­í• ë§Œ ëª…í™•íˆ í•˜ë©´ ì†ë„ê°€ ë‚œë‹¤.",
          ],
        },
        {
          id: "HEALTH_RECOVERY_GOOD",
          section: "ê±´ê°•",
          priority: 76,
          when: (a, b) => a.elements["ìˆ˜"] >= 1.2 && b.elements["ìˆ˜"] >= 1.2,
          evidence: "ë‘˜ ë‹¤ íšŒë³µ íƒ„ë ¥ì´ ì¢‹ì€ í¸ì´ì•¼.",
          copies: [
            "ì‰¬ëŠ” ë‚ ë§Œ ë§ì¶”ë©´ ì»¨ë””ì…˜ì´ í™• ì¢‹ì•„ì§„ë‹¤.",
            "ìˆ˜ë©´ë§Œ ì§€ì¼œë„ ë°˜ì€ ì„±ê³µ.",
          ],
        },
        {
          id: "HEALTH_RHYTHM_GAP",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => Math.abs(a.elements["ìˆ˜"] - b.elements["ìˆ˜"]) >= 0.8,
          evidence: "íšŒë³µ ë¦¬ë“¬ ì°¨ì´ê°€ ì»¤ì„œ í”¼ë¡œê°€ ì—‡ê°ˆë¦´ ìˆ˜ ìˆì–´.",
          copies: [
            "ì»¨ë””ì…˜ ì¢‹ì€ ë‚ ì— ì¤‘ìš”í•œ ì¼ ë°°ì¹˜.",
            "ê°ì ì‰¬ëŠ” íƒ€ì´ë°ì„ ì¡´ì¤‘í•˜ì.",
          ],
        },
        {
          id: "HEALTH_DIGEST",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => a.elements["í† "] <= 0.8 && b.elements["í† "] <= 0.8,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ì•½í•´ ì»¨ë””ì…˜ì´ í”ë“¤ë¦´ ìˆ˜ ìˆì–´.",
          copies: [
            "ì‹ì‚¬/ìˆ˜ë©´ ë£¨í‹´ë§Œ ì¡ì•„ë„ ì•ˆì •ëœë‹¤.",
            "ë¬´ë¦¬í•œ ì•½ì†ì„ ì¤„ì´ì.",
          ],
        },
        {
          id: "HEALTH_BALANCE_HELP",
          section: "ê±´ê°•",
          priority: 70,
          when: (a, b) =>
            (a.elements["í† "] >= 1.3 && b.elements["ìˆ˜"] >= 1.3) ||
            (b.elements["í† "] >= 1.3 && a.elements["ìˆ˜"] >= 1.3),
          evidence: "í•œìª½ì˜ ì•ˆì •ê°ê³¼ í•œìª½ì˜ íšŒë³µë ¥ì´ ì˜ ë§ì•„.",
          copies: [
            "ìƒí™œ ë¦¬ë“¬ì„ ê³µìœ í•˜ë©´ ì»¨ë””ì…˜ì´ ì¢‹ì•„ì§„ë‹¤.",
            "ê¾¸ì¤€í•œ íœ´ì‹ì´ ê°•ì .",
          ],
        },
      ];

      const TUNE_KEY = "compat_rule_tuning_v1";
      const TUNE_CFG_KEY = "compat_rule_tuning_cfg_v1";

      function loadTune() {
        try {
          return JSON.parse(localStorage.getItem(TUNE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveTune(v) {
        localStorage.setItem(TUNE_KEY, JSON.stringify(v));
      }
      function loadTuneCfg() {
        try {
          return (
            JSON.parse(localStorage.getItem(TUNE_CFG_KEY) || "{}") || {
              strength: 1,
            }
          );
        } catch {
          return { strength: 1 };
        }
      }
      function saveTuneCfg(cfg) {
        localStorage.setItem(TUNE_CFG_KEY, JSON.stringify(cfg));
      }
      function getTuneStrength() {
        return loadTuneCfg().strength ?? 1;
      }
      function getTunedPriority(rule) {
        const tune = loadTune();
        const delta = tune[rule.id] || 0;
        const strength = getTuneStrength();
        const tuned = rule.priority + delta * strength;
        return Math.max(40, Math.min(100, tuned));
      }
      function feedback(ruleId) {
        const t = loadTune();
        t[ruleId] = (t[ruleId] || 0) + 1.5;
        saveTune(t);
        updateTuneStatus();
      }
      function updateTuneStatus() {
        const t = loadTune();
        const keys = Object.keys(t);
        const strength = getTuneStrength();
        tuneStatus.textContent = keys.length
          ? `íŠœë‹ ì ìš© ì¤‘: ${keys.length}ê°œ ë£° (ê°•ë„ ${strength.toFixed(1)})`
          : `íŠœë‹ ì—†ìŒ (ê°•ë„ ${strength.toFixed(1)})`;
      }

      function buildPerson(person) {
        const { top, weak } = getTopWeak(person.elements);
        const monthBranch = person.monthBranch || "";
        const seasonTopElem = monthBranch ? BRANCH_MAIN_ELEM[monthBranch] : "";
        return {
          ...person,
          topElem: top,
          weakElem: weak,
          topScore: person.elements[top],
          weakScore: person.elements[weak],
          balance: calcBalance(person.elements),
          seasonTopElem,
          moneyStyle: person.elements["ê¸ˆ"] + person.elements["ìˆ˜"],
        };
      }

      function evaluateRules(a, b) {
        return RULES.filter((r) => r.when(a, b)).map((r) => ({
          ...r,
          tunedPriority: getTunedPriority(r),
        }));
      }

      function calcSectionScores(firedRules) {
        const result = {};
        Object.keys(SECTION_WEIGHT).forEach(
          (s) => (result[s] = { sum: 0, cnt: 0 })
        );
        firedRules.forEach((r) => {
          if (result[r.section]) {
            result[r.section].sum += r.tunedPriority;
            result[r.section].cnt += 1;
          }
        });
        const scores = {};
        Object.keys(result).forEach((s) => {
          scores[s] = result[s].cnt
            ? Math.round(result[s].sum / result[s].cnt)
            : 50;
        });
        return scores;
      }

      function calcTotalFromSections(sectionScores) {
        let total = 0;
        Object.entries(SECTION_WEIGHT).forEach(([k, w]) => {
          total += sectionScores[k] * w;
        });
        return Math.round(total);
      }

      function generateSummary(score) {
        if (score >= 85)
          return "ì „ë°˜ì ìœ¼ë¡œ ê¶í•©ì´ ê°•í•´. ê¸°ë³¸ ê²°ì´ ì˜ ë§ê³ , ì¥ê¸°ì ìœ¼ë¡œ ì•ˆì •ì ì´ì•¼.";
        if (score >= 70)
          return "ì¢‹ì€ í¸ì´ì•¼. í¬ì¸íŠ¸ ëª‡ ê°€ì§€ë§Œ ë§ì¶”ë©´ í›¨ì”¬ í¸í•´ì§ˆ ìˆ˜ ìˆì–´.";
        if (score >= 55)
          return "ë¬´ë‚œí•´. ì•½ì†ë§Œ ì˜ ì„¸ìš°ë©´ ì¶©ë¶„íˆ ì¢‹ì€ ê´€ê³„ë¡œ ê°ˆ ìˆ˜ ìˆì–´.";
        return "ë…¸ë ¥ì´ í•„ìš”í•œ ê¶í•©ì´ì•¼. ëŒ€ì‹  ê¸°ì¤€ë§Œ ë§ì¶”ë©´ ì˜ì™¸ë¡œ ë‹¨ë‹¨í•´ì§ˆ ìˆ˜ ìˆì–´.";
      }

      /* ======================================================
  6. í†¤ ë¶„ê¸°
====================================================== */
      const TONE = {
        couple: {
          title: "ì»¤í”Œ ëª¨ë“œ",
          soften: (s) =>
            s
              .replaceAll("ê·œì¹™", "ì•½ì†")
              .replaceAll("ê¸°í•œ", "íƒ€ì´ë°")
              .replaceAll("ë¦¬ìŠ¤í¬", "ì¡°ì‹¬ í¬ì¸íŠ¸"),
          tips: {
            conflict: [
              "ê°ì • ì˜¬ë¼ì˜¤ë©´ í•œ ë°•ì ì‰¬ê³  ë§í•˜ì.",
              "ë¬¸ìë³´ë‹¤ ì–¼êµ´ ë³´ê³  ì–˜ê¸°í•˜ëŠ” ê²Œ ë‹µ.",
            ],
            money: [
              "ëˆ ì–˜ê¸°ëŠ” ê¸°ì¤€ì„ ë¨¼ì € ë§ì¶”ëŠ” ê²Œ í¸í•´.",
              "í°ëˆë§Œ ê°™ì´ ê²°ì •í•˜ê³  ë‚˜ë¨¸ì§„ ììœ ë¡œ ê°€ì.",
            ],
          },
        },
        biz: {
          title: "ë™ì—…ì ëª¨ë“œ",
          soften: (s) =>
            s
              .replaceAll("ê°ì •", "ì»¤ë®¤ë‹ˆì¼€ì´ì…˜")
              .replaceAll("ì„œë¡œ", "ì–‘ì¸¡")
              .replaceAll("ì˜¤í•´", "ì •ë³´ ë¹„ëŒ€ì¹­"),
          tips: {
            conflict: [
              "ì˜ì‚¬ê²°ì • í”„ë¡œì„¸ìŠ¤ë¥¼ ë¬¸ì„œë¡œ ë°•ì•„.",
              "íšŒì˜ëŠ” ì˜ì œ 1ê°œì”©ë§Œ ì¡ì.",
            ],
            money: [
              "ì¬ë¬´ëŠ” ë£°ì´ ì•„ë‹ˆë¼ ì •ì±…ì´ë‹¤.",
              "ì§€ì¶œ ê¸°ì¤€/ìŠ¹ì¸ê¶Œì/í•œë„ë¥¼ ê³ ì •í•´.",
            ],
          },
        },
      };

      function applyTone(text, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        return t.soften(text);
      }
      function toneExtraTip(section, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        const pool = t.tips[section] || [];
        if (!pool.length) return "";
        return pool[hashToIndex(`${toneKey}|${section}`, pool.length)];
      }

      /* ======================================================
  7. ì„¹ì…˜ ë ˆì´ë” ë Œë”
====================================================== */
      function renderRadar(scores) {
        const svg = sectionRadarSvg;
        const keys = ["ì„±í–¥", "ê´€ê³„", "ëˆ", "ì¼", "ê±´ê°•"];
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = name;
          svg.appendChild(text);
        });

        const vals = keys.map((k) => clamp01((scores[k] ?? 50) / 100));
        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(37,99,235,0.28)",
          stroke: "rgba(37,99,235,0.9)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      /* ======================================================
  8. ì‹ ë…„ìš´ì„¸ ì›”ë³„
====================================================== */
      function pickMonthlyCopy(ctx) {
        const { month, seasonElem, top, weak, relTop, relWeak } = ctx;
        let mode = "steady";
        if (relTop === "ìƒ" || relTop === "ë™") mode = "push";
        if (relWeak === "ìƒ" || relWeak === "ë™")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "ê·¹" || relTop === "ëˆŒë¦¼") mode = "brake";

        const monthLabel = `${month}ì›”`;
        const templates = {
          push: [
            [
              `${monthLabel}ì€ íë¦„ì´ ë„¤ í¸ì´ì•¼. ë°€ì–´ë¶™ì´ë©´ ì„±ê³¼ê°€ ë‚œë‹¤.`,
              "ê°€ì¥ ì¤‘ìš”í•œ ì¼ 1ê°œë§Œ ë¨¼ì € ëë‚´.",
            ],
            [
              `${monthLabel}ì€ ì†ë„ê°€ ë¶™ëŠ” ë‹¬ì´ì•¼. ë¯¸ë£¨ë˜ ê±° ì²˜ë¦¬í•˜ê¸° ë”± ì¢‹ì•„.`,
              "ì—°ë½/ê²°ì •/ì •ë¦¬ ì¤‘ í•˜ë‚˜ëŠ” ì´ë²ˆ ë‹¬ì— ëë‚´.",
            ],
          ],
          pushPlus: [
            [
              `${monthLabel}ì€ ì¢‹ì€ íë¦„ + íšŒë³µê¹Œì§€ ê°™ì´ ì˜¤ëŠ” ë‹¬ì´ì•¼.`,
              "ìš•ì‹¬ë‚´ë„ ë˜ëŠ”ë°, ìˆ˜ë©´ë§Œì€ ê¼­ ì§€ì¼œ.",
            ],
            [
              `${monthLabel}ì€ ì˜ í’€ë¦¬ë©´ì„œ í¸í•´ì§€ëŠ” ë‹¬ì´ì•¼.`,
              "ìƒˆë¡œ ë²Œë¦¬ê¸°ë³´ë‹¤ ê¸°ì¡´ ê±¸ ì—…ê·¸ë ˆì´ë“œí•˜ë©´ í¬ê²Œ ë‚¨ì•„.",
            ],
          ],
          recover: [
            [
              `${monthLabel}ì€ íšŒë³µì´ ë³µì´ë‹¤. ì»¨ë””ì…˜ë§Œ ì¡ì•„ë„ ì¼ì´ í’€ë¦°ë‹¤.`,
              "ë¬´ë¦¬í•œ ì•½ì† ì¤„ì´ê³  ë£¨í‹´ í•˜ë‚˜ ë¶™ì—¬.",
            ],
            [
              `${monthLabel}ì€ ì •ë¦¬í•˜ë©´ ìš´ì´ ë¶™ëŠ” ë‹¬ì´ì•¼.`,
              "ê³µê°„/ëˆ/ì¼ì • ì¤‘ í•˜ë‚˜ë§Œ ì •ë¦¬í•´ë„ ì²´ê° ì˜¨ë‹¤.",
            ],
          ],
          brake: [
            [
              `${monthLabel}ì€ ë¬´ë¦¬í•˜ë©´ ì†í•´ ë³´ëŠ” ë‹¬ì´ì•¼. ì†ë„ ì¤„ì´ëŠ” ê²Œ ì´ë“.`,
              "í° ê²°ì •ì€ 2ì£¼ë§Œ ë¯¸ë£¨ê³  í™•ì¸ë¶€í„° í•´.",
            ],
            [
              `${monthLabel}ì€ ì‹ ì¤‘ì´ ê³§ ëˆì´ë‹¤.`,
              "ê³„ì•½/íˆ¬ì/ì¶©ë™êµ¬ë§¤ëŠ” í•œ ë²ˆ ë” ì²´í¬.",
            ],
          ],
          steady: [
            [
              `${monthLabel}ì€ ìœ ì§€ê°€ ì´ê¸°ëŠ” ë‹¬ì´ì•¼. ê¸°ë³¸ë§Œ ì§€ì¼œë„ ì¶©ë¶„í•´.`,
              "ë£¨í‹´ 3ê°œ(ìˆ˜ë©´/ì‹ì‚¬/ì •ë¦¬)ë§Œ ì±™ê²¨.",
            ],
            [
              `${monthLabel}ì€ í° ë³€í™”ë³´ë‹¤ ì‘ì€ ê°œì„ ì´ ë§ì•„.`,
              "5% ê°œì„  ëª©í‘œë¡œ ê°€ë©´ ê¾¸ì¤€íˆ ì´ê¸´ë‹¤.",
            ],
          ],
        };

        const seed = `${month}|${seasonElem}|${top}|${weak}|${mode}`;
        const arr = templates[mode];
        const idx = hashToIndex(seed, arr.length);
        const [oneLine, tip] = arr[idx];
        return { oneLine, tip, tags: [mode, seasonElem] };
      }

      function makeMonthlyLuck(person) {
        const { top, weak } = getTopWeak(person.elements);
        const months = [];
        for (let m = 1; m <= 12; m++) {
          const flow = MONTH_FLOW[m];
          const s = flow.seasonTop;
          const relTop = relationElem(top, s);
          const relWeak = relationElem(weak, s);
          const { oneLine, tip, tags } = pickMonthlyCopy({
            month: m,
            seasonElem: s,
            top,
            weak,
            relTop,
            relWeak,
          });
          months.push({
            month: m,
            seasonElem: s,
            monthBranch: flow.monthBranch,
            summary: oneLine,
            tip,
            tags,
          });
        }
        return months;
      }

      function renderMonthly(person) {
        monthlyList.innerHTML = makeMonthlyLuck(person)
          .map(
            (m) => `
            <div class="rule-card">
              <div class="row" style="justify-content: space-between">
                <div class="section-title">${m.month}ì›” Â· ${
              m.seasonElem
            } íë¦„</div>
                <span class="mini">${m.tags.join(" Â· ")}</span>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              <p class="mini">íŒ: ${escapeHtml(m.tip)}</p>
            </div>`
          )
          .join("");
      }

      /* ======================================================
  9. ë Œë”
====================================================== */
      function renderSummary(totalScore, firedRules, toneKey, coupleElements) {
        const summary = generateSummary(totalScore);
        totalScoreEl.textContent = `${totalScore}ì `;
        summaryMain.textContent = summary;
        summarySub.textContent = "ì…ë ¥ ì‹œê°„ëŒ€ ê¸°ì¤€ Â· ì ˆê¸°/ì˜¤í–‰ ê·œì¹™";

        const { top, weak } = getTopWeak(coupleElements);
        const pills = [
          `í•µì‹¬ ì˜¤í–‰: ${top}`,
          `ì•½í•œ ì˜¤í–‰: ${weak}`,
          `ë°œë™ ë£°: ${firedRules.length}ê°œ`,
          TONE[toneKey]?.title || "ì»¤í”Œ ëª¨ë“œ",
        ];
        summaryPills.innerHTML = pills
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");
      }

      function renderRules(firedRules, toneKey, tokens) {
        if (!firedRules.length) {
          ruleList.innerHTML = `<p class="mini">ë°œë™ëœ ë£°ì´ ì•„ì§ ì—†ì–´. ì…ë ¥ê°’ì„ í™•ì¸í•´ì¤˜.</p>`;
          return;
        }

        ruleList.innerHTML = firedRules
          .sort((a, b) => b.tunedPriority - a.tunedPriority)
          .map((r) => {
            const evidence = applyTone(fillTokens(r.evidence, tokens), toneKey);
            const copy = applyTone(r.copies[0], toneKey);
            const extra =
              r.section === "ëˆ"
                ? toneExtraTip("money", toneKey)
                : toneExtraTip("conflict", toneKey);
            return `
            <div class="rule-card">
              <div class="rule-head">
                <b>${escapeHtml(r.id)}</b>
                <button class="like-btn" data-rule="${r.id}">ê³µê° ğŸ‘</button>
              </div>
              <p class="mini">ê·¼ê±°: ${escapeHtml(evidence)}</p>
              <p>${escapeHtml(copy)}${
              extra
                ? `<br/><span class="mini">+ ${escapeHtml(extra)}</span>`
                : ""
            }</p>
            </div>`;
          })
          .join("");
      }

      function renderPillars(targetEl, result) {
        if (!result) {
          targetEl.textContent = "â€”";
          return;
        }
        const p = result.pillars;
        const tzText = formatTzOffset(result.input.tzOffsetMinutes);
        targetEl.innerHTML = `ì…ë ¥: ${result.input.local} (UTC${tzText})<br/>
          ì—°: ${p.year.text} / ì›”: ${p.month.text}<br/>
          ì¼: ${p.day.text} / ì‹œ: ${p.hour.text}`;
      }

      function renderElementsAnalysis(elements) {
        const keys = ["ëª©", "í™”", "í† ", "ê¸ˆ", "ìˆ˜"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const topIdx = values.indexOf(Math.max(...values));
        const lowIdx = values.indexOf(Math.min(...values));
        const top = keys[topIdx];
        const low = keys[lowIdx];
        const personality = getElementPersonality(top, low);

        const rounded = keys.reduce((acc, k) => {
          acc[k] = Math.round((elements[k] || 0) * 10) / 10;
          return acc;
        }, {});

        elementsSummary.textContent = `ì§€ê¸ˆì€ ${top} ê¸°ìš´ì´ ê°€ì¥ ê°•í•˜ê³ , ${low} ê¸°ìš´ì´ ìƒëŒ€ì ìœ¼ë¡œ ì•½í•œ í¸ì´ì•¼.`;
        renderElementsRadar(elements);

        const detailLines = [
          `ì˜¤í–‰ ë¶„í¬: ëª© ${rounded["ëª©"]} Â· í™” ${rounded["í™”"]} Â· í†  ${rounded["í† "]} Â· ê¸ˆ ${rounded["ê¸ˆ"]} Â· ìˆ˜ ${rounded["ìˆ˜"]}`,
          `ê°•í•œ ${top}: ì§‘ì¤‘/ì¶”ì§„ ìª½ìœ¼ë¡œ ì“°ë©´ ì„±ê³¼ê°€ ë¹¨ë¼ì ¸. íŠ¹íˆ ${top}ëŠ” í˜„ì¬ ì „ì²´ì˜ ì•½ ${Math.round(
            (values[topIdx] / maxVal) * 100
          )}% ìˆ˜ì¤€ì´ì•¼.`,
          `ì•½í•œ ${low}: ë£¨í‹´/í™˜ê²½ ë³´ì™„ìœ¼ë¡œ ì¶©ë¶„íˆ ë©”ê¿€ ìˆ˜ ìˆì–´. ${low}ëŠ” ì§€ê¸ˆ ê°€ì¥ ë‚®ì€ êµ¬ê°„ì´ë¼ ì˜ì‹ì ìœ¼ë¡œ ì±™ê¸°ëŠ” ê²Œ ì¢‹ì•„.`,
          `ì„±í–¥ ìš”ì•½: ${personality}`,
          `ê· í˜• íŒ: ìƒìƒ êµ¬ì¡°ë¥¼ ë”°ë¼ ${top}ì˜ ì¥ì ì„ ì‚´ë¦¬ë˜, ${low}ë¥¼ ë°›ì³ì¤„ ìƒí™œ ìŠµê´€ì„ í•˜ë‚˜ë§Œ ê³ ì •í•˜ë©´ íë¦„ì´ ì•ˆì •ë¼.`,
        ];
        elementsDetail.innerHTML = detailLines.map((l) => escapeHtml(l)).join("<br/>");
      }

      function getElementPersonality(top, low) {
        const topMap = {
          ëª©: "í™•ì¥í˜•. ì•„ì´ë””ì–´/ê°œì²™ì— ê°•í•˜ê³ , ë¹ ë¥´ê²Œ ì›€ì§ì—¬.",
          í™”: "í‘œí˜„í˜•. ì¶”ì§„/ì—´ì •ì´ ê°•í•˜ê³ , ë¶„ìœ„ê¸°ë¥¼ ì£¼ë„í•´.",
          í† : "ì•ˆì •í˜•. ì¡°ìœ¨/ê´€ë¦¬ ì¤‘ì‹¬ì´ë©°, ì‹ ë¢°ê°€ ìì‚°ì´ì•¼.",
          ê¸ˆ: "ì •ë°€í˜•. ê¸°ì¤€/ì›ì¹™ì´ ëšœë ·í•˜ê³ , ê²°ì •ì´ ë¹ ë¥¸ í¸ì´ì•¼.",
          ìˆ˜: "ë¶„ì„í˜•. ì •ë³´/íë¦„ì„ ì½ê³ , ìœ ì—°í•˜ê²Œ ëŒ€ì‘í•´.",
        };
        const lowMap = {
          ëª©: "ìƒˆë¡œìš´ ì‹œë„ëŠ” ì‰¬ëŠ”ë° ë§ˆë¬´ë¦¬ê°€ ì•½í•´ì§ˆ ìˆ˜ ìˆì–´.",
          í™”: "í¥ì´ ë–¨ì–´ì§€ë©´ ë™ë ¥ì´ ê¸‰ê°í•  ìˆ˜ ìˆì–´.",
          í† : "ë£¨í‹´ì´ ííŠ¸ëŸ¬ì§€ë©´ ë¶ˆì•ˆì •í•´ì§ˆ ìˆ˜ ìˆì–´.",
          ê¸ˆ: "ê²°ì • ê¸°ì¤€ì´ í”ë“¤ë¦¬ë©´ ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì»¤ì§ˆ ìˆ˜ ìˆì–´.",
          ìˆ˜: "ê³¼í•œ ì •ë³´ íƒìƒ‰ìœ¼ë¡œ ê²°ì •ì´ ëŠ¦ì–´ì§ˆ ìˆ˜ ìˆì–´.",
        };
        const topLine = topMap[top] || "ê¸°ì§ˆì˜ ì¤‘ì‹¬ì´ ë˜ëŠ” ì„±í–¥ì´ ë˜ë ·í•´.";
        const lowLine = lowMap[low] || "ì•½í•œ ì¶•ì„ ë³´ì™„í•˜ë©´ ì•ˆì •ê°ì´ ì˜¬ë¼ê°€.";
        return `${topLine} ${lowLine}`;
      }

      function renderElementsRadar(elements) {
        const svg = elementsRadarSvg;
        const keys = ["ëª©", "í™”", "í† ", "ê¸ˆ", "ìˆ˜"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const vals = values.map((v) => clamp01(v / maxVal));
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = `${name} ${Math.round((elements[name] || 0) * 10) / 10}`;
          svg.appendChild(text);
        });

        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(245,158,11,0.25)",
          stroke: "rgba(217,119,6,0.95)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        const dots = vals.map((v, i) => {
          const dot = el("circle", {
            cx: cx,
            cy: cy,
            r: "3.5",
            fill: "rgba(217,119,6,0.95)",
          });
          svg.appendChild(dot);
          return { dot, v, i };
        });

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          dots.forEach(({ dot, v, i }) => {
            const [dx, dy] = pt(v * p, i);
            dot.setAttribute("cx", dx.toFixed(2));
            dot.setAttribute("cy", dy.toFixed(2));
          });
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      function getGenerator(elem) {
        const map = { í™”: "ëª©", í† : "í™”", ê¸ˆ: "í† ", ìˆ˜: "ê¸ˆ", ëª©: "ìˆ˜" };
        return map[elem] || "";
      }

      function getOvercomeElem(elem) {
        const entries = Object.entries(OVERCOME);
        const found = entries.find(([, v]) => v === elem);
        return found ? found[0] : "";
      }

      function getYongshinSuggestion(person) {
        const suggestions = [];
        const genWeak = getGenerator(person.weakElem);
        const controlTop = getOvercomeElem(person.topElem);
        if (person.weakScore <= 0.8 && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `ì•½í•œ ${person.weakElem} ë³´ì™„`,
          });
        }
        if (person.topScore >= 1.4 && controlTop) {
          suggestions.push({
            elem: controlTop,
            reason: `ê°•í•œ ${person.topElem} ì¡°ì ˆ`,
          });
        }
        if (!suggestions.length && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `ê· í˜• ìœ ì§€`,
          });
        }
        return suggestions;
      }

      function renderDeepAnalysisCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderDeepBlock("A", a));
        if (b) blocks.push(renderDeepBlock("B", b));
        deepAnalysis.innerHTML = blocks.join("");
      }

      function renderDeepBlock(label, person) {
        const yongshin = getYongshinSuggestion(person);
        const yongText = yongshin.length
          ? yongshin.map((y) => `${y.elem}(${y.reason})`).join(", ")
          : "â€”";
        const season =
          person.monthBranch && person.seasonTopElem
            ? `${person.monthBranch}(${person.seasonTopElem})`
            : "â€”";
        const seasonLine =
          person.seasonTopElem && person.topElem === person.seasonTopElem
            ? "ì›”ë ¹ê³¼ ê°•ì ì´ ê°™ì•„ ìì—°ìŠ¤ëŸ½ê²Œ í˜ì´ ì‹¤ë¦¬ëŠ” íƒ€ì…."
            : "ì›”ë ¹ê³¼ ê°•ì ì´ ë‹¬ë¼ ì¡°ìœ¨Â·ë³´ì™„ì´ ì¤‘ìš”í•´.";

        return `
          <div class="rule-card">
            <div class="section-title">${label} ì‹¬í™” ìš”ì•½</div>
            <div class="mini">ê°„ì´ ìš©ì‹ : ${escapeHtml(yongText)}</div>
            <div class="mini">ê²©êµ­(ê°„ì´): ì›”ì§€ ${escapeHtml(
              season
            )} ì¤‘ì‹¬. ${escapeHtml(seasonLine)}</div>
          </div>
        `;
      }

      function getLocalNowYear(tzOffsetMinutes, dstMode) {
        const parts = toLocalDateParts(new Date(), tzOffsetMinutes, dstMode);
        return parts.y;
      }

      function pickYearMode(relTop, relWeak) {
        let mode = "steady";
        if (relTop === "ìƒ" || relTop === "ë™") mode = "push";
        if (relWeak === "ìƒ" || relWeak === "ë™")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "ê·¹" || relTop === "ëˆŒë¦¼") mode = "brake";
        return mode;
      }

      function yearModeText(mode) {
        const map = {
          push: "í™•ì¥/ì¶”ì§„ì— ìœ ë¦¬",
          pushPlus: "ì„±ê³¼+íšŒë³µ ë™ì‹œ",
          recover: "ì •ë¦¬/íšŒë³µì— ìœ ë¦¬",
          brake: "ì†ë„ ì¡°ì ˆ í•„ìš”",
          steady: "ê¸°ë³¸ ìœ ì§€",
        };
        return map[mode] || "ê¸°ë³¸ ìœ ì§€";
      }

      function buildYearFlows(person, tzOffsetMinutes, dstMode) {
        const startYear = getLocalNowYear(tzOffsetMinutes, dstMode);
        const flows = [];
        for (let i = 0; i < 10; i++) {
          const year = startYear + i;
          const pillar = ganzhiYear(year);
          const yearElem = STEM_ELEM[pillar.stem];
          const relTop = relationElem(yearElem, person.topElem);
          const relWeak = relationElem(yearElem, person.weakElem);
          const mode = pickYearMode(relTop, relWeak);
          flows.push({
            year,
            pillar,
            yearElem,
            mode,
          });
        }
        return flows;
      }

      function summarizeDecades(flows) {
        const buckets = {};
        flows.forEach((f) => {
          const start = f.year - (f.year % 10);
          if (!buckets[start]) buckets[start] = [];
          buckets[start].push(f);
        });
        return Object.entries(buckets).map(([start, list]) => {
          const counts = list.reduce((acc, cur) => {
            acc[cur.mode] = (acc[cur.mode] || 0) + 1;
            return acc;
          }, {});
          const topMode = Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];
          return {
            range: `${start}~${Number(start) + 9}`,
            mode: topMode,
          };
        });
      }

      function renderLuckFlowCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderLuckBlock("A", a));
        if (b) blocks.push(renderLuckBlock("B", b));
        luckFlow.innerHTML = blocks.join("");
      }

      function renderLuckBlock(label, person) {
        const tzOffsetMinutes = person.tzOffsetMinutes ?? 540;
        const dstMode = person.dstMode || "off";
        const flows = buildYearFlows(person, tzOffsetMinutes, dstMode);
        const decades = summarizeDecades(flows);
        const yearLines = flows
          .map(
            (f) =>
              `${f.year}ë…„ ${f.pillar.text}(${f.yearElem}) Â· ${yearModeText(
                f.mode
              )}`
          )
          .join("<br/>");
        const decadeLines = decades
          .map((d) => `${d.range}: ${yearModeText(d.mode)}`)
          .join(" Â· ");

        return `
          <div class="rule-card">
            <div class="section-title">${label} ëŒ€ìš´/ì„¸ìš´</div>
            <div class="mini">ëŒ€ìš´(10ë…„): ${escapeHtml(decadeLines)}</div>
            <div class="mini">ì„¸ìš´(10ë…„): ${yearLines}</div>
          </div>
        `;
      }

      function setResultVisibility(mode) {
        resultElementsCard.classList.toggle("hidden", !state.A);
        resultDeepCard.classList.toggle("hidden", !state.A);
        resultLuckCard.classList.toggle("hidden", !state.A);
        resultTodayCard.classList.toggle("hidden", mode === "newyear");
        resultRadarCard.classList.toggle("hidden", mode !== "compat");
        resultABCard.classList.toggle("hidden", mode !== "compat");
        resultRulesCard.classList.toggle("hidden", mode !== "compat");
        resultMonthlyCard.classList.toggle("hidden", mode === "today");
        tuningCard.classList.toggle("hidden", mode !== "compat");
      }

      function renderCompat() {
        const a = buildPerson(state.A);
        const b = buildPerson(state.B);
        const toneKey = toneSelect.value;
        const firedRules = evaluateRules(a, b);
        const sectionScores = calcSectionScores(firedRules);
        const totalScore = calcTotalFromSections(sectionScores);
        const coupleElements = combineElements(a.elements, b.elements);
        const coupleStats = getTopWeak(coupleElements);

        resultTitle.textContent = "ê¶í•© ìš”ì•½";
        renderElementsAnalysis(coupleElements);
        renderDeepAnalysisCard(a, b);
        renderLuckFlowCard(a, b);
        renderSummary(totalScore, firedRules, toneKey, coupleElements);
        renderTodayCoupleBox(a, b);
        renderRadar(sectionScores);
        renderRules(firedRules, toneKey, {
          topElem: coupleStats.top,
          weakElem: coupleStats.weak,
          A_topElem: a.topElem,
          B_topElem: b.topElem,
          A_weakElem: a.weakElem,
          B_weakElem: b.weakElem,
          A_branch: a.dayBranch,
          B_branch: b.dayBranch,
          A_season: a.seasonTopElem,
          B_season: b.seasonTopElem,
        });
        renderMonthly({ elements: coupleElements });
        renderPillars(aPillarsEl, state.aResult);
        renderPillars(bPillarsEl, state.bResult);

        return { totalScore, firedRules, coupleElements };
      }

      function renderNewYear() {
        const a = buildPerson(state.A);
        const { top, weak } = getTopWeak(a.elements);
        resultTitle.textContent = "ì‹ ë…„ìš´ì„¸ ìš”ì•½";
        renderElementsAnalysis(a.elements);
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "â€”";
        summarySub.textContent = "2026 íë¦„ Â· ì›”ë³„ ìš´ì„¸";
        summaryMain.textContent = `2026ë…„ì€ ${top} ê¸°ìš´ì´ í˜ì´ ë˜ê³ , ${weak} ìª½ì„ ë³´ì™„í•˜ë©´ íë¦„ì´ ì¢‹ì•„ì ¸.`;
        summaryPills.innerHTML = [
          `í•µì‹¬ ì˜¤í–‰: ${top}`,
          `ì•½í•œ ì˜¤í–‰: ${weak}`,
          "2026 ì›”ë³„ íë¦„",
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = "â€”";
        todayCoupleMeta.textContent = "";
        renderMonthly({ elements: a.elements });
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";

        return { totalScore: null, coupleElements: a.elements };
      }

      function renderTodayOnly() {
        const a = buildPerson(state.A);
        resultTitle.textContent = "ì˜¤ëŠ˜ìš´ì„¸ ìš”ì•½";
        renderElementsAnalysis(a.elements);
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "â€”";
        summarySub.textContent = "ì˜¤ëŠ˜ ì¼ì§„ ê¸°ë°˜";
        summaryMain.textContent = todayLuckLine(a);
        summaryPills.innerHTML = [
          `í•µì‹¬ ì˜¤í–‰: ${a.topElem}`,
          `ì•½í•œ ì˜¤í–‰: ${a.weakElem}`,
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = todayLuckLine(a);
        todayCoupleMeta.textContent = `ì˜¤ëŠ˜ ì˜¤í–‰: ${
          getTodayElementFlow().stemElem
        }/${getTodayElementFlow().branchElem}`;
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";
      }

      function renderAll() {
        if (!state.A) return;
        setResultVisibility(state.mode);
        if (state.mode === "compat") return renderCompat();
        if (state.mode === "newyear") return renderNewYear();
        return renderTodayOnly();
      }

      /* ======================================================
  10. ê³µìœ  ì¹´ë“œ
====================================================== */
      function roundRect(ctx, x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let i = 0; i < words.length; i++) {
          const test = line + words[i] + " ";
          if (ctx.measureText(test).width > maxWidth && i > 0) {
            ctx.fillText(line, x, y);
            line = words[i] + " ";
            y += lineHeight;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, y);
      }

      async function generateShareCard(payload) {
        const c = document.getElementById("shareCanvas");
        const ctx = c.getContext("2d");

        const g = ctx.createLinearGradient(0, 0, 0, c.height);
        g.addColorStop(0, "#0b1621");
        g.addColorStop(0.5, "#101f2e");
        g.addColorStop(1, "#14273b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, c.width, c.height);

        const pad = 70;
        const cardX = pad;
        const cardY = pad;
        const cardW = c.width - pad * 2;
        const cardH = c.height - pad * 2;
        roundRect(
          ctx,
          cardX,
          cardY,
          cardW,
          cardH,
          40,
          "rgba(255,255,255,0.92)"
        );

        ctx.fillStyle = "#0f172a";
        ctx.font = "800 52px IBM Plex Sans KR";
        ctx.fillText(payload.title, cardX + 50, cardY + 120);

        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.toneLabel, cardX + 50, cardY + 170);

        ctx.font = "800 110px IBM Plex Sans KR";
        ctx.fillStyle = "#0f172a";
        ctx.fillText(String(payload.scoreText), cardX + 50, cardY + 300);
        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.scoreLabel, cardX + 50, cardY + 350);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.85)";
        ctx.fillText(`í•µì‹¬ ì˜¤í–‰: ${payload.topElem}`, cardX + 50, cardY + 430);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        wrapText(
          ctx,
          `ìš”ì•½: ${payload.summary}`,
          cardX + 50,
          cardY + 510,
          cardW - 100,
          44
        );

        ctx.font = "700 28px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.78)";
        wrapText(
          ctx,
          payload.todayLine,
          cardX + 50,
          cardY + 700,
          cardW - 100,
          40
        );

        ctx.font = "700 26px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.6)";
        ctx.fillText("funnyfunny.cloud", cardX + 50, cardY + cardH - 70);

        return new Promise((resolve) => c.toBlob(resolve, "image/png", 1.0));
      }

      function getSharePayload(snapshot) {
        if (state.mode === "compat") {
          return {
            title: "ê¶í•© ë¦¬í¬íŠ¸",
            toneLabel: TONE[toneSelect.value]?.title || "ì»¤í”Œ ëª¨ë“œ",
            scoreText: snapshot.totalScore,
            scoreLabel: "ê¶í•© ì ìˆ˜",
            summary: summaryMain.textContent,
            todayLine: todayCoupleLine.textContent,
            topElem: getTopWeak(snapshot.coupleElements).top,
          };
        }
        if (state.mode === "newyear") {
          const topElem = getTopWeak(state.A.elements).top;
          return {
            title: "ì‹ ë…„ìš´ì„¸ ë¦¬í¬íŠ¸",
            toneLabel: "2026 íë¦„",
            scoreText: "â€”",
            scoreLabel: "ìš´ì„¸ ìš”ì•½",
            summary: summaryMain.textContent,
            todayLine: "ì›”ë³„ íë¦„ìœ¼ë¡œ ê³„íš ì„¸ìš°ê¸° ì¢‹ë‹¤.",
            topElem,
          };
        }
        const topElem = getTopWeak(state.A.elements).top;
        return {
          title: "ì˜¤ëŠ˜ìš´ì„¸",
          toneLabel: "ì¼ì§„ ê¸°ë°˜",
          scoreText: "â€”",
          scoreLabel: "ì˜¤ëŠ˜ íë¦„",
          summary: summaryMain.textContent,
          todayLine: todayCoupleLine.textContent,
          topElem,
        };
      }

      async function shareCard() {
        if (!state.A) {
          alert("ì…ë ¥ í›„ ê³„ì‚°í•´ì¤˜.");
          return;
        }
        const snapshot = renderAll() || {
          totalScore: "â€”",
          coupleElements: state.A.elements,
        };
        const blob = await generateShareCard(getSharePayload(snapshot));

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `ìš´ì„¸ì¹´ë“œ_${new Date().toISOString().slice(0, 10)}.png`;
        a.click();

        try {
          await navigator.clipboard.write([
            new ClipboardItem({ "image/png": blob }),
          ]);
          shareStatus.textContent = "ì¹´ë“œë¥¼ ìƒì„±í•˜ê³  í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆì–´.";
        } catch {
          shareStatus.textContent = "ì¹´ë“œë¥¼ ìƒì„±í–ˆì–´. ë‹¤ìš´ë¡œë“œë¥¼ í™•ì¸í•´ì¤˜.";
        }
      }

      /* ======================================================
  11. PDF ì €ì¥ (html2canvas + jsPDF)
====================================================== */
      async function savePdfPretty() {
        if (!state.A) {
          alert("ì…ë ¥ í›„ ê³„ì‚°í•´ì¤˜.");
          return;
        }
        if (!window.html2canvas || !window.jspdf) {
          alert("PDF ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ì–´.");
          return;
        }
        const area = document.getElementById("pdfArea");
        const canvas = await html2canvas(area, {
          scale: 2,
          backgroundColor: null,
          useCORS: true,
          logging: false,
        });
        const imgData = canvas.toDataURL("image/png", 1.0);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;

        if (imgH <= pageH) {
          pdf.addImage(imgData, "PNG", 0, 0, imgW, imgH);
        } else {
          let y = 0;
          let remaining = imgH;
          while (remaining > 0) {
            pdf.addImage(imgData, "PNG", 0, -y, imgW, imgH);
            remaining -= pageH;
            y += pageH;
            if (remaining > 0) pdf.addPage();
          }
        }

        const fileName = `ìš´ì„¸ë¦¬í¬íŠ¸_${new Date()
          .toISOString()
          .slice(0, 10)}.pdf`;
        pdf.save(fileName);
      }

      /* ======================================================
  12. ì…ë ¥/ê³„ì‚° íŒŒì´í”„ë¼ì¸
====================================================== */
      function loadInputs() {
        try {
          return JSON.parse(localStorage.getItem(INPUT_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveInputs(data) {
        localStorage.setItem(INPUT_KEY, JSON.stringify(data));
      }

      function setInputs(data) {
        if (!data) return;
        aDate.value = data.aDate || "";
        aHourBranch.value = data.aHourBranch || "ì";
        aHiddenMode.value = data.aHiddenMode || "on";
        aTzOffset.value = data.aTzOffset ?? "9";
        aDstMode.value = data.aDstMode || "off";
        bDate.value = data.bDate || "";
        bHourBranch.value = data.bHourBranch || "ì";
        bHiddenMode.value = data.bHiddenMode || "on";
        bTzOffset.value = data.bTzOffset ?? "9";
        bDstMode.value = data.bDstMode || "off";
        toneSelect.value = data.tone || "couple";
      }

      function getInputData() {
        return {
          aDate: aDate.value,
          aHourBranch: aHourBranch.value,
          aHiddenMode: aHiddenMode.value,
          aTzOffset: aTzOffset.value,
          aDstMode: aDstMode.value,
          bDate: bDate.value,
          bHourBranch: bHourBranch.value,
          bHiddenMode: bHiddenMode.value,
          bTzOffset: bTzOffset.value,
          bDstMode: bDstMode.value,
          tone: toneSelect.value,
          mode: state.mode,
        };
      }

      function configureInputForMode(mode) {
        if (mode === "compat") {
          inputTitle.textContent = "ê¶í•© ì…ë ¥";
          inputDesc.textContent = "A/B ì¶œìƒ ì •ë³´ ì…ë ¥ â†’ ê¶í•© ê³„ì‚°";
          panelB.classList.remove("hidden");
          toneRow.classList.remove("hidden");
        } else if (mode === "newyear") {
          inputTitle.textContent = "ì‹ ë…„ìš´ì„¸ ì…ë ¥";
          inputDesc.textContent = "í•œ ì‚¬ëŒ ì¶œìƒ ì •ë³´ ì…ë ¥ â†’ 2026 íë¦„";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
        } else {
          inputTitle.textContent = "ì˜¤ëŠ˜ìš´ì„¸ ì…ë ¥";
          inputDesc.textContent = "í•œ ì‚¬ëŒ ì¶œìƒ ì •ë³´ ì…ë ¥ â†’ ì˜¤ëŠ˜ í•œ ì¤„";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
        }
      }

      function showStep(name) {
        stepMenu.classList.toggle("active", name === "menu");
        stepInput.classList.toggle("active", name === "input");
        stepResult.classList.toggle("active", name === "result");
      }

      async function computePair() {
        const data = getInputData();
        if (!data.aDate || !data.aHourBranch) {
          alert("A ë‚ ì§œì™€ 12ê°„ì§€ë¥¼ ì„ íƒí•´ì¤˜.");
          return;
        }
        if (state.mode === "compat" && (!data.bDate || !data.bHourBranch)) {
          alert("B ë‚ ì§œì™€ 12ê°„ì§€ë¥¼ ì„ íƒí•´ì¤˜.");
          return;
        }
        saveInputs(data);

        loadingOverlay.classList.add("active");
        loadingOverlay.setAttribute("aria-hidden", "false");
        await new Promise((r) => setTimeout(r, 700));

        const aTime = hourBranchToTime(data.aHourBranch);
        const aOffsetMin = parseTzOffsetMinutes(data.aTzOffset, 540);
        const aBirth = parseLocalDateTime(
          data.aDate,
          aTime,
          aOffsetMin,
          data.aDstMode
        );
        const aResult = computeSajuFiveElements(aBirth, {
          ziMode: "2300",
          hiddenMode: data.aHiddenMode,
          tzOffsetMinutes: aOffsetMin,
          dstMode: data.aDstMode,
        });
        state.aResult = aResult;
        state.A = {
          name: "A",
          elements: aResult.elements.raw,
          dayBranch: aResult.pillars.day.branch,
          monthBranch: aResult.pillars.month.branch,
          tzOffsetMinutes: aOffsetMin,
          dstMode: data.aDstMode,
        };

        if (state.mode === "compat") {
          const bTime = hourBranchToTime(data.bHourBranch);
          const bOffsetMin = parseTzOffsetMinutes(data.bTzOffset, 540);
          const bBirth = parseLocalDateTime(
            data.bDate,
            bTime,
            bOffsetMin,
            data.bDstMode
          );
          const bResult = computeSajuFiveElements(bBirth, {
            ziMode: "2300",
            hiddenMode: data.bHiddenMode,
            tzOffsetMinutes: bOffsetMin,
            dstMode: data.bDstMode,
          });
          state.bResult = bResult;
          state.B = {
            name: "B",
            elements: bResult.elements.raw,
            dayBranch: bResult.pillars.day.branch,
            monthBranch: bResult.pillars.month.branch,
            tzOffsetMinutes: bOffsetMin,
            dstMode: data.bDstMode,
          };
        } else {
          state.bResult = null;
          state.B = null;
        }

        showStep("result");
        renderAll();

        await new Promise((r) => setTimeout(r, 400));
        loadingOverlay.classList.remove("active");
        loadingOverlay.setAttribute("aria-hidden", "true");
      }

      /* ======================================================
  INIT
====================================================== */
      function init() {
        const cfg = loadTuneCfg();
        tuneStrength.value = String(cfg.strength ?? 1);
        tuneLabel.textContent = Number(tuneStrength.value).toFixed(1);
        updateTuneStatus();
        const saved = loadInputs();
        setInputs(saved);
        if (saved.mode) {
          state.mode = saved.mode;
          configureInputForMode(state.mode);
          showStep("input");
        }
      }

      document.querySelectorAll(".menu-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.mode = btn.dataset.mode;
          configureInputForMode(state.mode);
          showStep("input");
        });
      });

      backToMenu.addEventListener("click", () => showStep("menu"));
      clearSaved.addEventListener("click", () => {
        localStorage.removeItem(INPUT_KEY);
        aDate.value = "";
        aHourBranch.value = "ì";
        aHiddenMode.value = "on";
        aTzOffset.value = "9";
        aDstMode.value = "off";
        bDate.value = "";
        bHourBranch.value = "ì";
        bHiddenMode.value = "on";
        bTzOffset.value = "9";
        bDstMode.value = "off";
        toneSelect.value = "couple";
        alert("ì €ì¥ëœ ì…ë ¥ì„ ì´ˆê¸°í™”í–ˆì–´.");
      });
      backToInput.addEventListener("click", () => showStep("input"));
      restartFlow.addEventListener("click", () => showStep("menu"));

      document.addEventListener("click", (e) => {
        const btn = e.target.closest(".like-btn");
        if (!btn) return;
        const ruleId = btn.dataset.rule;
        feedback(ruleId);
        btn.textContent = "ê³µê°ë¨ âœ”";
        btn.disabled = true;
      });

      tuneStrength.addEventListener("input", () => {
        const v = Number(tuneStrength.value);
        tuneLabel.textContent = v.toFixed(1);
        saveTuneCfg({ strength: v });
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      tuneReset.addEventListener("click", () => {
        localStorage.removeItem(TUNE_KEY);
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      toneSelect.addEventListener("change", () => {
        saveInputs(getInputData());
        if (state.mode === "compat") renderAll();
      });

      todayLuckBtn.addEventListener("click", () => {
        if (state.mode === "compat" && state.A && state.B) {
          renderTodayCoupleBox(buildPerson(state.A), buildPerson(state.B));
        } else if (state.A) {
          todayCoupleLine.textContent = todayLuckLine(buildPerson(state.A));
          todayCoupleMeta.textContent = `ì˜¤ëŠ˜ ì˜¤í–‰: ${
            getTodayElementFlow().stemElem
          }/${getTodayElementFlow().branchElem}`;
        }
      });

      shareBtn.addEventListener("click", shareCard);
      pdfBtn.addEventListener("click", savePdfPretty);
      calcBtn.addEventListener("click", computePair);

      init();
    </script>
  </body>
</html>
