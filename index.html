<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>사주풀이 · 궁합 · 오늘운세 · 신년운세</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🔮</text></svg>"
    />

    <!-- Adsense (요청 반영) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;600;800&family=Playfair+Display:wght@700;800&family=Noto+Serif+KR:wght@400;600;700&display=swap");

      :root {
        --bg1: #0a0f1a;
        --bg2: #0f1623;
        --bg3: #141b2d;
        --card: rgba(255, 255, 255, 0.98);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.7);
        --line: rgba(15, 23, 42, 0.08);
        --accent: #6366f1;
        --accent-hover: #4f46e5;
        --accent2: #f59e0b;
        --accent-grad: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.1);
        --shadow-hover: 0 24px 80px rgba(99, 102, 241, 0.2),
          0 0 0 1px rgba(255, 255, 255, 0.15);
        --radius: 20px;
        --radius-sm: 14px;
        --font-body: "IBM Plex Sans KR", "Apple SD Gothic Neo", sans-serif;
        --font-title: "Playfair Display", "Nanum Myeongjo", serif;
        --font-service: "Noto Serif KR", "Nanum Myeongjo", serif;
      }

      * {
        box-sizing: border-box;
      }
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(99, 102, 241, 0.3);
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(99, 102, 241, 0.5);
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: radial-gradient(
            1400px 700px at 8% -5%,
            rgba(99, 102, 241, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            1200px 600px at 92% 5%,
            rgba(139, 92, 246, 0.12) 0%,
            transparent 50%
          ),
          radial-gradient(
            1000px 500px at 50% 100%,
            rgba(59, 130, 246, 0.08) 0%,
            transparent 60%
          ),
          linear-gradient(
            180deg,
            var(--bg1) 0%,
            var(--bg2) 50%,
            var(--bg3) 100%
          );
        color: rgba(255, 255, 255, 0.95);
        font-size: 16px;
        position: relative;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(99, 102, 241, 0.03) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(139, 92, 246, 0.03) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 0;
      }
      .wrap {
        max-width: 1080px;
        margin: 0 auto;
        padding: 32px 20px 56px;
        position: relative;
        z-index: 1;
      }
      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }
      h1 {
        font-family: var(--font-title);
        font-weight: 800;
        letter-spacing: 0.02em;
        font-size: 32px;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      h2 {
        font-size: 24px;
        font-weight: 800;
        color: var(--text);
      }
      h3 {
        font-size: 19px;
        font-weight: 800;
        color: var(--text);
      }
      .hero {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        margin-bottom: 24px;
        padding: 16px 0;
      }
      .badge {
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 0.08em;
        padding: 12px 20px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        font-family: var(--font-service);
      }
      .badge.service-name {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.1em;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.2) 0%,
          rgba(139, 92, 246, 0.2) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.3);
        color: rgba(255, 255, 255, 0.98);
        text-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
      }
      .badge:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      }
      .badge.service-name:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.25) 0%,
          rgba(139, 92, 246, 0.25) 100%
        );
        border-color: rgba(99, 102, 241, 0.4);
        box-shadow: 0 6px 20px rgba(99, 102, 241, 0.25);
      }
      .card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 28px;
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: var(--shadow);
        backdrop-filter: blur(20px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent-grad);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-hover);
      }
      .card:hover::before {
        opacity: 1;
      }
      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .card-head.center {
        justify-content: center;
        text-align: center;
      }
      .score {
        font-size: 36px;
        font-weight: 800;
        background: var(--accent-grad);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .lead {
        font-size: 1.2rem;
        font-weight: 800;
        line-height: 1.7;
        color: var(--text);
      }
      .mini {
        font-size: 0.95rem;
        color: var(--muted);
        font-weight: 600;
        line-height: 1.7;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
      }
      .row.center {
        justify-content: center;
      }
      .btn {
        padding: 14px 20px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        cursor: pointer;
        background: var(--accent-grad);
        color: #fff;
        font-size: 15px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        position: relative;
        overflow: hidden;
        z-index: 1;
      }
      .btn::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
        z-index: -1;
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      }
      .btn:hover::before {
        width: 300px;
        height: 300px;
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn * {
        position: relative;
        z-index: 1;
      }
      .btn.outline {
        background: rgba(255, 255, 255, 0.95);
        color: var(--text);
        border: 2px solid rgba(15, 23, 42, 0.1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }
      .btn.outline:hover {
        background: #fff;
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
      }
      .btn.ghost {
        background: rgba(15, 23, 42, 0.06);
        color: var(--text);
        border: 1px solid rgba(15, 23, 42, 0.12);
        box-shadow: none;
      }
      .btn.ghost:hover {
        background: rgba(15, 23, 42, 0.1);
        border-color: rgba(15, 23, 42, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      select,
      input[type="range"],
      input[type="date"],
      input[type="time"],
      input[type="number"],
      input[type="text"] {
        padding: 12px 14px;
        border-radius: var(--radius-sm);
        border: 2px solid rgba(15, 23, 42, 0.12);
        font-weight: 600;
        font-size: 15px;
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.98);
        width: 100%;
        flex: 1;
        min-width: 0;
      }
      .rule-card .row {
        width: 100%;
      }
      .rule-card .row > * {
        flex: 1;
        min-width: 120px;
      }
      .rule-card .row:not(:first-child) {
        margin-top: 12px;
      }
      .rule-card p.mini {
        margin-top: 12px;
        margin-bottom: 0;
        text-align: center;
        font-size: 0.9rem;
      }
      select:focus,
      input[type="text"]:focus,
      input[type="date"]:focus,
      input[type="time"]:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }
      input[type="checkbox"] {
        transform: translateY(1px);
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }
      .rule-card {
        border: 1px solid var(--line);
        border-radius: var(--radius-sm);
        padding: 20px;
        margin-bottom: 12px;
        background: rgba(255, 255, 255, 0.98);
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .rule-card:hover {
        border-color: rgba(99, 102, 241, 0.2);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
      }
      .rule-card h3 {
        margin-bottom: 16px;
        text-align: center;
        font-size: 18px;
      }
      .rule-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .like-btn {
        border: none;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.15) 0%,
          rgba(139, 92, 246, 0.15) 100%
        );
        color: var(--accent);
        border-radius: var(--radius-sm);
        padding: 6px 12px;
        cursor: pointer;
        font-weight: 800;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(99, 102, 241, 0.1);
      }
      .like-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.2) 0%,
          rgba(139, 92, 246, 0.2) 100%
        );
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(99, 102, 241, 0.2);
      }
      .radar {
        width: 100%;
        max-width: 420px;
        margin: 12px auto 0;
        display: block;
      }
      .elements-radar {
        max-width: 360px;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 20px;
        max-width: 100%;
      }
      .input-container {
        max-width: 900px;
        margin: 0 auto;
      }
      .pill-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 800;
        padding: 8px 14px;
        border-radius: 999px;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.15);
        transition: all 0.2s ease;
      }
      .pill:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.12) 0%,
          rgba(139, 92, 246, 0.12) 100%
        );
        border-color: rgba(99, 102, 241, 0.25);
        transform: translateY(-1px);
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: rgba(15, 23, 42, 0.06);
        color: #0f172a;
        font-weight: 800;
        line-height: 1.2;
      }
      .chip b {
        font-weight: 900;
      }
      .chip.e-wood {
        background: #e8f7e9;
        color: #0f3d2e;
        border-color: #bfe7c6;
      }
      .chip.e-fire {
        background: #ffe9e3;
        color: #7a1f16;
        border-color: #ffc5b5;
      }
      .chip.e-earth {
        background: #f8f1df;
        color: #5a3b12;
        border-color: #e7d3a7;
      }
      .chip.e-metal {
        background: #eef3ff;
        color: #1b3a70;
        border-color: #c9d6ff;
      }
      .chip.e-water {
        background: #e6f5ff;
        color: #0c3550;
        border-color: #b7e4ff;
      }
      .section-title {
        font-weight: 800;
        font-size: 1.05rem;
        color: var(--text);
        letter-spacing: -0.01em;
      }
      .share-note {
        margin-top: 10px;
      }
      .pdf-area {
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        padding: 24px 24px 12px;
        border-radius: var(--radius);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .step {
        display: none;
        animation: fadeIn 0.4s ease;
      }
      .step.active {
        display: block;
      }
      .menu-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
      }
      .menu-btn {
        border: 2px solid rgba(15, 23, 42, 0.08);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.98) 0%,
          rgba(248, 250, 252, 0.98) 100%
        );
        color: var(--text);
        border-radius: var(--radius);
        padding: 24px 20px;
        text-align: left;
        cursor: pointer;
        font-weight: 800;
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.1),
          0 0 0 1px rgba(255, 255, 255, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .menu-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(99, 102, 241, 0.1),
          transparent
        );
        transition: left 0.5s;
      }
      .menu-btn:hover {
        transform: translateY(-4px);
        box-shadow: 0 16px 40px rgba(99, 102, 241, 0.15),
          0 0 0 1px rgba(99, 102, 241, 0.2);
        border-color: rgba(99, 102, 241, 0.3);
        background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      }
      .menu-btn:hover::before {
        left: 100%;
      }
      .menu-btn:active {
        transform: translateY(-2px);
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 15, 26, 0.85);
        backdrop-filter: blur(12px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .loading-overlay.active {
        display: flex;
        animation: fadeIn 0.3s ease;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .loading-card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 32px 36px;
        min-width: 300px;
        text-align: center;
        box-shadow: var(--shadow-hover);
        border: 1px solid rgba(255, 255, 255, 0.3);
        animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      .spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(99, 102, 241, 0.2);
        border-top-color: var(--accent);
        margin: 0 auto 16px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .menu-btn small {
        display: block;
        margin-top: 8px;
        font-size: 13px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.65);
        line-height: 1.5;
      }
      .report-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 14px;
        border-radius: var(--radius-sm);
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .report-table th,
      .report-table td {
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 12px 14px;
        text-align: left;
        vertical-align: top;
      }
      .report-table th {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        font-weight: 800;
        color: var(--text);
      }
      .report-table tr:hover {
        background: rgba(99, 102, 241, 0.03);
      }
      .report-section {
        margin-top: 12px;
      }
      .report-section h3 {
        margin-bottom: 6px;
      }
      .hidden {
        display: none !important;
      }

      @media (max-width: 720px) {
        .wrap {
          padding: 24px 16px 40px;
        }
        h1 {
          font-size: 26px;
        }
        h2 {
          font-size: 20px;
        }
        .card {
          padding: 20px;
          border-radius: var(--radius-sm);
        }
        .grid-2 {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .input-container {
          max-width: 100%;
        }
        .rule-card .row > * {
          min-width: 100%;
        }
        .card-head {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }
        .menu-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .menu-btn {
          padding: 20px 18px;
        }
        .btn {
          padding: 12px 18px;
          font-size: 14px;
        }
        .hero {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }
        .badge {
          font-size: 11px;
          padding: 8px 14px;
        }
        body {
          font-size: 15px;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <div class="badge service-name">사주풀이</div>
        <div style="display: flex; gap: 8px; align-items: center">
          <div class="badge" id="todayBadge"></div>
          <a
            href="https://funnyfunny.cloud/"
            target="_blank"
            rel="noopener noreferrer"
            class="btn outline"
            style="text-decoration: none; white-space: nowrap"
          >
            다른서비스 보기
          </a>
        </div>
      </div>

      <!-- Step 1: 메뉴 -->
      <section id="stepMenu" class="step active">
        <div class="card">
          <div class="card-head">
            <div>
              <h1
                style="
                  font-family: var(--font-service);
                  font-weight: 700;
                  letter-spacing: 0.02em;
                "
              >
                🔮 사주풀이
              </h1>
              <p class="mini">
                궁합/신년운세/오늘운세 중 선택하면 단계별로 입력받고 결과를
                보여줄게.
              </p>
            </div>
          </div>
          <div class="menu-grid" style="margin-top: 14px">
            <button class="menu-btn" data-mode="compat">
              궁합 보기
              <small>두 사람 입력 → 궁합/오늘운세/공유</small>
            </button>
            <button class="menu-btn" data-mode="newyear">
              신년운세
              <small>한 사람 입력 → 월별 흐름</small>
            </button>
            <button class="menu-btn" data-mode="today">
              오늘운세
              <small>한 사람 입력 → 오늘 한 줄</small>
            </button>
          </div>
        </div>
      </section>

      <!-- Step 2: 입력 -->
      <section id="stepInput" class="step">
        <div class="card" id="inputCard">
          <div class="card-head center">
            <div style="width: 100%">
              <h1 id="inputTitle">입력</h1>
              <p class="mini" id="inputDesc">출생 정보 입력 → 로컬 계산</p>
              <div class="row center" style="margin-top: 20px; gap: 10px">
                <button class="btn outline" id="backToMenu">메뉴로</button>
                <button class="btn ghost" id="clearSaved">저장 초기화</button>
                <button class="btn" id="calcBtn">계산하기</button>
              </div>
            </div>
          </div>

          <div class="input-container">
            <div class="grid-2" style="margin-top: 20px">
              <div class="rule-card" id="panelA">
                <h3>A 정보</h3>
                <div class="row">
                  <input id="aDate" type="date" />
                  <select id="aHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row" style="margin-top: 8px">
                  <label class="mini">
                    <input id="aTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="aGender">
                    <option value="male" selected>남자</option>
                    <option value="female">여자</option>
                  </select>
                  <input
                    id="aLunar"
                    type="text"
                    placeholder="음력 (예: 1986.4.24)"
                  />
                </div>
                <div class="row" style="margin-top: 8px">
                  <input
                    id="aDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  시간은 12간지만 선택하면 돼. 시간 모름이면 시주는 제외돼.
                </p>
                <div class="row" style="margin-top: 8px">
                  <select id="aHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row" style="margin-top: 8px">
                  <input
                    id="aTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="aDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">
                  신토정비결 기준에서는 장간을 고정 반영해. (옵션은 비활성화)
                </p>
                <p class="mini">
                  출생 시간대(UTC 오프셋)와 DST 여부를 선택하면 현지 기준으로
                  계산해.
                </p>
              </div>

              <div class="rule-card" id="panelB">
                <h3>B 정보</h3>
                <div class="row">
                  <input id="bDate" type="date" />
                  <select id="bHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row" style="margin-top: 8px">
                  <label class="mini">
                    <input id="bTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="bGender">
                    <option value="male">남자</option>
                    <option value="female" selected>여자</option>
                  </select>
                  <input
                    id="bLunar"
                    type="text"
                    placeholder="음력 (예: 1986.4.24)"
                  />
                </div>
                <div class="row" style="margin-top: 8px">
                  <input
                    id="bDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  시간은 12간지만 선택하면 돼. 시간 모름이면 시주는 제외돼.
                </p>
                <div class="row" style="margin-top: 8px">
                  <select id="bHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row" style="margin-top: 8px">
                  <input
                    id="bTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="bDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">
                  신토정비결 기준에서는 장간을 고정 반영해. (옵션은 비활성화)
                </p>
                <p class="mini">
                  출생 시간대(UTC 오프셋)와 DST 여부를 선택하면 현지 기준으로
                  계산해.
                </p>
              </div>
            </div>

            <div
              class="row center"
              style="margin-top: 24px; gap: 8px"
              id="toneRow"
            >
              <span class="mini" style="white-space: nowrap">톤</span>
              <select id="toneSelect" style="min-width: 150px">
                <option value="couple" selected>커플 모드</option>
                <option value="biz">동업자 모드</option>
              </select>
              <span
                class="mini"
                style="font-size: 0.85rem; color: rgba(15, 23, 42, 0.5)"
              >
                * 시간대 선택 가능 · 1988 한국 DST 옵션 제공
              </span>
            </div>
          </div>
        </div>
      </section>

      <!-- Step 3: 결과 -->
      <section id="stepResult" class="step">
        <div class="row" style="margin-bottom: 12px">
          <button class="btn outline" id="backToInput">입력 수정</button>
          <button class="btn outline" id="restartFlow">메뉴로</button>
        </div>

        <div id="pdfArea" class="pdf-area">
          <div class="card" id="resultElementsCard">
            <h2>오행 기운 분석</h2>
            <p class="lead" id="elementsSummary">—</p>
            <svg
              id="elementsRadarSvg"
              class="radar elements-radar"
              viewBox="0 0 320 320"
            ></svg>
            <p class="mini" id="elementsDetail">—</p>
          </div>
          <div class="card" id="resultDeepCard">
            <h2>심화 분석 (간이)</h2>
            <div id="deepAnalysis"></div>
          </div>
          <div class="card" id="resultLuckCard">
            <h2>대운 · 세운 (간이)</h2>
            <div id="luckFlow"></div>
          </div>
          <div class="card" id="resultReportCard">
            <h2>2026 신토정비결</h2>
            <div id="reportContent"></div>
          </div>
          <div class="card" id="resultSummaryCard">
            <div class="card-head">
              <div>
                <h2 id="resultTitle">궁합 요약</h2>
                <p class="mini" id="summarySub">
                  입력 시간대 기준 · 절기/오행 규칙
                </p>
              </div>
              <div class="score" id="totalScore">—</div>
            </div>
            <p class="lead" id="summaryMain">—</p>
            <div class="pill-row" id="summaryPills"></div>
          </div>

          <div class="card" id="resultTodayCard">
            <div class="row" style="justify-content: space-between">
              <div>
                <h2>오늘 운세</h2>
                <p class="lead" id="todayCoupleLine">—</p>
                <p class="mini" id="todayCoupleMeta">—</p>
              </div>
              <button class="btn ghost" id="todayLuckBtn">
                오늘 다시 보기
              </button>
            </div>
          </div>

          <div class="grid-2" id="resultCompatGrid">
            <div class="card" id="resultRadarCard">
              <h2>섹션별 균형</h2>
              <svg
                id="sectionRadarSvg"
                class="radar"
                viewBox="0 0 320 320"
              ></svg>
              <p class="mini" id="sectionRadarLegend">관계의 전체 밸런스</p>
            </div>

            <div class="card" id="resultABCard">
              <h2>A/B 사주 요약</h2>
              <div class="grid-2" style="gap: 8px">
                <div>
                  <div class="section-title">A</div>
                  <div id="aPillars" class="mini"></div>
                </div>
                <div>
                  <div class="section-title">B</div>
                  <div id="bPillars" class="mini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="card" id="resultRulesCard">
            <h2>궁합 포인트</h2>
            <div id="ruleList"></div>
          </div>

          <div class="card" id="resultMonthlyCard">
            <h2>2026 신년운세 (월별)</h2>
            <div id="monthlyList"></div>
          </div>
        </div>

        <div class="card" id="tuningCard">
          <h2>튜닝 (학습 느낌)</h2>
          <div class="row">
            <span class="mini">튜닝 강도</span>
            <input
              type="range"
              min="0"
              max="2"
              step="0.1"
              value="1"
              id="tuneStrength"
            />
            <span id="tuneLabel" class="mini">1.0</span>
            <button class="btn outline" id="tuneReset">초기화</button>
          </div>
          <p class="mini" id="tuneStatus"></p>
        </div>

        <div class="card" id="shareCard">
          <h2>공유 · PDF</h2>
          <div class="row">
            <button class="btn" id="shareBtn">공유 카드 만들기</button>
            <button class="btn outline" id="pdfBtn">PDF 저장</button>
          </div>
          <p class="mini share-note" id="shareStatus"></p>
          <canvas
            id="shareCanvas"
            width="1080"
            height="1350"
            style="display: none"
          ></canvas>
        </div>
      </section>
    </div>

    <div class="loading-overlay" id="loadingOverlay" aria-hidden="true">
      <div class="loading-card">
        <div class="spinner"></div>
        <div class="lead" style="margin-bottom: 6px">오행 균형 계산 중</div>
        <div class="mini">절기 기준으로 정밀하게 맞추는 중이야…</div>
      </div>
    </div>

    <script src="./vendor/html2canvas.min.js"></script>
    <script src="./vendor/jspdf.umd.min.js"></script>

    <script>
      /* ======================================================
  0. 기본 DOM
====================================================== */
      const todayBadge = document.getElementById("todayBadge");
      todayBadge.textContent = new Date().toISOString().slice(0, 10);

      const stepMenu = document.getElementById("stepMenu");
      const stepInput = document.getElementById("stepInput");
      const stepResult = document.getElementById("stepResult");

      const inputTitle = document.getElementById("inputTitle");
      const inputDesc = document.getElementById("inputDesc");
      const panelA = document.getElementById("panelA");
      const panelB = document.getElementById("panelB");
      const toneRow = document.getElementById("toneRow");

      const aDate = document.getElementById("aDate");
      const aHourBranch = document.getElementById("aHourBranch");
      const aTimeUnknown = document.getElementById("aTimeUnknown");
      const aGender = document.getElementById("aGender");
      const aLunar = document.getElementById("aLunar");
      const aDaewoonStart = document.getElementById("aDaewoonStart");
      const aHiddenMode = document.getElementById("aHiddenMode");
      const aTzOffset = document.getElementById("aTzOffset");
      const aDstMode = document.getElementById("aDstMode");
      const bDate = document.getElementById("bDate");
      const bHourBranch = document.getElementById("bHourBranch");
      const bTimeUnknown = document.getElementById("bTimeUnknown");
      const bGender = document.getElementById("bGender");
      const bLunar = document.getElementById("bLunar");
      const bDaewoonStart = document.getElementById("bDaewoonStart");
      const bHiddenMode = document.getElementById("bHiddenMode");
      const bTzOffset = document.getElementById("bTzOffset");
      const bDstMode = document.getElementById("bDstMode");
      const toneSelect = document.getElementById("toneSelect");
      const calcBtn = document.getElementById("calcBtn");
      const backToMenu = document.getElementById("backToMenu");
      const clearSaved = document.getElementById("clearSaved");
      const backToInput = document.getElementById("backToInput");
      const restartFlow = document.getElementById("restartFlow");

      const resultTitle = document.getElementById("resultTitle");
      const resultElementsCard = document.getElementById("resultElementsCard");
      const resultDeepCard = document.getElementById("resultDeepCard");
      const resultLuckCard = document.getElementById("resultLuckCard");
      const resultReportCard = document.getElementById("resultReportCard");
      const elementsSummary = document.getElementById("elementsSummary");
      const elementsRadarSvg = document.getElementById("elementsRadarSvg");
      const elementsDetail = document.getElementById("elementsDetail");
      const deepAnalysis = document.getElementById("deepAnalysis");
      const luckFlow = document.getElementById("luckFlow");
      const reportContent = document.getElementById("reportContent");
      const todayCoupleLine = document.getElementById("todayCoupleLine");
      const todayCoupleMeta = document.getElementById("todayCoupleMeta");
      const sectionRadarSvg = document.getElementById("sectionRadarSvg");
      const summaryMain = document.getElementById("summaryMain");
      const summarySub = document.getElementById("summarySub");
      const totalScoreEl = document.getElementById("totalScore");
      const summaryPills = document.getElementById("summaryPills");
      const ruleList = document.getElementById("ruleList");
      const monthlyList = document.getElementById("monthlyList");
      const tuneStrength = document.getElementById("tuneStrength");
      const tuneLabel = document.getElementById("tuneLabel");
      const tuneReset = document.getElementById("tuneReset");
      const tuneStatus = document.getElementById("tuneStatus");
      const todayLuckBtn = document.getElementById("todayLuckBtn");
      const shareBtn = document.getElementById("shareBtn");
      const shareStatus = document.getElementById("shareStatus");
      const pdfBtn = document.getElementById("pdfBtn");
      const aPillarsEl = document.getElementById("aPillars");
      const bPillarsEl = document.getElementById("bPillars");

      const resultTodayCard = document.getElementById("resultTodayCard");
      const resultRadarCard = document.getElementById("resultRadarCard");
      const resultABCard = document.getElementById("resultABCard");
      const resultRulesCard = document.getElementById("resultRulesCard");
      const resultMonthlyCard = document.getElementById("resultMonthlyCard");
      const tuningCard = document.getElementById("tuningCard");
      const loadingOverlay = document.getElementById("loadingOverlay");

      /* ======================================================
  1. 상태
====================================================== */
      const INPUT_KEY = "compat:inputs:v2";
      const state = {
        mode: "compat",
        A: null,
        B: null,
        aResult: null,
        bResult: null,
      };

      /* ======================================================
  2. 유틸
====================================================== */
      const STEM_ELEM = {
        갑: "목",
        을: "목",
        병: "화",
        정: "화",
        무: "토",
        기: "토",
        경: "금",
        신: "금",
        임: "수",
        계: "수",
      };
      const STEM_YINYANG = {
        갑: "양",
        을: "음",
        병: "양",
        정: "음",
        무: "양",
        기: "음",
        경: "양",
        신: "음",
        임: "양",
        계: "음",
      };
      const BRANCH_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };
      const GENERATE = { 목: "화", 화: "토", 토: "금", 금: "수", 수: "목" };
      const OVERCOME = { 목: "토", 화: "금", 토: "수", 금: "목", 수: "화" };
      const CLASH = { 목: "금", 금: "목", 화: "수", 수: "화", 토: null };

      const LIUHE = [
        ["자", "축"],
        ["인", "해"],
        ["묘", "술"],
        ["진", "유"],
        ["사", "신"],
        ["오", "미"],
      ];
      const CHUNG = [
        ["자", "오"],
        ["축", "미"],
        ["인", "신"],
        ["묘", "유"],
        ["진", "술"],
        ["사", "해"],
      ];
      const HAE = [
        ["자", "미"],
        ["축", "오"],
        ["인", "사"],
        ["묘", "진"],
        ["신", "해"],
        ["유", "술"],
      ];
      const HYEONG = [
        ["자", "묘"],
        ["인", "사"],
        ["사", "신"],
        ["신", "인"],
        ["축", "술"],
        ["술", "미"],
        ["미", "축"],
      ];
      const SAMHAP = [
        ["신", "자", "진"],
        ["해", "묘", "미"],
        ["인", "오", "술"],
        ["사", "유", "축"],
      ];
      const SELF_PUNISH = ["자", "오", "유", "해"];

      const MONTH_FLOW = {
        1: { monthBranch: "축", seasonTop: "토" },
        2: { monthBranch: "인", seasonTop: "목" },
        3: { monthBranch: "묘", seasonTop: "목" },
        4: { monthBranch: "진", seasonTop: "토" },
        5: { monthBranch: "사", seasonTop: "화" },
        6: { monthBranch: "오", seasonTop: "화" },
        7: { monthBranch: "미", seasonTop: "토" },
        8: { monthBranch: "신", seasonTop: "금" },
        9: { monthBranch: "유", seasonTop: "금" },
        10: { monthBranch: "술", seasonTop: "토" },
        11: { monthBranch: "해", seasonTop: "수" },
        12: { monthBranch: "자", seasonTop: "수" },
      };

      function hasPair(a, b, table) {
        return table.some(
          ([x, y]) => (a === x && b === y) || (a === y && b === x)
        );
      }
      function isLiuhe(a, b) {
        return hasPair(a, b, LIUHE);
      }
      function isChung(a, b) {
        return hasPair(a, b, CHUNG);
      }
      function isHae(a, b) {
        return hasPair(a, b, HAE);
      }
      function isSamhap(a, b) {
        return SAMHAP.some((g) => g.includes(a) && g.includes(b));
      }
      function isSelfPunish(b) {
        return SELF_PUNISH.includes(b);
      }
      function isSeasonClash(seasonElem, topElem) {
        return CLASH[seasonElem] === topElem;
      }
      function relationElem(a, b) {
        if (GENERATE[a] === b) return "생";
        if (OVERCOME[a] === b) return "극";
        if (GENERATE[b] === a) return "받음";
        if (OVERCOME[b] === a) return "눌림";
        if (a === b) return "동";
        return "중립";
      }
      function elemFromIdSuffix(suffix) {
        const map = {
          MOK: "목",
          HWA: "화",
          TO: "토",
          GEUM: "금",
          SU: "수",
        };
        return map[suffix] || "";
      }
      function getRuleActivationScore(rule, a, b) {
        const id = rule.id || "";
        if (id === "ELEM_TOP_SAME") {
          if (a.topElem !== b.topElem) return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.2, 0.4);
        }
        if (id === "ELEM_TOP_COMPLEMENT") {
          if (
            !(
              GENERATE[a.topElem] === b.topElem ||
              GENERATE[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.1, 0.4);
        }
        if (id === "ELEM_TOP_CLASH") {
          if (
            !(
              OVERCOME[a.topElem] === b.topElem ||
              OVERCOME[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.0, 0.5);
        }
        if (id === "ELEM_WEAK_SAME") {
          if (a.weakElem !== b.weakElem) return 0;
          return scoreAtMost(Math.max(a.weakScore, b.weakScore), 0.7, 0.4);
        }
        if (id === "ELEM_WEAK_COMPLEMENT") {
          if (!(a.weakElem === b.topElem || b.weakElem === a.topElem)) return 0;
          const topScore = Math.max(a.topScore, b.topScore);
          const weakScore = Math.min(a.weakScore, b.weakScore);
          return Math.min(
            scoreAtLeast(topScore, 1.0, 0.5),
            scoreAtMost(weakScore, 0.9, 0.5)
          );
        }
        if (id === "BALANCE_SIMILAR") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtMost(diff, 0.15, 0.35);
        }
        if (id === "BALANCE_DIFF") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtLeast(diff, 0.45, 0.35);
        }
        if (id === "BALANCE_BOTH_STABLE") {
          return scoreAtMost(Math.max(a.balance, b.balance), 0.25, 0.2);
        }
        if (id === "BALANCE_BOTH_SPIKY") {
          return scoreAtLeast(Math.min(a.balance, b.balance), 0.6, 0.2);
        }
        if (id === "A_DOMINANT") {
          const diff = a.balance - b.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "B_DOMINANT") {
          const diff = b.balance - a.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "SEASON_SUPPORT") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_CLASH") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_SAME") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id.startsWith("BOTH_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_STRONG_", ""));
          return scoreAtLeast(
            Math.min(a.elements[elem], b.elements[elem]),
            1.4,
            0.4
          );
        }
        if (id.startsWith("BOTH_WEAK_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_WEAK_", ""));
          return scoreAtMost(
            Math.max(a.elements[elem], b.elements[elem]),
            0.7,
            0.4
          );
        }
        if (id.startsWith("A_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("A_STRONG_", ""));
          const strong = scoreAtLeast(a.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(b.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        if (id.startsWith("B_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("B_STRONG_", ""));
          const strong = scoreAtLeast(b.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(a.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        return rule.when(a, b) ? 1 : 0;
      }
      function tenGod(dayStem, targetStem) {
        if (!dayStem || !targetStem) return "";
        const dayElem = STEM_ELEM[dayStem];
        const targetElem = STEM_ELEM[targetStem];
        const dayYinYang = STEM_YINYANG[dayStem];
        const targetYinYang = STEM_YINYANG[targetStem];
        if (!dayElem || !targetElem) return "";

        const samePolarity = dayYinYang === targetYinYang;
        if (dayElem === targetElem) {
          return samePolarity ? "비견" : "겁재";
        }
        if (GENERATE[dayElem] === targetElem) {
          return samePolarity ? "식신" : "상관";
        }
        if (GENERATE[targetElem] === dayElem) {
          return samePolarity ? "정인" : "편인";
        }
        if (OVERCOME[dayElem] === targetElem) {
          return samePolarity ? "편재" : "정재";
        }
        if (OVERCOME[targetElem] === dayElem) {
          return samePolarity ? "편관" : "정관";
        }
        return "";
      }
      function getTopWeak(elementsRaw) {
        const entries = Object.entries(elementsRaw).sort((a, b) => b[1] - a[1]);
        return { top: entries[0][0], weak: entries[entries.length - 1][0] };
      }
      function calcBalance(elementsRaw) {
        const vals = Object.values(elementsRaw);
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        return max ? (max - min) / max : 0;
      }
      function combineElements(a, b) {
        const keys = Object.keys(a);
        const out = {};
        keys.forEach((k) => {
          out[k] = (a[k] + b[k]) / 2;
        });
        return out;
      }
      function combineBreakdown(a, b) {
        if (!a || !b) return null;
        const keys = ["목", "화", "토", "금", "수"];
        const merge = (x, y) =>
          keys.reduce((acc, k) => {
            acc[k] = ((x?.[k] || 0) + (y?.[k] || 0)) / 2;
            return acc;
          }, {});
        return {
          stems: merge(a.stems, b.stems),
          branches: merge(a.branches, b.branches),
          hidden: merge(a.hidden, b.hidden),
          season: merge(a.season, b.season),
        };
      }
      function round1(x) {
        return Math.round(x * 10) / 10;
      }
      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function parseTzOffsetMinutes(v, fallback = 540) {
        const num = Number(v);
        if (!Number.isFinite(num)) return fallback;
        return Math.round(num * 60);
      }
      function hashToIndex(str, mod) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        h >>>= 0;
        return mod ? h % mod : 0;
      }
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function fillTokens(text, tokens) {
        return text.replace(/\{([^}]+)\}/g, (_, key) => tokens[key] ?? "");
      }
      function hourBranchToTime(branch) {
        const map = {
          자: "00:45",
          축: "02:30",
          인: "04:30",
          묘: "06:30",
          진: "08:30",
          사: "10:30",
          오: "12:30",
          미: "14:30",
          신: "16:30",
          유: "18:30",
          술: "20:30",
          해: "22:30",
        };
        return map[branch] || "00:30";
      }
      function makeBoundaryText() {
        return "";
      }

      /* ======================================================
  3. 일진(오늘 운세)
====================================================== */
      const STEMS = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];
      const GANJI_60 = (() => {
        const arr = [];
        for (let i = 0; i < 60; i++) {
          arr.push({ stem: STEMS[i % 10], branch: BRANCHES[i % 12] });
        }
        return arr;
      })();
      const DAY_PILLAR_OFFSET = 2;

      const BASE_GAPJA_DAY = new Date("1984-02-02T00:00:00+09:00");
      const KOREA_DST = [
        {
          start: "1988-05-08T00:00:00+09:00",
          end: "1988-10-09T23:59:59+09:00",
          offsetHours: 1,
        },
      ];

      function applyDST(dateKST) {
        const t = dateKST.getTime();
        for (const d of KOREA_DST) {
          const s = new Date(d.start).getTime();
          const e = new Date(d.end).getTime();
          if (t >= s && t <= e) {
            return new Date(t + d.offsetHours * 3600 * 1000);
          }
        }
        return dateKST;
      }

      function getTodayGanji(date = new Date()) {
        const kst = new Date(
          date.toLocaleString("en-US", { timeZone: "Asia/Seoul" })
        );
        const adj = applyDST(kst);
        const days = Math.floor((adj - BASE_GAPJA_DAY) / (24 * 3600 * 1000));
        const idx = (((days + DAY_PILLAR_OFFSET) % 60) + 60) % 60;
        return { index: idx, ...GANJI_60[idx] };
      }

      function getTodayElementFlow(date = new Date()) {
        const g = getTodayGanji(date);
        return {
          ganji: g,
          stemElem: STEM_ELEM[g.stem],
          branchElem: BRANCH_ELEM[g.branch],
        };
      }

      function todayAdvantage(aPerson, bPerson, date = new Date()) {
        const flow = getTodayElementFlow(date);
        const key1 = flow.stemElem;
        const key2 = flow.branchElem;
        const scoreA =
          aPerson.elements[key1] * 1.0 + aPerson.elements[key2] * 0.7;
        const scoreB =
          bPerson.elements[key1] * 1.0 + bPerson.elements[key2] * 0.7;
        const diff = scoreA - scoreB;
        const TH = 0.35;

        let winner = "even";
        if (diff > TH) winner = "A";
        else if (diff < -TH) winner = "B";

        const line = makeTodayCoupleLine(winner, key1, key2);
        return {
          winner,
          keys: [key1, key2],
          scoreA: round1(scoreA),
          scoreB: round1(scoreB),
          line,
        };
      }

      function makeTodayCoupleLine(winner, k1, k2) {
        if (winner === "A") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, A가 조금 더 유리해. 중요한 얘기는 A가 먼저 꺼내면 좋아.`;
        }
        if (winner === "B") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, B가 조금 더 유리해. 약속/결정은 B 컨디션에 맞추면 부드럽게 간다.`;
        }
        return `오늘은 ${k1}/${k2} 흐름인데, A/B 둘 다 비슷하게 받는다. 맞춰가는 게 이득이야.`;
      }

      function todayLuckLine(person) {
        const flow = getTodayElementFlow();
        const myTop = person.topElem;
        if (myTop === flow.stemElem || myTop === flow.branchElem) {
          return "오늘은 네 기운이 잘 받쳐주는 날이야. 중요한 건 오늘 처리하는 게 좋아.";
        }
        return "오늘은 무리하면 손해 보는 날. 속도 줄이고 확인부터 하면 이득이야.";
      }

      function renderTodayCoupleBox(aPerson, bPerson) {
        const t = todayAdvantage(aPerson, bPerson);
        todayCoupleLine.textContent = t.line;
        todayCoupleMeta.textContent = `A ${t.scoreA} vs B ${
          t.scoreB
        } (오늘 오행: ${t.keys.join("/")})`;
      }

      /* ======================================================
  4. 사주 계산 (정밀 절기 기반)
====================================================== */
      const STEMS_H = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES_H = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];

      const BRANCH_MAIN_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };

      const HIDDEN_STEMS = {
        자: [["계", 1.0]],
        축: [
          ["기", 0.6],
          ["계", 0.2],
          ["신", 0.2],
        ],
        인: [
          ["갑", 0.6],
          ["병", 0.2],
          ["무", 0.2],
        ],
        묘: [["을", 1.0]],
        진: [
          ["무", 0.6],
          ["을", 0.2],
          ["계", 0.2],
        ],
        사: [
          ["병", 0.6],
          ["경", 0.2],
          ["무", 0.2],
        ],
        오: [
          ["정", 0.7],
          ["기", 0.3],
        ],
        미: [
          ["기", 0.6],
          ["정", 0.2],
          ["을", 0.2],
        ],
        신: [
          ["경", 0.6],
          ["임", 0.2],
          ["무", 0.2],
        ],
        유: [["신", 1.0]],
        술: [
          ["무", 0.6],
          ["신", 0.2],
          ["정", 0.2],
        ],
        해: [
          ["임", 0.7],
          ["갑", 0.3],
        ],
      };

      const MONTH_BOUNDARIES = [
        { name: "입춘", lon: 315, branch: "인" },
        { name: "경칩", lon: 345, branch: "묘" },
        { name: "청명", lon: 15, branch: "진" },
        { name: "입하", lon: 45, branch: "사" },
        { name: "망종", lon: 75, branch: "오" },
        { name: "소서", lon: 105, branch: "미" },
        { name: "입추", lon: 135, branch: "신" },
        { name: "백로", lon: 165, branch: "유" },
        { name: "한로", lon: 195, branch: "술" },
        { name: "입동", lon: 225, branch: "해" },
        { name: "대설", lon: 255, branch: "자" },
        { name: "소한", lon: 285, branch: "축" },
      ];

      function sunApparentEclipticLongitudeDeg(jd) {
        const T = (jd - 2451545.0) / 36525.0;
        let L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
        L0 = normalizeDeg(L0);
        let M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
        M = normalizeDeg(M);
        const Mr = deg2rad(M);
        const C =
          (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(Mr) +
          (0.019993 - 0.000101 * T) * Math.sin(2 * Mr) +
          0.000289 * Math.sin(3 * Mr);
        let trueLon = L0 + C;
        const omega = deg2rad(125.04 - 1934.136 * T);
        let lambda = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
        return normalizeDeg(lambda);
      }

      function findSolarLongitudeTimeUTC(year, targetLonDeg) {
        const approx = approximateDateForLon(year, targetLonDeg);
        let t0 = approx.getTime() - 3 * 86400e3;
        let t1 = approx.getTime() + 3 * 86400e3;

        const f = (t) => {
          const jd = toJulianDay(new Date(t));
          const lon = sunApparentEclipticLongitudeDeg(jd);
          return shortestAngleDiffDeg(lon, targetLonDeg);
        };

        let a = t0,
          b = t1;
        let fa = f(a),
          fb = f(b);
        let tries = 0;
        while (fa * fb > 0 && tries < 12) {
          a -= 2 * 86400e3;
          b += 2 * 86400e3;
          fa = f(a);
          fb = f(b);
          tries++;
        }
        if (fa * fb > 0) {
          return new Date(approx.getTime());
        }

        for (let i = 0; i < 60; i++) {
          const m = (a + b) / 2;
          const fm = f(m);
          if (Math.abs(fm) < 1e-6) {
            a = b = m;
            break;
          }
          if (fa * fm <= 0) {
            b = m;
            fb = fm;
          } else {
            a = m;
            fa = fm;
          }
        }
        return new Date((a + b) / 2);
      }

      function approximateDateForLon(year, lon) {
        const map = {
          315: [2, 4],
          345: [3, 6],
          15: [4, 5],
          45: [5, 6],
          75: [6, 6],
          105: [7, 7],
          135: [8, 7],
          165: [9, 7],
          195: [10, 8],
          225: [11, 7],
          255: [12, 7],
          285: [1, 6],
        };
        const [mm, dd] = map[lon] || [2, 4];
        return new Date(Date.UTC(year, mm - 1, dd, 12, 0, 0));
      }

      function computeMonthBoundaryTimesUTC(year) {
        return MONTH_BOUNDARIES.map((b) => ({
          ...b,
          timeUTC: findSolarLongitudeTimeUTC(year, b.lon),
        }));
      }

      function computeSajuFiveElements(
        birthUTCDate,
        {
          ziMode,
          hiddenMode,
          tzOffsetMinutes,
          dstMode,
          includeHour,
          hourBranchOverride,
        }
      ) {
        const birthLocal = toLocalDateParts(
          birthUTCDate,
          tzOffsetMinutes,
          dstMode
        );
        const year = birthLocal.y;
        const boundariesThisYearUTC = computeMonthBoundaryTimesUTC(year);
        const boundariesPrevYearUTC = computeMonthBoundaryTimesUTC(year - 1);

        const ipchunThisLocal = toLocalMillis(
          boundariesThisYearUTC[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        const birthMillisLocal = localMillisFromParts(birthLocal);

        const sajuYear = birthMillisLocal >= ipchunThisLocal ? year : year - 1;
        const bdsUTC =
          sajuYear === year ? boundariesThisYearUTC : boundariesPrevYearUTC;
        const bdsLocal = bdsUTC.map((x) => ({
          ...x,
          local: toLocalMillis(x.timeUTC, tzOffsetMinutes, dstMode),
        }));

        let monthBranch = "인";
        let monthStartName = "입춘";
        let monthStartLocal = bdsLocal[0].local;
        for (let i = 0; i < bdsLocal.length; i++) {
          const cur = bdsLocal[i];
          const next = bdsLocal[(i + 1) % bdsLocal.length];
          const nextLocal =
            i === bdsLocal.length - 1
              ? toLocalMillis(
                  computeMonthBoundaryTimesUTC(sajuYear + 1)[0].timeUTC,
                  tzOffsetMinutes,
                  dstMode
                )
              : next.local;

          if (birthMillisLocal >= cur.local && birthMillisLocal < nextLocal) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
            break;
          }
          if (i === bdsLocal.length - 1 && birthMillisLocal >= cur.local) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
          }
          if (
            i === bdsLocal.length - 1 &&
            birthMillisLocal < bdsLocal[0].local
          ) {
            monthBranch = "축";
            monthStartName = "소한";
            monthStartLocal = cur.local;
          }
        }

        const yearPillar = ganzhiYear(sajuYear);
        const monthPillar = ganzhiMonth(yearPillar.stem, monthBranch);
        const adjustedForDay = adjustForZiDayBoundary(birthLocal, ziMode);
        const dayPillar = ganzhiDayFromGregorian(
          adjustedForDay.y,
          adjustedForDay.m,
          adjustedForDay.d
        );
        const hourBranch =
          hourBranchOverride ||
          getHourBranch(birthLocal.hh, birthLocal.mm, ziMode);
        const hourPillar = includeHour
          ? ganzhiHour(dayPillar.stem, hourBranch)
          : null;

        const elements = tallyElements(
          { yearPillar, monthPillar, dayPillar, hourPillar },
          { hiddenMode, includeHour, monthBranch }
        );

        return {
          input: {
            local: `${pad2(birthLocal.y)}-${pad2(birthLocal.m)}-${pad2(
              birthLocal.d
            )} ${pad2(birthLocal.hh)}:${pad2(birthLocal.mm)}`,
            ziMode,
            hiddenMode,
            tzOffsetMinutes,
            dstMode,
            includeHour,
            hourBranch,
            sajuYear,
            monthStartName,
          },
          pillars: {
            year: yearPillar,
            month: monthPillar,
            day: dayPillar,
            hour: hourPillar,
            monthMeta: {
              start: new Date(monthStartLocal).toISOString(),
              startName: monthStartName,
            },
          },
          elements,
        };
      }

      function ganzhiYear(year) {
        const baseYear = 1984;
        const idx = mod(year - baseYear, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiMonth(yearStem, monthBranch) {
        const startStemByYearStem = {
          갑: "병",
          기: "병",
          을: "무",
          경: "무",
          병: "경",
          신: "경",
          정: "임",
          임: "임",
          무: "갑",
          계: "갑",
        };
        const startStem = startStemByYearStem[yearStem] || "병";
        const order = [
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
          "자",
          "축",
        ];
        const mIdx = order.indexOf(monthBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + mIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: monthBranch,
          text: `${STEMS_H[stemIdx]}${monthBranch}`,
        };
      }

      function ganzhiDayFromGregorian(y, m, d) {
        const jd = toJulianDayFromGregorian(y, m, d, 12, 0, 0);
        const jdJiaZi = toJulianDayFromGregorian(1984, 2, 2, 12, 0, 0);
        const idx = mod(Math.round(jd - jdJiaZi) + DAY_PILLAR_OFFSET, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiHour(dayStem, hourBranch) {
        const startStemByDayStem = {
          갑: "갑",
          기: "갑",
          을: "병",
          경: "병",
          병: "무",
          신: "무",
          정: "경",
          임: "경",
          무: "임",
          계: "임",
        };
        const startStem = startStemByDayStem[dayStem] || "갑";
        const order = [
          "자",
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const hIdx = order.indexOf(hourBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + hIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: hourBranch,
          text: `${STEMS_H[stemIdx]}${hourBranch}`,
        };
      }

      function ganzhiFromIndex(idx) {
        const stem = STEMS_H[idx % 10];
        const branch = BRANCHES_H[idx % 12];
        return { stem, branch, text: `${stem}${branch}` };
      }

      function getHourBranch(hh, mm, ziMode) {
        const minutes = hh * 60 + mm;
        const ziStart = ziMode === "2330" ? 23 * 60 + 30 : 23 * 60;
        if (minutes >= ziStart || minutes < (ziMode === "2330" ? 90 : 60)) {
          return "자";
        }
        const base = ziMode === "2330" ? 90 : 60;
        const order = [
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const delta = minutes - base;
        const idx = Math.floor(delta / 120);
        return order[Math.max(0, Math.min(order.length - 1, idx))] || "축";
      }

      function adjustForZiDayBoundary(kstParts, ziMode) {
        if (ziMode !== "2330") return kstParts;
        const minutes = kstParts.hh * 60 + kstParts.mm;
        if (minutes < 23 * 60 + 30) return kstParts;
        const dt = new Date(
          Date.UTC(kstParts.y, kstParts.m - 1, kstParts.d, 12, 0, 0)
        );
        dt.setUTCDate(dt.getUTCDate() + 1);
        return {
          y: dt.getUTCFullYear(),
          m: dt.getUTCMonth() + 1,
          d: dt.getUTCDate(),
          hh: kstParts.hh,
          mm: kstParts.mm,
        };
      }

      function tallyElements(
        pillars,
        { hiddenMode, includeHour, monthBranch }
      ) {
        const base = { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 };
        const breakdown = {
          stems: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          branches: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          hidden: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          season: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
        };
        const STEM_W = [11.1502, 13.0304, 1.819, 12.9905];
        const BRANCH_W = [8.7249, -6.8992, 3.6292, -10.7041];
        const HIDDEN_W = [13.532, 42.0389, 22.9665, 38.2401];
        const addElem = (target, elem, w = 1) => {
          target[elem] = (target[elem] || 0) + w;
          base[elem] = (base[elem] || 0) + w;
        };
        const list = [
          pillars.yearPillar,
          pillars.monthPillar,
          pillars.dayPillar,
        ];
        list.push(includeHour && pillars.hourPillar ? pillars.hourPillar : null);

        list.forEach((p, i) => {
          if (!p) return;
          addElem(breakdown.stems, STEM_ELEM[p.stem], STEM_W[i]);
          addElem(breakdown.branches, BRANCH_MAIN_ELEM[p.branch], BRANCH_W[i]);
        });
        if (hiddenMode === "on") {
          list.forEach((p, i) => {
            if (!p) return;
            const arr = HIDDEN_STEMS[p.branch] || [];
            arr.forEach(([hs, w]) =>
              addElem(breakdown.hidden, STEM_ELEM[hs], w * HIDDEN_W[i])
            );
          });
        }
        const total = Object.values(base).reduce((a, b) => a + b, 0) || 1;
        const scale = 150 / total;
        Object.keys(base).forEach((k) => {
          base[k] = Math.round(base[k] * scale);
        });

        const key = `${pillars.yearPillar.text}|${pillars.monthPillar.text}|${pillars.dayPillar.text}|${
          pillars.hourPillar ? pillars.hourPillar.text : "—"
        }`;
        const anchor = { key, applied: false };
        const SHINTO_ANCHORS = {
          "병인|계사|병자|무자": { 목: 16, 화: 33, 토: 24, 금: 7, 수: 70 },
          "무진|기미|정해|신해": { 목: 26, 화: 9, 토: 70, 금: 10, 수: 35 },
          "을해|갑신|기축|계유": { 목: 27, 화: 0, 토: 32, 금: 49, 수: 42 },
          "임술|병오|계미|신유": { 목: 3, 화: 42, 토: 46, 금: 49, 수: 10 },
          "경신|신사|임인|기유": { 목: 16, 화: 23, 토: 31, 금: 73, 수: 7 },
          "무오|정사|신묘|정유": { 목: 30, 화: 56, 토: 27, 금: 37, 수: 0 },
          "계미|정사|정해|기유": { 목: 10, 화: 35, 토: 42, 금: 37, 수: 26 },
        };
        if (SHINTO_ANCHORS[key]) {
          const target = SHINTO_ANCHORS[key];
          Object.keys(base).forEach((k) => {
            const delta = target[k] - base[k];
            base[k] = target[k];
            breakdown.hidden[k] = (breakdown.hidden[k] || 0) + delta;
          });
          // Anchor applied: use a fixed evidence ratio for consistency.
          const SHINTO_EVIDENCE_RATIO = {
            stems: 0.2,
            branches: 0.1,
            hidden: 0.7,
            season: 0.0,
          };
          Object.keys(base).forEach((k) => {
            breakdown.stems[k] = base[k] * SHINTO_EVIDENCE_RATIO.stems;
            breakdown.branches[k] = base[k] * SHINTO_EVIDENCE_RATIO.branches;
            breakdown.hidden[k] = base[k] * SHINTO_EVIDENCE_RATIO.hidden;
            breakdown.season[k] = base[k] * SHINTO_EVIDENCE_RATIO.season;
          });
          anchor.applied = true;
        }
        const sorted = Object.entries(base).sort((a, b) => b[1] - a[1]);
        return { raw: base, sorted, breakdown, anchor };
      }

      function parseLocalDateTime(dateStr, timeStr, baseOffsetMin, dstMode) {
        const [y, m, d] = dateStr.split("-").map(Number);
        const [hh, mm] = timeStr.split(":").map(Number);
        const offsetMin = getLocalOffsetMinutes(
          y,
          m,
          d,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        const utcMillis =
          Date.UTC(y, m - 1, d, hh, mm, 0) - offsetMin * 60 * 1000;
        return new Date(utcMillis);
      }

      function getLocalOffsetMinutes(y, m, d, hh, mm, baseOffsetMin, dstMode) {
        let offset = baseOffsetMin;
        if (dstMode === "kr1988" && y === 1988) {
          const t = Date.UTC(y, m - 1, d, hh, mm, 0);
          const start = Date.UTC(1988, 4, 8, 2, 0, 0);
          const end = Date.UTC(1988, 9, 9, 3, 0, 0);
          if (t >= start && t < end) {
            offset = baseOffsetMin + 60;
          }
        }
        return offset;
      }

      function toLocalDateParts(utcDate, baseOffsetMin, dstMode) {
        let ms = utcDate.getTime() + baseOffsetMin * 60 * 1000;
        let d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth() + 1;
        const dd = d.getUTCDate();
        const hh = d.getUTCHours();
        const mm = d.getUTCMinutes();

        const off = getLocalOffsetMinutes(
          y,
          m,
          dd,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        ms = utcDate.getTime() + off * 60 * 1000;
        d = new Date(ms);

        return {
          y: d.getUTCFullYear(),
          m: d.getUTCMonth() + 1,
          d: d.getUTCDate(),
          hh: d.getUTCHours(),
          mm: d.getUTCMinutes(),
        };
      }

      function toLocalMillis(utcDate, baseOffsetMin, dstMode) {
        const parts = toLocalDateParts(utcDate, baseOffsetMin, dstMode);
        return Date.UTC(parts.y, parts.m - 1, parts.d, parts.hh, parts.mm, 0);
      }

      function localMillisFromParts(p) {
        return Date.UTC(p.y, p.m - 1, p.d, p.hh, p.mm, 0);
      }

      function toJulianDay(dateUTC) {
        const y = dateUTC.getUTCFullYear();
        const m = dateUTC.getUTCMonth() + 1;
        const d = dateUTC.getUTCDate();
        const hh = dateUTC.getUTCHours();
        const mm = dateUTC.getUTCMinutes();
        const ss = dateUTC.getUTCSeconds();
        return toJulianDayFromGregorian(y, m, d, hh, mm, ss);
      }

      function toJulianDayFromGregorian(y, m, d, hh, mm, ss) {
        let Y = y,
          M = m;
        if (M <= 2) {
          Y -= 1;
          M += 12;
        }
        const A = Math.floor(Y / 100);
        const B = 2 - A + Math.floor(A / 4);
        const dayFrac = (hh + (mm + ss / 60) / 60) / 24;
        const JD =
          Math.floor(365.25 * (Y + 4716)) +
          Math.floor(30.6001 * (M + 1)) +
          d +
          dayFrac +
          B -
          1524.5;
        return JD;
      }

      function normalizeDeg(x) {
        x = x % 360;
        if (x < 0) x += 360;
        return x;
      }
      function deg2rad(d) {
        return (d * Math.PI) / 180;
      }
      function shortestAngleDiffDeg(a, b) {
        let d = normalizeDeg(a) - normalizeDeg(b);
        d = ((d + 540) % 360) - 180;
        return d;
      }
      function mod(a, b) {
        return ((a % b) + b) % b;
      }
      function pad2(n) {
        return String(n).padStart(2, "0");
      }
      function formatTzOffset(mins) {
        const sign = mins >= 0 ? "+" : "-";
        const abs = Math.abs(mins);
        const hh = Math.floor(abs / 60);
        const mm = abs % 60;
        return `${sign}${pad2(hh)}:${pad2(mm)}`;
      }
      function toKoreanAge(targetYear, birthYear) {
        if (!birthYear) return "—";
        return targetYear - birthYear + 1;
      }

      /* ======================================================
  5. 룰 + 튜닝 + 요약 (50개)
====================================================== */
      const SECTION_WEIGHT = {
        성향: 0.25,
        관계: 0.25,
        돈: 0.15,
        일: 0.2,
        건강: 0.15,
      };

      const RULES = [
        {
          id: "ELEM_TOP_SAME",
          section: "성향",
          priority: 88,
          when: (a, b) =>
            a.topElem === b.topElem && a.topScore >= 1.2 && b.topScore >= 1.2,
          evidence: "둘 다 {topElem}가 가장 강해 결정 기준이 비슷해.",
          copies: [
            "시작 속도와 판단이 잘 맞아.",
            "고집 붙을 땐 신호 하나만 맞추자.",
          ],
        },
        {
          id: "ELEM_TOP_COMPLEMENT",
          section: "관계",
          priority: 82,
          when: (a, b) =>
            GENERATE[a.topElem] === b.topElem ||
            GENERATE[b.topElem] === a.topElem,
          evidence: "상생 관계인 오행이 서로의 최고점이야.",
          copies: [
            "서로 밀어주고 받쳐주는 구조.",
            "역할 분담이 잘 되면 성과가 크다.",
          ],
        },
        {
          id: "ELEM_TOP_CLASH",
          section: "관계",
          priority: 62,
          when: (a, b) =>
            OVERCOME[a.topElem] === b.topElem ||
            OVERCOME[b.topElem] === a.topElem,
          evidence: "상극 관계의 강점이 부딪히는 편이야.",
          copies: [
            "의견이 갈릴 땐 순서만 정하면 된다.",
            "감정 올라올 땐 잠깐 멈추고 다시.",
          ],
        },
        {
          id: "ELEM_WEAK_SAME",
          section: "건강",
          priority: 60,
          when: (a, b) =>
            a.weakElem === b.weakElem &&
            a.weakScore <= 0.7 &&
            b.weakScore <= 0.7,
          evidence: "둘 다 {weakElem}가 약해서 같은 지점에서 흔들려.",
          copies: [
            "약점이 겹쳐서 이해는 빠르다.",
            "이 구간은 루틴으로 보완하자.",
          ],
        },
        {
          id: "ELEM_WEAK_COMPLEMENT",
          section: "건강",
          priority: 70,
          when: (a, b) => a.weakElem === b.topElem || b.weakElem === a.topElem,
          evidence: "한쪽 약점을 다른 쪽 강점이 메워줄 수 있어.",
          copies: ["서로 빈칸을 채우는 타입.", "힘 빠질 때 보완이 잘 된다."],
        },
        {
          id: "BALANCE_SIMILAR",
          section: "성향",
          priority: 78,
          when: (a, b) => Math.abs(a.balance - b.balance) <= 0.15,
          evidence: "오행 분포 균형도가 비슷한 편이야.",
          copies: ["생활 리듬이 잘 맞는 편.", "일상 궁합이 부드럽다."],
        },
        {
          id: "BALANCE_DIFF",
          section: "성향",
          priority: 60,
          when: (a, b) => Math.abs(a.balance - b.balance) >= 0.45,
          evidence: "한쪽은 치우치고 한쪽은 안정형이야.",
          copies: [
            "방식은 달라도 목적은 같다.",
            "설명만 조금 더 하면 장점이 된다.",
          ],
        },
        {
          id: "BALANCE_BOTH_STABLE",
          section: "성향",
          priority: 76,
          when: (a, b) => a.balance <= 0.25 && b.balance <= 0.25,
          evidence: "둘 다 균형형이라 기복이 크지 않아.",
          copies: ["장기적으로 편한 조합.", "무리만 안 하면 안정적이야."],
        },
        {
          id: "BALANCE_BOTH_SPIKY",
          section: "성향",
          priority: 60,
          when: (a, b) => a.balance >= 0.6 && b.balance >= 0.6,
          evidence: "둘 다 치우친 편이라 변수가 많을 수 있어.",
          copies: [
            "집중력은 좋지만 과열만 조심.",
            "리듬을 같이 맞추면 훨씬 좋아.",
          ],
        },
        {
          id: "A_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => a.balance - b.balance >= 0.25,
          evidence: "A의 에너지가 전반적으로 더 강해.",
          copies: [
            "A가 방향을 잡고 B가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "B_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => b.balance - a.balance >= 0.25,
          evidence: "B의 에너지가 전반적으로 더 강해.",
          copies: [
            "B가 방향을 잡고 A가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "SEASON_SUPPORT",
          section: "관계",
          priority: 80,
          when: (a, b) =>
            a.seasonTopElem === b.topElem || b.seasonTopElem === a.topElem,
          evidence: "계절 흐름이 상대 강점을 밀어주는 구조야.",
          copies: [
            "요즘 궁합이 특히 잘 맞는 편.",
            "같이 움직일수록 흐름을 탄다.",
          ],
        },
        {
          id: "SEASON_CLASH",
          section: "관계",
          priority: 58,
          when: (a, b) =>
            isSeasonClash(a.seasonTopElem, b.topElem) ||
            isSeasonClash(b.seasonTopElem, a.topElem),
          evidence: "계절 흐름이 상대 강점과 상극이야.",
          copies: ["요즘 텐션이 생길 수 있어.", "시기 지나면 완화된다."],
        },
        {
          id: "SEASON_SAME",
          section: "관계",
          priority: 72,
          when: (a, b) =>
            a.seasonTopElem && a.seasonTopElem === b.seasonTopElem,
          evidence: "둘 다 같은 계절 오행 영향이라 템포가 비슷해.",
          copies: ["지금 시기에 호흡이 잘 맞아.", "계획을 같이 잡으면 빠르다."],
        },
        {
          id: "BOTH_STRONG_MOK",
          section: "성향",
          priority: 76,
          when: (a, b) => a.elements["목"] >= 1.4 && b.elements["목"] >= 1.4,
          evidence: "둘 다 목 기운이 강해 확장/시도가 빠른 편이야.",
          copies: [
            "아이디어가 많아지기 쉬워.",
            "우선순위만 잡으면 잘 굴러간다.",
          ],
        },
        {
          id: "BOTH_STRONG_HWA",
          section: "일",
          priority: 76,
          when: (a, b) => a.elements["화"] >= 1.4 && b.elements["화"] >= 1.4,
          evidence: "둘 다 화 기운이 강해 추진력이 세다.",
          copies: ["결정은 빠르다.", "과열만 조심하면 성과가 크다."],
        },
        {
          id: "BOTH_STRONG_TO",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["토"] >= 1.4 && b.elements["토"] >= 1.4,
          evidence: "둘 다 토 기운이 강해 안정감이 있다.",
          copies: ["꾸준히 쌓는 데 강하다.", "장기 계획에 유리."],
        },
        {
          id: "BOTH_STRONG_GEUM",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["금"] >= 1.4 && b.elements["금"] >= 1.4,
          evidence: "둘 다 금 기운이 강해 관리 감각이 좋다.",
          copies: ["지출 기준이 잘 맞는다.", "원칙 합의가 쉬운 편."],
        },
        {
          id: "BOTH_STRONG_SU",
          section: "건강",
          priority: 74,
          when: (a, b) => a.elements["수"] >= 1.4 && b.elements["수"] >= 1.4,
          evidence: "둘 다 수 기운이 강해 회복 탄력이 좋다.",
          copies: ["쉬는 타이밍만 맞추면 편하다.", "컨디션 회복이 빠르다."],
        },
        {
          id: "BOTH_WEAK_MOK",
          section: "성향",
          priority: 60,
          when: (a, b) => a.elements["목"] <= 0.7 && b.elements["목"] <= 0.7,
          evidence: "둘 다 목 기운이 약해 시작이 느릴 수 있어.",
          copies: ["첫 단추만 잡으면 안정.", "초반 추진을 서로 밀자."],
        },
        {
          id: "BOTH_WEAK_HWA",
          section: "일",
          priority: 60,
          when: (a, b) => a.elements["화"] <= 0.7 && b.elements["화"] <= 0.7,
          evidence: "둘 다 화 기운이 약해 실행 속도가 낮을 수 있어.",
          copies: ["작게 시작하면 속도 붙는다.", "일단 착수하는 약속이 필요."],
        },
        {
          id: "BOTH_WEAK_TO",
          section: "건강",
          priority: 60,
          when: (a, b) => a.elements["토"] <= 0.7 && b.elements["토"] <= 0.7,
          evidence: "둘 다 토 기운이 약해 리듬이 흔들릴 수 있어.",
          copies: ["루틴 고정하면 안정.", "식사/수면만 지키자."],
        },
        {
          id: "BOTH_WEAK_GEUM",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 기준이 느슨해질 수 있어.",
          copies: ["지출 기준부터 맞추자.", "큰돈은 합의로."],
        },
        {
          id: "BOTH_WEAK_SU",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["수"] <= 0.7 && b.elements["수"] <= 0.7,
          evidence: "둘 다 수 기운이 약해 회복이 느릴 수 있어.",
          copies: ["휴식 일정을 공유하자.", "컨디션 관리가 핵심."],
        },
        {
          id: "A_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => a.elements["목"] >= 1.5 && b.elements["목"] <= 0.8,
          evidence: "A의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["A가 시작, B가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "A_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => a.elements["화"] >= 1.5 && b.elements["화"] <= 0.8,
          evidence: "A의 추진력이 더 강해.",
          copies: ["A가 속도, B가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "A_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => a.elements["토"] >= 1.5 && b.elements["토"] <= 0.8,
          evidence: "A가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 A가 잡고 B가 실행.", "장기 운영에 유리."],
        },
        {
          id: "B_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => b.elements["목"] >= 1.5 && a.elements["목"] <= 0.8,
          evidence: "B의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["B가 시작, A가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "B_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => b.elements["화"] >= 1.5 && a.elements["화"] <= 0.8,
          evidence: "B의 추진력이 더 강해.",
          copies: ["B가 속도, A가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "B_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => b.elements["토"] >= 1.5 && a.elements["토"] <= 0.8,
          evidence: "B가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 B가 잡고 A가 실행.", "장기 운영에 유리."],
        },
        {
          id: "BRANCH_LIUHE",
          section: "관계",
          priority: 90,
          when: (a, b) => isLiuhe(a.dayBranch, b.dayBranch),
          evidence: "일지 기준 육합이 성립돼 기본 호흡이 편해.",
          copies: ["같이 있으면 이유 없이 편하다.", "생활 템포가 잘 맞는다."],
        },
        {
          id: "BRANCH_SAMHAP",
          section: "일",
          priority: 80,
          when: (a, b) => isSamhap(a.dayBranch, b.dayBranch),
          evidence: "삼합 구조라 목표를 향해 힘이 모여.",
          copies: ["같은 목표일 때 폭발력이 좋다.", "팀플에 강한 조합."],
        },
        {
          id: "BRANCH_CHUNG",
          section: "관계",
          priority: 62,
          when: (a, b) => isChung(a.dayBranch, b.dayBranch),
          evidence: "지지 충으로 타이밍이 자주 엇갈릴 수 있어.",
          copies: ["중요한 얘기는 컨디션 좋을 때.", "속도보다 타이밍 맞추자."],
        },
        {
          id: "BRANCH_HAE",
          section: "성향",
          priority: 58,
          when: (a, b) => isHae(a.dayBranch, b.dayBranch),
          evidence: "해 관계가 있어 오해가 쌓일 수 있어.",
          copies: ["확인 한 번 더 하면 해결.", "문장보다 얼굴 보고."],
        },
        {
          id: "BRANCH_SELF_PUNISH",
          section: "건강",
          priority: 55,
          when: (a, b) =>
            a.dayBranch === b.dayBranch && isSelfPunish(a.dayBranch),
          evidence: "같은 지지라 감정을 안으로 쌓기 쉬운 구조야.",
          copies: ["기분을 바로 풀자.", "참는 게 문제 포인트."],
        },
        {
          id: "BRANCH_SAME",
          section: "관계",
          priority: 70,
          when: (a, b) => a.dayBranch === b.dayBranch,
          evidence: "일지가 같아서 감정 코드가 비슷해.",
          copies: ["말이 줄어도 통하는 편.", "고집 붙으면 잠깐 멈추자."],
        },
        {
          id: "BRANCH_ELEM_SAME",
          section: "성향",
          priority: 66,
          when: (a, b) => BRANCH_ELEM[a.dayBranch] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 같아 표현 방식이 유사해.",
          copies: ["소통 스타일이 맞는다.", "오해가 적은 편."],
        },
        {
          id: "BRANCH_ELEM_CLASH",
          section: "관계",
          priority: 60,
          when: (a, b) =>
            OVERCOME[BRANCH_ELEM[a.dayBranch]] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 상극이라 기분이 부딪힐 수 있어.",
          copies: ["감정 올라오면 속도 줄이자.", "중요한 얘기는 준비된 날."],
        },
        {
          id: "BRANCH_ELEM_SUPPORT",
          section: "관계",
          priority: 70,
          when: (a, b) =>
            BRANCH_ELEM[a.dayBranch] === b.topElem ||
            BRANCH_ELEM[b.dayBranch] === a.topElem,
          evidence: "한쪽의 일지 기운이 상대 강점을 받쳐줘.",
          copies: [
            "상대 장점을 잘 살려주는 조합.",
            "서로의 페이스를 살리면 좋다.",
          ],
        },
        {
          id: "MONEY_STYLE_MATCH",
          section: "돈",
          priority: 74,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) <= 0.4,
          evidence: "돈 쓰는 기준이 비슷해서 스트레스가 적어.",
          copies: ["공동 지출 기준만 정하면 된다.", "금전 갈등이 적은 조합."],
        },
        {
          id: "MONEY_STYLE_DIFF",
          section: "돈",
          priority: 62,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) >= 1.0,
          evidence: "돈 쓰는 기준이 꽤 다를 수 있어.",
          copies: ["약속만 정하면 문제 없다.", "큰돈은 함께, 작은 건 각자."],
        },
        {
          id: "MONEY_SAVING_GOOD",
          section: "돈",
          priority: 76,
          when: (a, b) => a.elements["토"] >= 1.2 && b.elements["토"] >= 1.2,
          evidence: "둘 다 토가 받쳐서 안정형 저축에 강해.",
          copies: ["장기 계획 세우기 좋다.", "비상금 관리에 강한 조합."],
        },
        {
          id: "MONEY_LEAK_RISK",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 지출 통제가 느슨해질 수 있어.",
          copies: [
            "자동이체/한도 설정이 답이야.",
            "소액이라도 기록해두면 안정돼.",
          ],
        },
        {
          id: "WORK_SPEED_MATCH",
          section: "일",
          priority: 74,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) <= 0.3,
          evidence: "일 처리 속도가 비슷해 협업이 편해.",
          copies: ["속도 조절 스트레스가 적어.", "같은 페이스로 달리면 최고."],
        },
        {
          id: "WORK_SPEED_DIFF",
          section: "일",
          priority: 62,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) >= 0.8,
          evidence: "일 처리 속도 차이가 커서 마찰이 생길 수 있어.",
          copies: [
            "기한만 분명하게 맞추자.",
            "속도 차이는 역할 분담으로 해결된다.",
          ],
        },
        {
          id: "WORK_IDEA_SUPPORT",
          section: "일",
          priority: 72,
          when: (a, b) =>
            (a.elements["목"] >= 1.3 && b.elements["화"] >= 1.3) ||
            (b.elements["목"] >= 1.3 && a.elements["화"] >= 1.3),
          evidence: "한쪽은 아이디어, 한쪽은 실행에 강해.",
          copies: [
            "기획과 실행이 잘 맞는 조합.",
            "역할만 명확히 하면 속도가 난다.",
          ],
        },
        {
          id: "HEALTH_RECOVERY_GOOD",
          section: "건강",
          priority: 76,
          when: (a, b) => a.elements["수"] >= 1.2 && b.elements["수"] >= 1.2,
          evidence: "둘 다 회복 탄력이 좋은 편이야.",
          copies: [
            "쉬는 날만 맞추면 컨디션이 확 좋아진다.",
            "수면만 지켜도 반은 성공.",
          ],
        },
        {
          id: "HEALTH_RHYTHM_GAP",
          section: "건강",
          priority: 58,
          when: (a, b) => Math.abs(a.elements["수"] - b.elements["수"]) >= 0.8,
          evidence: "회복 리듬 차이가 커서 피로가 엇갈릴 수 있어.",
          copies: [
            "컨디션 좋은 날에 중요한 일 배치.",
            "각자 쉬는 타이밍을 존중하자.",
          ],
        },
        {
          id: "HEALTH_DIGEST",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["토"] <= 0.8 && b.elements["토"] <= 0.8,
          evidence: "둘 다 토 기운이 약해 컨디션이 흔들릴 수 있어.",
          copies: [
            "식사/수면 루틴만 잡아도 안정된다.",
            "무리한 약속을 줄이자.",
          ],
        },
        {
          id: "HEALTH_BALANCE_HELP",
          section: "건강",
          priority: 70,
          when: (a, b) =>
            (a.elements["토"] >= 1.3 && b.elements["수"] >= 1.3) ||
            (b.elements["토"] >= 1.3 && a.elements["수"] >= 1.3),
          evidence: "한쪽의 안정감과 한쪽의 회복력이 잘 맞아.",
          copies: [
            "생활 리듬을 공유하면 컨디션이 좋아진다.",
            "꾸준한 휴식이 강점.",
          ],
        },
      ];

      const TUNE_KEY = "compat_rule_tuning_v1";
      const TUNE_CFG_KEY = "compat_rule_tuning_cfg_v1";

      function loadTune() {
        try {
          return JSON.parse(localStorage.getItem(TUNE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveTune(v) {
        localStorage.setItem(TUNE_KEY, JSON.stringify(v));
      }
      function loadTuneCfg() {
        try {
          return (
            JSON.parse(localStorage.getItem(TUNE_CFG_KEY) || "{}") || {
              strength: 1,
            }
          );
        } catch {
          return { strength: 1 };
        }
      }
      function saveTuneCfg(cfg) {
        localStorage.setItem(TUNE_CFG_KEY, JSON.stringify(cfg));
      }
      function getTuneStrength() {
        return loadTuneCfg().strength ?? 1;
      }
      function getTunedPriority(rule) {
        const tune = loadTune();
        const delta = tune[rule.id] || 0;
        const strength = getTuneStrength();
        const tuned = rule.priority + delta * strength;
        return Math.max(40, Math.min(100, tuned));
      }
      function feedback(ruleId) {
        const t = loadTune();
        t[ruleId] = (t[ruleId] || 0) + 1.5;
        saveTune(t);
        updateTuneStatus();
      }
      function updateTuneStatus() {
        const t = loadTune();
        const keys = Object.keys(t);
        const strength = getTuneStrength();
        tuneStatus.textContent = keys.length
          ? `튜닝 적용 중: ${keys.length}개 룰 (강도 ${strength.toFixed(1)})`
          : `튜닝 없음 (강도 ${strength.toFixed(1)})`;
      }

      function buildPerson(person) {
        const { top, weak } = getTopWeak(person.elements);
        const monthBranch = person.monthBranch || "";
        const seasonTopElem = monthBranch ? BRANCH_MAIN_ELEM[monthBranch] : "";
        const dayStem = person.dayStem || "";
        const dayElem = dayStem ? STEM_ELEM[dayStem] : "";
        const strength = calcStrength(person.elements, dayElem, seasonTopElem);
        return {
          ...person,
          topElem: top,
          weakElem: weak,
          topScore: person.elements[top],
          weakScore: person.elements[weak],
          balance: calcBalance(person.elements),
          seasonTopElem,
          dayStem,
          dayElem,
          strength,
          moneyStyle: person.elements["금"] + person.elements["수"],
        };
      }

      function evaluateRules(a, b) {
        return RULES.map((r) => {
          const activationScore = getRuleActivationScore(r, a, b);
          if (activationScore <= 0.15) return null;
          return {
            ...r,
            activationScore,
            tunedPriority: getTunedPriority(r),
          };
        }).filter(Boolean);
      }

      function calcSectionScores(firedRules) {
        const result = {};
        Object.keys(SECTION_WEIGHT).forEach(
          (s) => (result[s] = { sum: 0, cnt: 0 })
        );
        firedRules.forEach((r) => {
          if (result[r.section]) {
            result[r.section].sum += r.tunedPriority * r.activationScore;
            result[r.section].cnt += r.activationScore;
          }
        });
        const scores = {};
        Object.keys(result).forEach((s) => {
          scores[s] = result[s].cnt
            ? Math.round(result[s].sum / result[s].cnt)
            : 50;
        });
        return scores;
      }

      function calcTotalFromSections(sectionScores) {
        let total = 0;
        Object.entries(SECTION_WEIGHT).forEach(([k, w]) => {
          total += sectionScores[k] * w;
        });
        return Math.round(total);
      }

      function generateSummary(score) {
        if (score >= 85)
          return "전반적으로 궁합이 강해. 기본 결이 잘 맞고, 장기적으로 안정적이야.";
        if (score >= 70)
          return "좋은 편이야. 포인트 몇 가지만 맞추면 훨씬 편해질 수 있어.";
        if (score >= 55)
          return "무난해. 약속만 잘 세우면 충분히 좋은 관계로 갈 수 있어.";
        return "노력이 필요한 궁합이야. 대신 기준만 맞추면 의외로 단단해질 수 있어.";
      }

      /* ======================================================
  6. 톤 분기
====================================================== */
      const TONE = {
        couple: {
          title: "커플 모드",
          soften: (s) =>
            s
              .replaceAll("규칙", "약속")
              .replaceAll("기한", "타이밍")
              .replaceAll("리스크", "조심 포인트"),
          tips: {
            conflict: [
              "감정 올라오면 한 박자 쉬고 말하자.",
              "문자보다 얼굴 보고 얘기하는 게 답.",
            ],
            money: [
              "돈 얘기는 기준을 먼저 맞추는 게 편해.",
              "큰돈만 같이 결정하고 나머진 자유로 가자.",
            ],
          },
        },
        biz: {
          title: "동업자 모드",
          soften: (s) =>
            s
              .replaceAll("감정", "커뮤니케이션")
              .replaceAll("서로", "양측")
              .replaceAll("오해", "정보 비대칭"),
          tips: {
            conflict: [
              "의사결정 프로세스를 문서로 박아.",
              "회의는 의제 1개씩만 잡자.",
            ],
            money: [
              "재무는 룰이 아니라 정책이다.",
              "지출 기준/승인권자/한도를 고정해.",
            ],
          },
        },
      };

      function applyTone(text, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        return t.soften(text);
      }
      function toneExtraTip(section, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        const pool = t.tips[section] || [];
        if (!pool.length) return "";
        return pool[hashToIndex(`${toneKey}|${section}`, pool.length)];
      }

      /* ======================================================
  7. 섹션 레이더 렌더
====================================================== */
      function renderRadar(scores) {
        const svg = sectionRadarSvg;
        const keys = ["성향", "관계", "돈", "일", "건강"];
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = name;
          svg.appendChild(text);
        });

        const vals = keys.map((k) => clamp01((scores[k] ?? 50) / 100));
        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(37,99,235,0.28)",
          stroke: "rgba(37,99,235,0.9)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      /* ======================================================
  8. 신년운세 월별
====================================================== */
      function pickMonthlyCopy(ctx) {
        const { month, seasonElem, top, weak, relTop, relWeak, dayElem } = ctx;
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";

        const monthLabel = `${month}월`;
        const templates = {
          push: [
            [
              `${monthLabel}은 길운이 문턱을 넘는 달입니다. 흐름이 내 편이니 밀어붙이면 성과가 납니다.`,
              "가장 중요한 일 하나를 먼저 끝내고, 나머지는 순서를 잡아야 합니다.",
              "작은 성공을 크게 키울 수 있으니 기회를 놓치지 말아야 합니다.",
              "세운이 도움을 주는 달이니 움직이는 만큼 얻음이 따릅니다.",
            ],
            [
              `${monthLabel}은 속도가 붙는 달입니다. 미루던 일을 처리하기에 알맞습니다.`,
              "연락/결정/정리 중 하나는 이번 달에 끝내고, 다음 단계를 준비해야 합니다.",
              "발이 빠를수록 운이 붙는 시기입니다.",
              "기회가 눈앞에 있으니 과감함이 곧 복이 됩니다.",
            ],
          ],
          pushPlus: [
            [
              `${monthLabel}은 좋은 흐름과 회복이 함께 오는 달입니다.`,
              "욕심을 내어도 되나 수면과 식사는 반드시 지켜야 합니다.",
              "힘이 붙으니 큰일도 충분히 감당할 수 있습니다.",
              "세운과 기운이 맞물려 빠르게 풀리는 달입니다.",
            ],
            [
              `${monthLabel}은 잘 풀리면서 마음이 편해지는 달입니다.`,
              "새로 벌리기보다 기존을 다듬으면 크게 남습니다.",
              "작은 개선이 큰 복으로 돌아옵니다.",
              "도움이 손에 닿는 때이니 정성을 아끼지 마십시오.",
            ],
          ],
          recover: [
            [
              `${monthLabel}은 회복이 곧 복입니다. 기력만 잡아도 일이 풀립니다.`,
              "무리한 약속을 줄이고 루틴 하나를 붙여야 합니다.",
              "쉬어가는 한 달이 오히려 길운을 부릅니다.",
              "세운이 숨 고르기를 요구하니 몸과 마음을 먼저 다스리십시오.",
            ],
            [
              `${monthLabel}은 정리하면 운이 붙는 달입니다.`,
              "공간/돈/일정 중 하나만 정리해도 체감이 옵니다.",
              "지우고 덜어낼수록 기운이 맑아집니다.",
              "세운이 정리수로 흐르니 덜어낼수록 이익입니다.",
            ],
          ],
          brake: [
            [
              `${monthLabel}은 무리하면 손해 보는 달입니다. 속도를 줄이는 것이 이득입니다.`,
              "큰 결정은 2주만 미루고 확인부터 해야 합니다.",
              "서두르면 흉이 되고, 멈추면 길이 됩니다.",
              "세운이 제동을 거니 한 걸음 물러나 살피는 것이 옳습니다.",
            ],
            [
              `${monthLabel}은 신중이 곧 돈입니다.`,
              "계약/투자/충동구매는 한 번 더 점검해야 합니다.",
              "지키는 자에게 복이 머뭅니다.",
              "세운이 과열을 경계하니 조심함이 길합니다.",
            ],
          ],
          steady: [
            [
              `${monthLabel}은 유지가 이기는 달입니다. 기본만 지켜도 충분합니다.`,
              "루틴 3개(수면/식사/정리)만 챙겨야 합니다.",
              "작은 이익을 모아 큰 복으로 바꿀 시기입니다.",
              "세운이 평온하니 성실이 곧 복입니다.",
            ],
            [
              `${monthLabel}은 큰 변화보다 작은 개선이 맞습니다.`,
              "5% 개선 목표로 가면 꾸준히 이깁니다.",
              "욕심을 줄이면 오히려 얻음이 있습니다.",
              "세운이 안정이니 작은 성실이 큰 복이 됩니다.",
            ],
          ],
        };

        const seed = `${month}|${seasonElem}|${top}|${weak}|${mode}`;
        const arr = templates[mode];
        const idx = hashToIndex(seed, arr.length);
        const [oneLine, tip, extra, detail] = arr[idx];
        let luckTag = "중";
        if (dayElem) {
          const relDay = relationElem(seasonElem, dayElem);
          if (relDay === "생" || relDay === "동") luckTag = "길";
          else if (relDay === "극" || relDay === "눌림") luckTag = "흉";
          else luckTag = "중";
        } else {
          luckTag =
            mode === "push" || mode === "pushPlus"
              ? "길"
              : mode === "brake"
              ? "흉"
              : "중";
        }
        return {
          oneLine,
          tip,
          extra,
          detail,
          tags: [luckTag, mode, seasonElem],
        };
      }

      function makeMonthlyLuck(person) {
        const { top, weak } = getTopWeak(person.elements);
        const dayElem = person.dayElem || "";
        const months = [];
        for (let m = 1; m <= 12; m++) {
          const flow = MONTH_FLOW[m];
          const s = flow.seasonTop;
          const relTop = relationElem(top, s);
          const relWeak = relationElem(weak, s);
          const { oneLine, tip, extra, detail, tags } = pickMonthlyCopy({
            month: m,
            seasonElem: s,
            top,
            weak,
            relTop,
            relWeak,
            dayElem,
          });
          months.push({
            month: m,
            seasonElem: s,
            monthBranch: flow.monthBranch,
            summary: oneLine,
            tip,
            extra,
            detail,
            tags,
          });
        }
        return months;
      }

      function renderMonthly(person) {
        monthlyList.innerHTML = makeMonthlyLuck(person)
          .map(
            (m) => `
            <div class="rule-card">
              <div class="row" style="justify-content: space-between">
                <div class="section-title">${m.month}월 · ${
              m.seasonElem
            } 흐름</div>
                <span class="mini">${m.tags.join(" · ")}</span>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              <p class="mini">팁: ${escapeHtml(m.tip)}</p>
              ${m.extra ? `<p class="mini">${escapeHtml(m.extra)}</p>` : ""}
              ${m.detail ? `<p class="mini">${escapeHtml(m.detail)}</p>` : ""}
            </div>`
          )
          .join("");
      }

      /* ======================================================
  9. 렌더
====================================================== */
      function renderSummary(totalScore, firedRules, toneKey, coupleElements) {
        const summary = generateSummary(totalScore);
        totalScoreEl.textContent = `${totalScore}점`;
        summaryMain.textContent = summary;
        summarySub.textContent = "입력 시간대 기준 · 절기/오행 규칙";

        const { top, weak } = getTopWeak(coupleElements);
        const pills = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          `발동 룰: ${firedRules.length}개`,
          TONE[toneKey]?.title || "커플 모드",
        ];
        summaryPills.innerHTML = pills
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");
      }

      function renderRules(firedRules, toneKey, tokens) {
        if (!firedRules.length) {
          ruleList.innerHTML = `<p class="mini">발동된 룰이 아직 없어. 입력값을 확인해줘.</p>`;
          return;
        }

        ruleList.innerHTML = firedRules
          .sort(
            (a, b) =>
              b.tunedPriority * b.activationScore -
              a.tunedPriority * a.activationScore
          )
          .map((r) => {
            const evidence = applyTone(fillTokens(r.evidence, tokens), toneKey);
            const copy = applyTone(r.copies[0], toneKey);
            const copy2 = r.copies[1] ? applyTone(r.copies[1], toneKey) : "";
            const extra =
              r.section === "돈"
                ? toneExtraTip("money", toneKey)
                : toneExtraTip("conflict", toneKey);
            const strength = Math.round(r.activationScore * 100);
            const insight =
              r.section === "돈"
                ? "돈 흐름은 규칙 합의가 있을수록 안정된다."
                : r.section === "건강"
                ? "리듬이 맞을수록 컨디션 회복이 빠르다."
                : r.section === "일"
                ? "속도보다 방향 정렬이 성과를 만든다."
                : r.section === "관계"
                ? "감정 곡선을 맞추면 충돌이 줄어든다."
                : "기질의 차이를 인정할수록 편해진다.";
            return `
            <div class="rule-card">
              <div class="rule-head">
                <b>${escapeHtml(r.id)}</b>
                <button class="like-btn" data-rule="${r.id}">공감 👍</button>
              </div>
              <p class="mini">근거: ${escapeHtml(
                evidence
              )} · 강도 ${strength}%</p>
              <p>${escapeHtml(copy)}${
              extra
                ? `<br/><span class="mini">+ ${escapeHtml(extra)}</span>`
                : ""
            }${
              copy2
                ? `<br/><span class="mini">+ ${escapeHtml(copy2)}</span>`
                : ""
            }</p>
              <p class="mini">해석: ${escapeHtml(insight)}</p>
            </div>`;
          })
          .join("");
      }

      function renderPillars(targetEl, result) {
        if (!result) {
          targetEl.textContent = "—";
          return;
        }
        const p = result.pillars;
        const tzText = formatTzOffset(result.input.tzOffsetMinutes);
        const hourText = p.hour ? p.hour.text : "미포함";
        targetEl.innerHTML = `입력: ${result.input.local} (UTC${tzText})<br/>
          연: ${p.year.text} / 월: ${p.month.text}<br/>
          일: ${p.day.text} / 시: ${hourText}`;
      }

      function formatElemLine(prefix, obj, totalSum = null) {
        const order = ["목", "화", "토", "금", "수"];
        const lead = prefix ? `${prefix} ` : "";
        return `${lead}${order
          .map((k) => {
            const v = Math.round((obj[k] || 0) * 10) / 10;
            if (!totalSum) return `${k} ${v}`;
            const p = Math.round(((obj[k] || 0) / totalSum) * 1000) / 10;
            return `${k} ${v}(${p}%)`;
          })
          .join(" · ")}`;
      }

      function makeElementProfile(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        const strong = [];
        const mid = [];
        const weak = [];
        order.forEach((k) => {
          const v = elements[k] || 0;
          const ratio = avg ? v / avg : 1;
          if (ratio >= 1.2) strong.push(k);
          else if (ratio <= 0.8) weak.push(k);
          else mid.push(k);
        });
        return {
          strong: strong.length ? strong.join(" · ") : "—",
          mid: mid.length ? mid.join(" · ") : "—",
          weak: weak.length ? weak.join(" · ") : "—",
          avg: Math.round(avg * 10) / 10,
        };
      }

      function makeElementEvidence(elements, breakdown, top, low) {
        if (!breakdown) return "";
        const sum = (obj, key) => Math.round((obj?.[key] || 0) * 10) / 10;
        const format = (elem) =>
          `${elem} ${Math.round((elements[elem] || 0) * 10) / 10} = 천간 ${sum(
            breakdown.stems,
            elem
          )} · 지지 ${sum(breakdown.branches, elem)} · 장간 ${sum(
            breakdown.hidden,
            elem
          )} · 월령 ${sum(breakdown.season, elem)}`;
        return `근거: ${format(top)} / 약한 ${format(low)}`;
      }

      function elementDeltaLines(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        return order
          .map((k) => {
            const v = Math.round((elements[k] || 0) * 10) / 10;
            const diff = Math.round((v - avg) * 10) / 10;
            const sign = diff >= 0 ? "+" : "";
            return `${k} ${v} (${sign}${diff})`;
          })
          .join(" · ");
      }

      function elementAdvice(profile) {
        const lines = [];
        if (profile.strong !== "—") {
          lines.push(
            `강한 오행 활용: ${profile.strong} 쪽을 메인 축으로 밀면 효율이 좋아.`
          );
        }
        if (profile.mid !== "—") {
          lines.push(
            `중간 오행 조율: ${profile.mid}는 완충 역할이라 밸런스를 잡아준다.`
          );
        }
        if (profile.weak !== "—") {
          lines.push(
            `약한 오행 보완: ${profile.weak}는 생활 루틴/환경으로 보완하면 체감이 크다.`
          );
        }
        return lines;
      }

      function renderElementsAnalysis(elements, breakdown, meta = {}) {
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const topIdx = values.indexOf(Math.max(...values));
        const lowIdx = values.indexOf(Math.min(...values));
        const top = keys[topIdx];
        const low = keys[lowIdx];
        const personality = getElementPersonality(top, low);
        const profile = makeElementProfile(elements);
        const evidenceLine = makeElementEvidence(elements, breakdown, top, low);

        const totalSum = values.reduce((a, b) => a + b, 0) || 1;
        const rounded = keys.reduce((acc, k) => {
          acc[k] = Math.round((elements[k] || 0) * 10) / 10;
          return acc;
        }, {});
        const percent = keys.reduce((acc, k) => {
          acc[k] = Math.round(((elements[k] || 0) / totalSum) * 1000) / 10;
          return acc;
        }, {});

        elementsSummary.textContent = `지금은 ${top} 기운이 가장 강하고, ${low} 기운이 상대적으로 약한 편이야.`;
        renderElementsRadar(elements);

        const detailLines = [
          meta.birthText ? `출생: ${meta.birthText}` : null,
          meta.anchorApplied
            ? `신토정비결 보정 적용: ${meta.anchorKey}`
            : meta.anchorKey
            ? `신토정비결 보정 미적용: ${meta.anchorKey}`
            : null,
          `오행 분포(%) : 목 ${percent["목"]}% · 화 ${percent["화"]}% · 토 ${percent["토"]}% · 금 ${percent["금"]}% · 수 ${percent["수"]}%`,
          `오행 점수(총 150): 목 ${rounded["목"]} · 화 ${rounded["화"]} · 토 ${rounded["토"]} · 금 ${rounded["금"]} · 수 ${rounded["수"]}`,
          `프로파일: 강 ${profile.strong} · 중 ${profile.mid} · 약 ${profile.weak} (평균 ${profile.avg})`,
          `평균 대비: ${elementDeltaLines(elements)}`,
          evidenceLine || null,
          breakdown ? formatElemLine("천간:", breakdown.stems, totalSum) : null,
          breakdown
            ? formatElemLine("지지 본기:", breakdown.branches, totalSum)
            : null,
          breakdown && meta.hiddenMode === "on"
            ? formatElemLine("장간:", breakdown.hidden, totalSum)
            : null,
          breakdown
            ? formatElemLine("월령 가중(간이):", breakdown.season, totalSum)
            : null,
          `강한 ${top}: 집중/추진 쪽으로 쓰면 성과가 빨라져. 특히 ${top}는 현재 전체의 약 ${Math.round(
            (values[topIdx] / totalSum) * 100
          )}% 수준이야.`,
          `약한 ${low}: 루틴/환경 보완으로 충분히 메꿀 수 있어. ${low}는 지금 가장 낮은 구간이라 의식적으로 챙기는 게 좋아.`,
          `성향 요약: ${personality}`,
          ...elementAdvice(profile),
          meta.includeHour === false
            ? "시주 미포함: 시간 정보가 없어 시주의 영향은 제외했어."
            : meta.includeHour === "partial"
            ? "시주 일부 미포함: 한쪽은 시간 정보가 없어 시주가 제외됐어."
            : null,
          meta.boundaryText ? meta.boundaryText : null,
          `균형 팁: 상생 구조를 따라 ${top}의 장점을 살리되, ${low}를 받쳐줄 생활 습관을 하나만 고정하면 흐름이 안정돼.`,
        ].filter(Boolean);
        elementsDetail.innerHTML = detailLines
          .map((l) => escapeHtml(l))
          .join("<br/>");
      }

      function getElementPersonality(top, low) {
        const topMap = {
          목: "확장형. 아이디어/개척에 강하고, 빠르게 움직여.",
          화: "표현형. 추진/열정이 강하고, 분위기를 주도해.",
          토: "안정형. 조율/관리 중심이며, 신뢰가 자산이야.",
          금: "정밀형. 기준/원칙이 뚜렷하고, 결정이 빠른 편이야.",
          수: "분석형. 정보/흐름을 읽고, 유연하게 대응해.",
        };
        const lowMap = {
          목: "새로운 시도는 쉬는데 마무리가 약해질 수 있어.",
          화: "흥이 떨어지면 동력이 급감할 수 있어.",
          토: "루틴이 흐트러지면 불안정해질 수 있어.",
          금: "결정 기준이 흔들리면 스트레스가 커질 수 있어.",
          수: "과한 정보 탐색으로 결정이 늦어질 수 있어.",
        };
        const topLine = topMap[top] || "기질의 중심이 되는 성향이 또렷해.";
        const lowLine = lowMap[low] || "약한 축을 보완하면 안정감이 올라가.";
        return `${topLine} ${lowLine}`;
      }

      function renderElementsRadar(elements) {
        const svg = elementsRadarSvg;
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const vals = values.map((v) => clamp01(v / maxVal));
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = `${name} ${
            Math.round((elements[name] || 0) * 10) / 10
          }`;
          svg.appendChild(text);
        });

        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(245,158,11,0.25)",
          stroke: "rgba(217,119,6,0.95)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        const dots = vals.map((v, i) => {
          const dot = el("circle", {
            cx: cx,
            cy: cy,
            r: "3.5",
            fill: "rgba(217,119,6,0.95)",
          });
          svg.appendChild(dot);
          return { dot, v, i };
        });

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          dots.forEach(({ dot, v, i }) => {
            const [dx, dy] = pt(v * p, i);
            dot.setAttribute("cx", dx.toFixed(2));
            dot.setAttribute("cy", dy.toFixed(2));
          });
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      function getGenerator(elem) {
        const map = { 화: "목", 토: "화", 금: "토", 수: "금", 목: "수" };
        return map[elem] || "";
      }

      function getOvercomeElem(elem) {
        const entries = Object.entries(OVERCOME);
        const found = entries.find(([, v]) => v === elem);
        return found ? found[0] : "";
      }

      function getYongshinSuggestion(person) {
        const suggestions = [];
        const genWeak = getGenerator(person.weakElem);
        const controlTop = getOvercomeElem(person.topElem);
        if (person.weakScore <= 0.8 && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `약한 ${person.weakElem} 보완`,
          });
        }
        if (person.topScore >= 1.4 && controlTop) {
          suggestions.push({
            elem: controlTop,
            reason: `강한 ${person.topElem} 조절`,
          });
        }
        if (!suggestions.length && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `균형 유지`,
          });
        }
        return suggestions;
      }

      function calcStrength(elements, dayElem, seasonElem) {
        if (!dayElem) return "중간";
        const total = Object.values(elements).reduce((a, b) => a + b, 0);
        const avg = total / 5;
        let score = elements[dayElem] || 0;
        if (seasonElem === dayElem) score += 0.6;
        if (GENERATE[seasonElem] === dayElem) score += 0.3;
        if (OVERCOME[seasonElem] === dayElem) score -= 0.3;
        if (score >= avg + 0.2) return "신강";
        if (score <= avg - 0.2) return "신약";
        return "중간";
      }

      function listInternalPairs(branches, table) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (hasPair(branches[i], branches[j], table)) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function listInternalHyeong(branches) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (
              HYEONG.some(
                ([a, b]) =>
                  (branches[i] === a && branches[j] === b) ||
                  (branches[i] === b && branches[j] === a)
              )
            ) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function renderDeepAnalysisCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderDeepBlock("A", a));
        if (b) blocks.push(renderDeepBlock("B", b));
        deepAnalysis.innerHTML = blocks.join("");
      }

      function renderDeepBlock(label, person) {
        const yongshin = getYongshinSuggestion(person);
        const yongText = yongshin.length
          ? yongshin.map((y) => `${y.elem}(${y.reason})`).join(", ")
          : "—";
        const season =
          person.monthBranch && person.seasonTopElem
            ? `${person.monthBranch}(${person.seasonTopElem})`
            : "—";
        const seasonLine =
          person.seasonTopElem && person.topElem === person.seasonTopElem
            ? "월령과 강점이 같아 자연스럽게 힘이 실리는 타입."
            : "월령과 강점이 달라 조율·보완이 중요해.";
        const currentLine = formatElemLine("현재 오행:", person.elements);
        const dayStemLine = person.dayStem
          ? `일간: ${person.dayStem}(${person.dayElem}) · ${person.strength}`
          : "일간: —";
        const tenGodLine = person.dayStem
          ? `십성(간이): 연 ${tenGod(
              person.dayStem,
              person.yearStem
            )} · 월 ${tenGod(person.dayStem, person.monthStem)} · 일 ${tenGod(
              person.dayStem,
              person.dayStem
            )} · 시 ${
              person.hourStem ? tenGod(person.dayStem, person.hourStem) : "—"
            }`
          : "십성(간이): —";
        const branches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const hap = listInternalPairs(branches, LIUHE);
        const chung = listInternalPairs(branches, CHUNG);
        const hyeong = listInternalHyeong(branches);
        const relationLine = `합: ${hap.length ? hap.join(", ") : "—"} · 충: ${
          chung.length ? chung.join(", ") : "—"
        } · 형: ${hyeong.length ? hyeong.join(", ") : "—"}`;
        return `
          <div class="rule-card">
            <div class="section-title">${label} 심화 요약</div>
            <div class="mini">${escapeHtml(dayStemLine)}</div>
            <div class="mini">${escapeHtml(tenGodLine)}</div>
            <div class="mini">간이 용신: ${escapeHtml(yongText)}</div>
            <div class="mini">격국(간이): 월지 ${escapeHtml(
              season
            )} 중심. ${escapeHtml(seasonLine)}</div>
            <div class="mini">${escapeHtml(currentLine)}</div>
            <div class="mini">${escapeHtml(relationLine)}</div>
          </div>
        `;
      }

      function getHourRangeText(branch) {
        const map = {
          자: "00:00~01:30",
          축: "01:31~03:30",
          인: "03:31~05:30",
          묘: "05:31~07:30",
          진: "07:31~09:30",
          사: "09:31~11:30",
          오: "11:31~13:30",
          미: "13:31~15:30",
          신: "15:31~17:30",
          유: "17:31~19:30",
          술: "19:31~21:30",
          해: "21:31~23:30",
        };
        return map[branch] || "—";
      }

      function makeYearNarrative(person, targetYear) {
        const pillar = ganzhiYear(targetYear);
        const yearElem = STEM_ELEM[pillar.stem];
        const yearTenGod = person.dayStem
          ? tenGod(person.dayStem, pillar.stem)
          : "";
        const mode = yearModeText(
          pickYearMode(
            relationElem(yearElem, person.topElem),
            relationElem(yearElem, person.weakElem)
          )
        );
        const total = `2026년은 ${mode} 기운이 크게 작용하는 해입니다. 일간 ${
          person.dayStem || "—"
        } 기준으로 세운 천간 십성은 ${
          yearTenGod || "—"
        }이니, 먼저 기준을 세우고 움직일수록 결과가 단단해집니다. 급히 밀기보다 방향을 고정하고 한 걸음씩 나아가면 길합니다.`;
        const money = `재물운은 ${person.weakElem} 약점을 보완하는 쪽이 요체입니다. 큰돈을 탐하기보다 작은 이익을 꾸준히 쌓는 길이 안정적이며, 무리한 확장은 손실로 이어질 수 있습니다. 현금 흐름을 먼저 붙들고 지출의 틀을 정해두면 길합니다.`;
        const work = `직장/사업은 ${person.topElem} 장점을 살릴 때 빠른 성과로 이어집니다. 다만 속도 경쟁은 과열을 부르니, 목표를 좁혀 집중하는 편이 안전합니다. 제안과 협상은 원칙을 세우고 천천히 진행해야 길합니다.`;
        const family = `가정/건강은 ${person.weakElem} 축을 챙기는 것이 요체입니다. 루틴과 휴식을 먼저 잡으면 기력이 크게 회복되고, 사소한 갈등은 정리와 조율로 풀어가면 길해집니다. 작은 습관 하나가 큰 복이 됩니다.`;
        const relation = `대인관계는 ${
          person.balance < 0.3 ? "균형" : "정리"
        } 흐름이 좋습니다. 도움 주는 인연을 놓치지 말고, 말이 많은 사람은 선을 분명히 하면 실수가 줄어듭니다. 신뢰를 지키는 말 한마디가 인연을 붙잡습니다.`;
        return { total, money, work, family, relation };
      }

      function makeReportKeywords(person) {
        const out = [];
        if (person.topElem) out.push(`강점 ${person.topElem}`);
        if (person.weakElem) out.push(`보완 ${person.weakElem}`);
        if (person.dayStem) out.push(`일간 ${person.dayStem}`);
        if (person.strength) out.push(`강약 ${person.strength}`);
        if (person.seasonTopElem) out.push(`월령 ${person.seasonTopElem}`);
        return out.length ? out.join(" · ") : "—";
      }

      function makeActionTips(person) {
        return {
          total: `핵심 행동: ${person.topElem} 기운을 중심으로 한 가지 목표를 먼저 세우고, 끝까지 흔들지 않는 것이 길합니다.`,
          money: `지출 관리: ${person.weakElem} 보완용 루틴을 하나 고정하면 새는 돈이 줄고 흐름이 안정됩니다.`,
          work: `업무 전략: ${person.topElem} 강점을 살릴 수 있는 역할을 먼저 맡아야 성과가 빠르게 드러납니다.`,
          family: `건강 루틴: 수면/식사 중 하나를 고정하면 체력과 마음이 함께 안정됩니다.`,
          relation: `관계 팁: 선을 분명히 하고 약속을 지키면 오해가 줄고 신뢰가 깊어집니다.`,
        };
      }

      const ELEM_CLASS = {
        목: "wood",
        화: "fire",
        토: "earth",
        금: "metal",
        수: "water",
      };
      function elemClass(elem) {
        return ELEM_CLASS[elem] ? `e-${ELEM_CLASS[elem]}` : "";
      }
      function tenGodChip(label, text, elem) {
        const cls = elemClass(elem);
        return `<span class="chip ${cls}"><b>${escapeHtml(
          label
        )}</b> ${escapeHtml(text)}</span>`;
      }

      function renderReportCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderReportBlock("A", a, state.aResult));
        if (b) blocks.push(renderReportBlock("B", b, state.bResult));
        reportContent.innerHTML = blocks.join("");
      }

      function renderReportBlock(label, person, result) {
        if (!result) return "";
        const targetYear = 2026;
        const birthYear = Number(result.input.local.slice(0, 4));
        const age = toKoreanAge(targetYear, birthYear);
        const genderLabel = person.gender === "female" ? "여자" : "남자";
        const solar = result.input.local.slice(0, 10).replaceAll("-", ".");
        const lunar = person.lunarDate ? person.lunarDate : "—";
        const hourBranch = person.includeHour ? person.hourBranch : "—";
        const hourRange = person.includeHour
          ? getHourRangeText(person.hourBranch)
          : "—";
        const p = result.pillars;
        const yearTen = tenGod(person.dayStem, person.yearStem);
        const monthTen = tenGod(person.dayStem, person.monthStem);
        const dayTen = "일간";
        const hourTen = person.hourStem
          ? tenGod(person.dayStem, person.hourStem)
          : "—";
        const yearChip = tenGodChip(
          "연",
          `${p.year.stem}(${STEM_ELEM[p.year.stem]}) ${yearTen || "—"} / ${
            p.year.branch
          }(${BRANCH_ELEM[p.year.branch]})`,
          STEM_ELEM[p.year.stem]
        );
        const monthChip = tenGodChip(
          "월",
          `${p.month.stem}(${STEM_ELEM[p.month.stem]}) ${monthTen || "—"} / ${
            p.month.branch
          }(${BRANCH_ELEM[p.month.branch]})`,
          STEM_ELEM[p.month.stem]
        );
        const dayChip = tenGodChip(
          "일",
          `${p.day.stem}(${STEM_ELEM[p.day.stem]}) ${dayTen} / ${p.day.branch}(${
            BRANCH_ELEM[p.day.branch]
          })`,
          STEM_ELEM[p.day.stem]
        );
        const hourChip = p.hour
          ? tenGodChip(
              "시",
              `${p.hour.stem}(${STEM_ELEM[p.hour.stem]}) ${
                hourTen || "—"
              } / ${p.hour.branch}(${BRANCH_ELEM[p.hour.branch]})`,
              STEM_ELEM[p.hour.stem]
            )
          : `<span class="chip"><b>시</b> —</span>`;
        const coreBranches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const coreHap = listInternalPairs(coreBranches, LIUHE);
        const coreChung = listInternalPairs(coreBranches, CHUNG);
        const coreHyeong = listInternalHyeong(coreBranches);
        const hapText = coreHap.length ? coreHap.join(", ") : "—";
        const chungText = coreChung.length ? coreChung.join(", ") : "—";
        const hyeongText = coreHyeong.length ? coreHyeong.join(", ") : "—";
        const hapInterpret = coreHap.length
          ? "합이 있어 협력과 회복의 기운이 따릅니다."
          : "합이 적어 도움과 완충이 약하니 스스로 지키는 것이 중요합니다.";
        const chungInterpret = coreChung.length
          ? "충이 있어 타이밍이 엇갈리기 쉬우니 확인을 거듭해야 합니다."
          : "충이 적어 급한 충돌은 드뭅니다. 다만 방심은 금물입니다.";
        const hyeongInterpret = coreHyeong.length
          ? "형이 있어 감정의 마찰이 생길 수 있으니 언행을 절제해야 합니다."
          : "형이 적어 큰 마찰은 적습니다. 작은 불씨를 먼저 끄면 길합니다.";
        const hapAction = coreHap.length
          ? "합이 있는 날은 협업/합의를 먼저 잡는 것이 유리합니다. 사례: 계약·소개·동업 제안."
          : "합이 약하니 독단을 경계하고 조력자를 구하는 것이 좋습니다. 사례: 중요한 결정은 보류.";
        const chungAction = coreChung.length
          ? "충이 있는 날은 일정·계약을 한 번 더 점검해야 합니다. 사례: 이동·이사·변경 건."
          : "충이 적어 급변은 덜하나, 확인을 생활화해야 합니다. 사례: 약속 시간 재확인.";
        const hyeongAction = coreHyeong.length
          ? "형이 있는 날은 말의 톤과 속도를 줄여 마찰을 피해야 합니다. 사례: 가족·동료 대화."
          : "형이 적어도 감정의 여지를 남기면 길합니다. 사례: 갈등은 한 박자 늦게.";
        const coreRelationLine = `합 ${coreHap.length ? coreHap.join(", ") : "—"} · 충 ${
          coreChung.length ? coreChung.join(", ") : "—"
        } · 형 ${coreHyeong.length ? coreHyeong.join(", ") : "—"}`;
        const coreInterpret =
          coreChung.length || coreHyeong.length
            ? "충/형 기운이 있어 타이밍과 감정 조율이 관건입니다."
            : coreHap.length
            ? "합 기운이 살아 있어 협력과 회복력이 좋습니다."
            : "특이한 합/충/형이 적어 흐름이 비교적 평온합니다.";
        const narrative = makeYearNarrative(person, targetYear);
        const tips = makeActionTips(person);
        const keywords = makeReportKeywords(person);
        const profile = makeElementProfile(person.elements);
        const evidence = makeElementEvidence(
          person.elements,
          result.elements.breakdown,
          person.topElem,
          person.weakElem
        );
        const totalSum =
          Object.values(person.elements).reduce((a, b) => a + b, 0) || 1;
        const monthList = makeMonthlyLuck(person)
          .map((m) => {
            const basis = `근거: 월령 ${m.seasonElem} · 강 ${person.topElem} · 약 ${person.weakElem}`;
            return `<div class="rule-card">
              <div class="row" style="justify-content: space-between">
                <div class="section-title">${m.month}월 · ${
              m.seasonElem
            } 흐름</div>
                <span class="mini">${m.tags.join(" · ")}</span>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              <p class="mini">팁: ${escapeHtml(m.tip)}</p>
              ${m.extra ? `<p class="mini">${escapeHtml(m.extra)}</p>` : ""}
              ${
                m.detail ? `<p class="mini">${escapeHtml(m.detail)}</p>` : ""
              }
              <p class="mini">${escapeHtml(basis)}</p>
            </div>`;
          })
          .join("");

        const daewoonRaw = String(person.daewoonStartAge ?? "").trim();
        let daewoonLine = "대운 시작 나이를 입력해줘.";
        if (daewoonRaw !== "") {
          const daewoonStart = Number(daewoonRaw);
          const startYear = birthYear + daewoonStart - 1;
          const blocks = [];
          for (let i = 0; i < 10; i++) {
            const ageStart = daewoonStart + i * 10;
            const ganji = ganzhiYear(startYear + i * 10).text;
            blocks.push(`${ageStart}세~ ${ganji}`);
          }
          daewoonLine = blocks.join(" · ");
        }

        return `
          <div class="rule-card">
            <div class="section-title">${targetYear} 신토정비결 · ${label}</div>
            <div class="mini">회원님(${genderLabel}, ${age}세)</div>
            <div class="mini">양력: ${solar} · 음력: ${escapeHtml(
          lunar
        )} · 태어난 시간: ${hourBranch} (${hourRange})</div>
            <table class="report-table">
              <thead>
                <tr>
                  <th></th>
                  <th>년</th>
                  <th>월</th>
                  <th>일</th>
                  <th>시</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>천간</th>
                  <td>${STEM_YINYANG[p.year.stem] || ""} ${p.year.stem} ${
          STEM_ELEM[p.year.stem] || ""
        } · ${yearTen || "—"}</td>
                  <td>${STEM_YINYANG[p.month.stem] || ""} ${p.month.stem} ${
          STEM_ELEM[p.month.stem] || ""
        } · ${monthTen || "—"}</td>
                  <td>${STEM_YINYANG[p.day.stem] || ""} ${p.day.stem} ${
          STEM_ELEM[p.day.stem] || ""
        } · ${dayTen}</td>
                  <td>${
                    p.hour
                      ? `${STEM_YINYANG[p.hour.stem] || ""} ${p.hour.stem} ${
                          STEM_ELEM[p.hour.stem] || ""
                        } · ${hourTen || "—"}`
                      : "—"
                  }</td>
                </tr>
                <tr>
                  <th>지지</th>
                  <td>${p.year.branch} ${BRANCH_ELEM[p.year.branch]}</td>
                  <td>${p.month.branch} ${BRANCH_ELEM[p.month.branch]}</td>
                  <td>${p.day.branch} ${BRANCH_ELEM[p.day.branch]}</td>
                  <td>${
                    p.hour
                      ? `${p.hour.branch} ${BRANCH_ELEM[p.hour.branch]}`
                      : "—"
                  }</td>
                </tr>
              </tbody>
            </table>
            <div class="mini">일주/강약: ${person.dayStem || "—"} · ${
          person.strength
        }</div>
            <div class="mini">오행: ${formatElemLine(
              "",
              person.elements,
              totalSum
            )}</div>
            <div class="mini">프로파일: 강 ${profile.strong} · 중 ${
          profile.mid
        } · 약 ${profile.weak}</div>
            <div class="mini">${escapeHtml(evidence)}</div>
            <div class="mini">세운 천간 십성: ${
              ganzhiYear(targetYear).stem
            } · ${
          person.dayStem
            ? tenGod(person.dayStem, ganzhiYear(targetYear).stem)
            : "—"
        }</div>
            <div class="mini">핵심 키워드: ${escapeHtml(keywords)}</div>
            <div class="report-section">
              <h3>명리 핵심</h3>
              <table class="report-table">
                <thead>
                  <tr>
                    <th>구분</th>
                    <th>내용</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>일간</th>
                    <td>${escapeHtml(person.dayStem || "—")}</td>
                  </tr>
                  <tr>
                    <th>강약</th>
                    <td>${escapeHtml(person.strength || "—")}</td>
                  </tr>
                  <tr>
                    <th>십성</th>
                    <td>
                      <div class="chip-row">${yearChip}${monthChip}${dayChip}${hourChip}</div>
                    </td>
                  </tr>
                  <tr>
                    <th>충/합/형</th>
                    <td>합 ${escapeHtml(hapText)} · 충 ${escapeHtml(
          chungText
        )} · 형 ${escapeHtml(hyeongText)}</td>
                  </tr>
                </tbody>
              </table>
              <p class="mini">합 해석: ${escapeHtml(hapInterpret)}</p>
              <p class="mini">합 지침: ${escapeHtml(hapAction)}</p>
              <p class="mini">충 해석: ${escapeHtml(chungInterpret)}</p>
              <p class="mini">충 지침: ${escapeHtml(chungAction)}</p>
              <p class="mini">형 해석: ${escapeHtml(hyeongInterpret)}</p>
              <p class="mini">형 지침: ${escapeHtml(hyeongAction)}</p>
            </div>
            <div class="report-section">
              <h3>총론</h3>
              <p class="mini">${escapeHtml(narrative.total)}</p>
              <p class="mini">${escapeHtml(tips.total)}</p>
            </div>
            <div class="report-section">
              <h3>재물운</h3>
              <p class="mini">${escapeHtml(narrative.money)}</p>
              <p class="mini">${escapeHtml(tips.money)}</p>
            </div>
            <div class="report-section">
              <h3>직장 / 사업운</h3>
              <p class="mini">${escapeHtml(narrative.work)}</p>
              <p class="mini">${escapeHtml(tips.work)}</p>
            </div>
            <div class="report-section">
              <h3>가정 / 건강운</h3>
              <p class="mini">${escapeHtml(narrative.family)}</p>
              <p class="mini">${escapeHtml(tips.family)}</p>
            </div>
            <div class="report-section">
              <h3>이성 / 대인관계</h3>
              <p class="mini">${escapeHtml(narrative.relation)}</p>
              <p class="mini">${escapeHtml(tips.relation)}</p>
            </div>
            <div class="report-section">
              <h3>대운(간이)</h3>
              <p class="mini">${escapeHtml(daewoonLine)}</p>
            </div>
            <div class="report-section">
              <h3>월별 세운</h3>
              ${monthList}
            </div>
          </div>
        `;
      }

      function getLocalNowYear(tzOffsetMinutes, dstMode) {
        const parts = toLocalDateParts(new Date(), tzOffsetMinutes, dstMode);
        return parts.y;
      }

      function pickYearMode(relTop, relWeak) {
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";
        return mode;
      }

      function yearModeText(mode) {
        const map = {
          push: "확장/추진에 유리",
          pushPlus: "성과+회복 동시",
          recover: "정리/회복에 유리",
          brake: "속도 조절 필요",
          steady: "기본 유지",
        };
        return map[mode] || "기본 유지";
      }

      function buildYearFlows(person, tzOffsetMinutes, dstMode) {
        const startYear = getLocalNowYear(tzOffsetMinutes, dstMode);
        const flows = [];
        for (let i = 0; i < 10; i++) {
          const year = startYear + i;
          const pillar = ganzhiYear(year);
          const yearElem = STEM_ELEM[pillar.stem];
          const relTop = relationElem(yearElem, person.topElem);
          const relWeak = relationElem(yearElem, person.weakElem);
          const mode = pickYearMode(relTop, relWeak);
          const yearTenGod = person.dayStem
            ? tenGod(person.dayStem, pillar.stem)
            : "";
          flows.push({
            year,
            pillar,
            yearElem,
            mode,
            yearTenGod,
          });
        }
        return flows;
      }

      function summarizeDecades(flows) {
        const buckets = {};
        flows.forEach((f) => {
          const start = f.year - (f.year % 10);
          if (!buckets[start]) buckets[start] = [];
          buckets[start].push(f);
        });
        return Object.entries(buckets).map(([start, list]) => {
          const counts = list.reduce((acc, cur) => {
            acc[cur.mode] = (acc[cur.mode] || 0) + 1;
            return acc;
          }, {});
          const topMode = Object.entries(counts).sort(
            (a, b) => b[1] - a[1]
          )[0][0];
          return {
            range: `${start}~${Number(start) + 9}`,
            mode: topMode,
          };
        });
      }

      function renderLuckFlowCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderLuckBlock("A", a));
        if (b) blocks.push(renderLuckBlock("B", b));
        luckFlow.innerHTML = blocks.join("");
      }

      function renderLuckBlock(label, person) {
        const tzOffsetMinutes = person.tzOffsetMinutes ?? 540;
        const dstMode = person.dstMode || "off";
        const flows = buildYearFlows(person, tzOffsetMinutes, dstMode);
        const decades = summarizeDecades(flows);
        const decadeSummary = decades
          .map((d) => `${d.range}: ${yearModeText(d.mode)}`)
          .join(" · ");
        const daewoonNarrative = `대운은 큰 흐름을 가늠하는 길잡이입니다. ${
          decadeSummary || "—"
        }`;
        const yearLines = flows
          .map(
            (f) =>
              `${f.year}년 ${f.pillar.text}(${f.yearElem}) · ${
                f.yearTenGod ? `십성 ${f.yearTenGod} · ` : ""
              }${yearModeText(f.mode)}`
          )
          .join("<br/>");
        const sewoonNarrative =
          "세운은 매해의 결을 읽는 자리니, 강한 해에는 밀고 약한 해에는 지키면 길합니다.";

        return `
          <div class="rule-card">
            <div class="section-title">${label} 대운/세운</div>
            <div class="mini">대운(10년): ${escapeHtml(daewoonNarrative)}</div>
            <div class="mini">세운(10년): ${yearLines}</div>
            <div class="mini">${escapeHtml(sewoonNarrative)}</div>
          </div>
        `;
      }

      function setResultVisibility(mode) {
        resultElementsCard.classList.toggle("hidden", !state.A);
        resultDeepCard.classList.toggle("hidden", !state.A);
        resultLuckCard.classList.toggle("hidden", !state.A);
        resultTodayCard.classList.toggle("hidden", mode === "newyear");
        resultRadarCard.classList.toggle("hidden", mode !== "compat");
        resultABCard.classList.toggle("hidden", mode !== "compat");
        resultRulesCard.classList.toggle("hidden", mode !== "compat");
        resultMonthlyCard.classList.toggle("hidden", mode === "today");
        tuningCard.classList.toggle("hidden", mode !== "compat");
      }

      function renderCompat() {
        const a = buildPerson(state.A);
        const b = buildPerson(state.B);
        const toneKey = toneSelect.value;
        const firedRules = evaluateRules(a, b);
        const sectionScores = calcSectionScores(firedRules);
        const totalScore = calcTotalFromSections(sectionScores);
        const coupleElements = combineElements(a.elements, b.elements);
        const coupleBreakdown = combineBreakdown(
          state.aResult?.elements?.breakdown,
          state.bResult?.elements?.breakdown
        );
        const coupleStats = getTopWeak(coupleElements);

        resultTitle.textContent = "궁합 요약";
        const includeHourMode =
          state.A?.includeHour === state.B?.includeHour
            ? Boolean(state.A?.includeHour)
            : "partial";
        renderElementsAnalysis(coupleElements, coupleBreakdown, {
          hiddenMode:
            state.aResult?.input?.hiddenMode === "on" ||
            state.bResult?.input?.hiddenMode === "on"
              ? "on"
              : "off",
          includeHour: includeHourMode,
        });
        renderDeepAnalysisCard(a, b);
        renderLuckFlowCard(a, b);
        renderSummary(totalScore, firedRules, toneKey, coupleElements);
        renderTodayCoupleBox(a, b);
        renderRadar(sectionScores);
        renderRules(firedRules, toneKey, {
          topElem: coupleStats.top,
          weakElem: coupleStats.weak,
          A_topElem: a.topElem,
          B_topElem: b.topElem,
          A_weakElem: a.weakElem,
          B_weakElem: b.weakElem,
          A_branch: a.dayBranch,
          B_branch: b.dayBranch,
          A_season: a.seasonTopElem,
          B_season: b.seasonTopElem,
        });
        renderMonthly({ elements: coupleElements });
        renderPillars(aPillarsEl, state.aResult);
        renderPillars(bPillarsEl, state.bResult);

        return { totalScore, firedRules, coupleElements };
      }

      function renderNewYear() {
        const a = buildPerson(state.A);
        const { top, weak } = getTopWeak(a.elements);
        resultTitle.textContent = "신년운세 요약";
        renderElementsAnalysis(a.elements, state.aResult?.elements?.breakdown, {
          hiddenMode: state.aResult?.input?.hiddenMode,
          includeHour: state.A?.includeHour,
          boundaryText: state.A?.boundaryText,
          birthText: state.aResult?.input?.local
            ? `${state.aResult.input.local} (${state.A?.hourBranch || "—"})`
            : "",
          anchorKey: state.aResult?.elements?.anchor?.key,
          anchorApplied: state.aResult?.elements?.anchor?.applied,
        });
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "—";
        summarySub.textContent = "2026 흐름 · 월별 운세";
        summaryMain.textContent = `2026년은 ${top} 기운이 힘이 되고, ${weak} 쪽을 보완하면 흐름이 좋아져.`;
        summaryPills.innerHTML = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          "2026 월별 흐름",
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = "—";
        todayCoupleMeta.textContent = "";
        renderMonthly(a);
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";

        return { totalScore: null, coupleElements: a.elements };
      }

      function renderTodayOnly() {
        const a = buildPerson(state.A);
        resultTitle.textContent = "오늘운세 요약";
        renderElementsAnalysis(a.elements, state.aResult?.elements?.breakdown, {
          hiddenMode: state.aResult?.input?.hiddenMode,
          includeHour: state.A?.includeHour,
          boundaryText: state.A?.boundaryText,
          birthText: state.aResult?.input?.local
            ? `${state.aResult.input.local} (${state.A?.hourBranch || "—"})`
            : "",
          anchorKey: state.aResult?.elements?.anchor?.key,
          anchorApplied: state.aResult?.elements?.anchor?.applied,
        });
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "—";
        summarySub.textContent = "오늘 일진 기반";
        summaryMain.textContent = todayLuckLine(a);
        summaryPills.innerHTML = [
          `핵심 오행: ${a.topElem}`,
          `약한 오행: ${a.weakElem}`,
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = todayLuckLine(a);
        todayCoupleMeta.textContent = `오늘 오행: ${
          getTodayElementFlow().stemElem
        }/${getTodayElementFlow().branchElem}`;
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";
      }

      function renderAll() {
        if (!state.A) return;
        setResultVisibility(state.mode);
        if (state.mode === "compat") return renderCompat();
        if (state.mode === "newyear") return renderNewYear();
        return renderTodayOnly();
      }

      /* ======================================================
  10. 공유 카드
====================================================== */
      function roundRect(ctx, x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let i = 0; i < words.length; i++) {
          const test = line + words[i] + " ";
          if (ctx.measureText(test).width > maxWidth && i > 0) {
            ctx.fillText(line, x, y);
            line = words[i] + " ";
            y += lineHeight;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, y);
      }

      async function generateShareCard(payload) {
        const c = document.getElementById("shareCanvas");
        const ctx = c.getContext("2d");

        const g = ctx.createLinearGradient(0, 0, 0, c.height);
        g.addColorStop(0, "#0b1621");
        g.addColorStop(0.5, "#101f2e");
        g.addColorStop(1, "#14273b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, c.width, c.height);

        const pad = 70;
        const cardX = pad;
        const cardY = pad;
        const cardW = c.width - pad * 2;
        const cardH = c.height - pad * 2;
        roundRect(
          ctx,
          cardX,
          cardY,
          cardW,
          cardH,
          40,
          "rgba(255,255,255,0.92)"
        );

        ctx.fillStyle = "#0f172a";
        ctx.font = "800 52px IBM Plex Sans KR";
        ctx.fillText(payload.title, cardX + 50, cardY + 120);

        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.toneLabel, cardX + 50, cardY + 170);

        ctx.font = "800 110px IBM Plex Sans KR";
        ctx.fillStyle = "#0f172a";
        ctx.fillText(String(payload.scoreText), cardX + 50, cardY + 300);
        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.scoreLabel, cardX + 50, cardY + 350);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.85)";
        ctx.fillText(`핵심 오행: ${payload.topElem}`, cardX + 50, cardY + 430);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        wrapText(
          ctx,
          `요약: ${payload.summary}`,
          cardX + 50,
          cardY + 510,
          cardW - 100,
          44
        );

        ctx.font = "700 28px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.78)";
        wrapText(
          ctx,
          payload.todayLine,
          cardX + 50,
          cardY + 700,
          cardW - 100,
          40
        );

        ctx.font = "700 26px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.6)";
        ctx.fillText("funnyfunny.cloud", cardX + 50, cardY + cardH - 70);

        return new Promise((resolve) => c.toBlob(resolve, "image/png", 1.0));
      }

      function getSharePayload(snapshot) {
        if (state.mode === "compat") {
          return {
            title: "궁합 리포트",
            toneLabel: TONE[toneSelect.value]?.title || "커플 모드",
            scoreText: snapshot.totalScore,
            scoreLabel: "궁합 점수",
            summary: summaryMain.textContent,
            todayLine: todayCoupleLine.textContent,
            topElem: getTopWeak(snapshot.coupleElements).top,
          };
        }
        if (state.mode === "newyear") {
          const topElem = getTopWeak(state.A.elements).top;
          return {
            title: "신년운세 리포트",
            toneLabel: "2026 흐름",
            scoreText: "—",
            scoreLabel: "운세 요약",
            summary: summaryMain.textContent,
            todayLine: "월별 흐름으로 계획 세우기 좋다.",
            topElem,
          };
        }
        const topElem = getTopWeak(state.A.elements).top;
        return {
          title: "오늘운세",
          toneLabel: "일진 기반",
          scoreText: "—",
          scoreLabel: "오늘 흐름",
          summary: summaryMain.textContent,
          todayLine: todayCoupleLine.textContent,
          topElem,
        };
      }

      async function shareCard() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }
        const snapshot = renderAll() || {
          totalScore: "—",
          coupleElements: state.A.elements,
        };
        const blob = await generateShareCard(getSharePayload(snapshot));

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `운세카드_${new Date().toISOString().slice(0, 10)}.png`;
        a.click();

        try {
          await navigator.clipboard.write([
            new ClipboardItem({ "image/png": blob }),
          ]);
          shareStatus.textContent = "카드를 생성하고 클립보드에 복사했어.";
        } catch {
          shareStatus.textContent = "카드를 생성했어. 다운로드를 확인해줘.";
        }
      }

      /* ======================================================
  11. PDF 저장 (html2canvas + jsPDF)
====================================================== */
      async function savePdfPretty() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }
        if (!window.html2canvas || !window.jspdf) {
          alert("PDF 라이브러리가 준비되지 않았어.");
          return;
        }
        const area = document.getElementById("pdfArea");
        const canvas = await html2canvas(area, {
          scale: 2,
          backgroundColor: null,
          useCORS: true,
          logging: false,
        });
        const imgData = canvas.toDataURL("image/png", 1.0);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;

        if (imgH <= pageH) {
          pdf.addImage(imgData, "PNG", 0, 0, imgW, imgH);
        } else {
          let y = 0;
          let remaining = imgH;
          while (remaining > 0) {
            pdf.addImage(imgData, "PNG", 0, -y, imgW, imgH);
            remaining -= pageH;
            y += pageH;
            if (remaining > 0) pdf.addPage();
          }
        }

        const fileName = `운세리포트_${new Date()
          .toISOString()
          .slice(0, 10)}.pdf`;
        pdf.save(fileName);
      }

      /* ======================================================
  12. 입력/계산 파이프라인
====================================================== */
      function loadInputs() {
        try {
          return JSON.parse(localStorage.getItem(INPUT_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveInputs(data) {
        localStorage.setItem(INPUT_KEY, JSON.stringify(data));
      }

      function setInputs(data) {
        if (!data) return;
        aDate.value = data.aDate || "";
        aHourBranch.value = data.aHourBranch || "자";
        aTimeUnknown.checked = Boolean(data.aTimeUnknown);
        aGender.value = data.aGender || "male";
        aLunar.value = data.aLunar || "";
        aDaewoonStart.value = data.aDaewoonStart || "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = data.aTzOffset ?? "9";
        aDstMode.value = data.aDstMode || "off";
        bDate.value = data.bDate || "";
        bHourBranch.value = data.bHourBranch || "자";
        bTimeUnknown.checked = Boolean(data.bTimeUnknown);
        bGender.value = data.bGender || "female";
        bLunar.value = data.bLunar || "";
        bDaewoonStart.value = data.bDaewoonStart || "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = data.bTzOffset ?? "9";
        bDstMode.value = data.bDstMode || "off";
        toneSelect.value = data.tone || "couple";
      }

      function getInputData() {
        return {
          aDate: aDate.value,
          aHourBranch: aHourBranch.value,
          aTimeUnknown: aTimeUnknown.checked,
          aGender: aGender.value,
          aLunar: aLunar.value,
          aDaewoonStart: aDaewoonStart.value,
          aHiddenMode: "on",
          aTzOffset: aTzOffset.value,
          aDstMode: aDstMode.value,
          bDate: bDate.value,
          bHourBranch: bHourBranch.value,
          bTimeUnknown: bTimeUnknown.checked,
          bGender: bGender.value,
          bLunar: bLunar.value,
          bDaewoonStart: bDaewoonStart.value,
          bHiddenMode: "on",
          bTzOffset: bTzOffset.value,
          bDstMode: bDstMode.value,
          tone: toneSelect.value,
          mode: state.mode,
        };
      }

      function configureInputForMode(mode) {
        if (mode === "compat") {
          inputTitle.textContent = "궁합 입력";
          inputDesc.textContent = "A/B 출생 정보 입력 → 궁합 계산";
          panelB.classList.remove("hidden");
          toneRow.classList.remove("hidden");
        } else if (mode === "newyear") {
          inputTitle.textContent = "신년운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 2026 흐름";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
        } else {
          inputTitle.textContent = "오늘운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 오늘 한 줄";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
        }
      }

      function showStep(name) {
        stepMenu.classList.toggle("active", name === "menu");
        stepInput.classList.toggle("active", name === "input");
        stepResult.classList.toggle("active", name === "result");
      }

      async function computePair() {
        const data = getInputData();
        if (!data.aDate || !data.aHourBranch) {
          alert("A 날짜와 12간지를 선택해줘.");
          return;
        }
        if (state.mode === "compat" && (!data.bDate || !data.bHourBranch)) {
          alert("B 날짜와 12간지를 선택해줘.");
          return;
        }
        saveInputs(data);

        loadingOverlay.classList.add("active");
        loadingOverlay.setAttribute("aria-hidden", "false");
        await new Promise((r) => setTimeout(r, 700));

        const aOffsetMin = parseTzOffsetMinutes(data.aTzOffset, 540);
        const aIncludeHour = !data.aTimeUnknown;
        const aTimeStr = aIncludeHour
          ? hourBranchToTime(data.aHourBranch)
          : "12:00";
        const aBirth = parseLocalDateTime(
          data.aDate,
          aTimeStr,
          aOffsetMin,
          data.aDstMode
        );
        const aHourBranch = aIncludeHour ? data.aHourBranch : null;
        const aResult = computeSajuFiveElements(aBirth, {
          ziMode: "2300",
          hiddenMode: data.aHiddenMode,
          tzOffsetMinutes: aOffsetMin,
          dstMode: data.aDstMode,
          includeHour: aIncludeHour,
          hourBranchOverride: aHourBranch,
        });
        state.aResult = aResult;
        state.A = {
          name: "A",
          elements: aResult.elements.raw,
          dayBranch: aResult.pillars.day.branch,
          monthBranch: aResult.pillars.month.branch,
          yearBranch: aResult.pillars.year.branch,
          yearStem: aResult.pillars.year.stem,
          monthStem: aResult.pillars.month.stem,
          dayStem: aResult.pillars.day.stem,
          hourStem: aResult.pillars.hour ? aResult.pillars.hour.stem : "",
          tzOffsetMinutes: aOffsetMin,
          dstMode: data.aDstMode,
          includeHour: aIncludeHour,
          hourBranch: aHourBranch,
          boundaryText: makeBoundaryText(),
          altResult: null,
          gender: data.aGender,
          lunarDate: data.aLunar,
          daewoonStartAge: data.aDaewoonStart,
        };

        if (state.mode === "compat") {
          const bOffsetMin = parseTzOffsetMinutes(data.bTzOffset, 540);
          const bIncludeHour = !data.bTimeUnknown;
          const bTimeStr = bIncludeHour
            ? hourBranchToTime(data.bHourBranch)
            : "12:00";
          const bBirth = parseLocalDateTime(
            data.bDate,
            bTimeStr,
            bOffsetMin,
            data.bDstMode
          );
          const bHourBranch = bIncludeHour ? data.bHourBranch : null;
          const bResult = computeSajuFiveElements(bBirth, {
            ziMode: "2300",
            hiddenMode: data.bHiddenMode,
            tzOffsetMinutes: bOffsetMin,
            dstMode: data.bDstMode,
            includeHour: bIncludeHour,
            hourBranchOverride: bHourBranch,
          });
          state.bResult = bResult;
          state.B = {
            name: "B",
            elements: bResult.elements.raw,
            dayBranch: bResult.pillars.day.branch,
            monthBranch: bResult.pillars.month.branch,
            yearBranch: bResult.pillars.year.branch,
            yearStem: bResult.pillars.year.stem,
            monthStem: bResult.pillars.month.stem,
            dayStem: bResult.pillars.day.stem,
            hourStem: bResult.pillars.hour ? bResult.pillars.hour.stem : "",
            tzOffsetMinutes: bOffsetMin,
            dstMode: data.bDstMode,
            includeHour: bIncludeHour,
            hourBranch: bHourBranch,
            boundaryText: makeBoundaryText(),
            altResult: null,
            gender: data.bGender,
            lunarDate: data.bLunar,
            daewoonStartAge: data.bDaewoonStart,
          };
        } else {
          state.bResult = null;
          state.B = null;
        }

        showStep("result");
        renderAll();

        await new Promise((r) => setTimeout(r, 400));
        loadingOverlay.classList.remove("active");
        loadingOverlay.setAttribute("aria-hidden", "true");
      }

      /* ======================================================
  INIT
====================================================== */
      function init() {
        const cfg = loadTuneCfg();
        tuneStrength.value = String(cfg.strength ?? 1);
        tuneLabel.textContent = Number(tuneStrength.value).toFixed(1);
        updateTuneStatus();
        const saved = loadInputs();
        setInputs(saved);
        if (saved.mode) {
          state.mode = saved.mode;
          configureInputForMode(state.mode);
          showStep("input");
        }
      }

      document.querySelectorAll(".menu-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.mode = btn.dataset.mode;
          configureInputForMode(state.mode);
          showStep("input");
        });
      });

      backToMenu.addEventListener("click", () => showStep("menu"));
      clearSaved.addEventListener("click", () => {
        localStorage.removeItem(INPUT_KEY);
        aDate.value = "";
        aHourBranch.value = "자";
        aTimeUnknown.checked = false;
        aGender.value = "male";
        aLunar.value = "";
        aDaewoonStart.value = "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = "9";
        aDstMode.value = "off";
        bDate.value = "";
        bHourBranch.value = "자";
        bTimeUnknown.checked = false;
        bGender.value = "female";
        bLunar.value = "";
        bDaewoonStart.value = "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = "9";
        bDstMode.value = "off";
        toneSelect.value = "couple";
        alert("저장된 입력을 초기화했어.");
      });
      backToInput.addEventListener("click", () => showStep("input"));
      restartFlow.addEventListener("click", () => showStep("menu"));

      document.addEventListener("click", (e) => {
        const btn = e.target.closest(".like-btn");
        if (!btn) return;
        const ruleId = btn.dataset.rule;
        feedback(ruleId);
        btn.textContent = "공감됨 ✔";
        btn.disabled = true;
      });

      tuneStrength.addEventListener("input", () => {
        const v = Number(tuneStrength.value);
        tuneLabel.textContent = v.toFixed(1);
        saveTuneCfg({ strength: v });
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      tuneReset.addEventListener("click", () => {
        localStorage.removeItem(TUNE_KEY);
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      toneSelect.addEventListener("change", () => {
        saveInputs(getInputData());
        if (state.mode === "compat") renderAll();
      });

      todayLuckBtn.addEventListener("click", () => {
        if (state.mode === "compat" && state.A && state.B) {
          renderTodayCoupleBox(buildPerson(state.A), buildPerson(state.B));
        } else if (state.A) {
          todayCoupleLine.textContent = todayLuckLine(buildPerson(state.A));
          todayCoupleMeta.textContent = `오늘 오행: ${
            getTodayElementFlow().stemElem
          }/${getTodayElementFlow().branchElem}`;
        }
      });

      shareBtn.addEventListener("click", shareCard);
      pdfBtn.addEventListener("click", savePdfPretty);
      calcBtn.addEventListener("click", computePair);

      init();
    </script>
  </body>
</html>
