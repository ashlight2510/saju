<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ê¶í•© Â· ì˜¤ëŠ˜ìš´ì„¸ Â· ì‹ ë…„ìš´ì„¸</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Adsense (ìš”ì²­ ë°˜ì˜) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;600;800&family=Playfair+Display:wght@700;800&display=swap");

      :root {
        --bg1: #0b1621;
        --bg2: #101f2e;
        --bg3: #14273b;
        --card: rgba(255, 255, 255, 0.94);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.65);
        --line: rgba(15, 23, 42, 0.12);
        --accent: #2563eb;
        --accent2: #f59e0b;
        --shadow: 0 16px 40px rgba(0, 0, 0, 0.25);
        --radius: 18px;
        --font-body: "IBM Plex Sans KR", "Apple SD Gothic Neo", sans-serif;
        --font-title: "Playfair Display", "Nanum Myeongjo", serif;
      }

      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        color: rgba(255, 255, 255, 0.92);
      }
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 24px 18px 40px;
      }
      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }
      h1 {
        font-family: var(--font-title);
        font-weight: 800;
        letter-spacing: 0.02em;
      }
      .hero {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 14px;
      }
      .badge {
        font-size: 12px;
        font-weight: 800;
        letter-spacing: 0.14em;
        text-transform: uppercase;
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 18px;
        margin-bottom: 16px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: var(--shadow);
      }
      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .score {
        font-size: 28px;
        font-weight: 800;
        color: var(--accent);
      }
      .lead {
        font-size: 1.05rem;
        font-weight: 800;
        line-height: 1.5;
      }
      .mini {
        font-size: 0.85rem;
        color: var(--muted);
        font-weight: 700;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .btn {
        padding: 10px 14px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        cursor: pointer;
        background: var(--text);
        color: #fff;
      }
      .btn.outline {
        background: #fff;
        color: var(--text);
        border: 1px solid var(--text);
      }
      .btn.ghost {
        background: rgba(15, 23, 42, 0.08);
        color: var(--text);
        border: 1px solid rgba(15, 23, 42, 0.1);
      }
      select,
      input[type="range"],
      input[type="date"],
      input[type="time"] {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        font-weight: 700;
      }
      .rule-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 10px;
        background: rgba(255, 255, 255, 0.96);
      }
      .rule-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .like-btn {
        border: none;
        background: rgba(37, 99, 235, 0.12);
        color: #1e40af;
        border-radius: 10px;
        padding: 4px 8px;
        cursor: pointer;
        font-weight: 800;
      }
      .radar {
        width: 100%;
        max-width: 420px;
        margin: 12px auto 0;
        display: block;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }
      .pill-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        font-weight: 800;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        border: 1px solid rgba(15, 23, 42, 0.1);
      }
      .section-title {
        font-weight: 800;
        font-size: 1rem;
      }
      .share-note {
        margin-top: 10px;
      }
      .pdf-area {
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        padding: 14px 14px 2px;
        border-radius: 16px;
      }

      @media (max-width: 720px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }
        .card-head {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <div class="badge">Local Only</div>
        <div class="badge" id="todayBadge"></div>
      </div>

      <div class="card" id="inputCard">
        <div class="card-head">
          <div>
            <h1>ğŸ”® ê¶í•© ë¦¬í¬íŠ¸</h1>
            <p class="mini">ì¶œìƒ ì •ë³´ ì…ë ¥ â†’ ë¡œì»¬ ê³„ì‚°</p>
          </div>
          <button class="btn" id="calcBtn">ê³„ì‚°í•˜ê¸°</button>
        </div>

        <div class="grid-2" style="margin-top: 12px">
          <div class="rule-card">
            <h3>A ì •ë³´</h3>
            <div class="row">
              <input id="aDate" type="date" />
              <input id="aTime" type="time" step="60" />
            </div>
            <div class="row" style="margin-top: 8px">
              <select id="aZiMode">
                <option value="2300" selected>ìì‹œ: 23:00</option>
                <option value="2330">ì•¼ìì‹œ: 23:30</option>
              </select>
              <select id="aHiddenMode">
                <option value="on" selected>ì¥ê°„ ë°˜ì˜</option>
                <option value="off">ì¥ê°„ ë¯¸ë°˜ì˜</option>
              </select>
            </div>
          </div>

          <div class="rule-card">
            <h3>B ì •ë³´</h3>
            <div class="row">
              <input id="bDate" type="date" />
              <input id="bTime" type="time" step="60" />
            </div>
            <div class="row" style="margin-top: 8px">
              <select id="bZiMode">
                <option value="2300" selected>ìì‹œ: 23:00</option>
                <option value="2330">ì•¼ìì‹œ: 23:30</option>
              </select>
              <select id="bHiddenMode">
                <option value="on" selected>ì¥ê°„ ë°˜ì˜</option>
                <option value="off">ì¥ê°„ ë¯¸ë°˜ì˜</option>
              </select>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top: 12px">
          <span class="mini">í†¤</span>
          <select id="toneSelect">
            <option value="couple" selected>ì»¤í”Œ ëª¨ë“œ</option>
            <option value="biz">ë™ì—…ì ëª¨ë“œ</option>
          </select>
          <span class="mini">* Asia/Seoul(UTC+9) Â· 1988 DST ë°˜ì˜</span>
        </div>
      </div>

      <div id="pdfArea" class="pdf-area">
        <div class="card">
          <div class="card-head">
            <div>
              <h2>ê¶í•© ìš”ì•½</h2>
              <p class="mini" id="summarySub">Asia/Seoul ê¸°ì¤€ Â· ì ˆê¸°/ì˜¤í–‰ ê·œì¹™</p>
            </div>
            <div class="score" id="totalScore">â€”</div>
          </div>
          <p class="lead" id="summaryMain">â€”</p>
          <div class="pill-row" id="summaryPills"></div>
        </div>

        <div class="card">
          <div class="row" style="justify-content: space-between">
            <div>
              <h2>ì˜¤ëŠ˜ ìš´ì„¸ (ê¶í•© ê²°í•©)</h2>
              <p class="lead" id="todayCoupleLine">â€”</p>
              <p class="mini" id="todayCoupleMeta">â€”</p>
            </div>
            <button class="btn ghost" id="todayLuckBtn">ì˜¤ëŠ˜ ë‹¤ì‹œ ë³´ê¸°</button>
          </div>
        </div>

        <div class="grid-2">
          <div class="card">
            <h2>ì„¹ì…˜ë³„ ê· í˜•</h2>
            <svg id="sectionRadarSvg" class="radar" viewBox="0 0 320 320"></svg>
            <p class="mini" id="sectionRadarLegend">ê´€ê³„ì˜ ì „ì²´ ë°¸ëŸ°ìŠ¤</p>
          </div>

          <div class="card">
            <h2>A/B ì‚¬ì£¼ ìš”ì•½</h2>
            <div class="grid-2" style="gap: 8px">
              <div>
                <div class="section-title">A</div>
                <div id="aPillars" class="mini"></div>
              </div>
              <div>
                <div class="section-title">B</div>
                <div id="bPillars" class="mini"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>ê¶í•© í¬ì¸íŠ¸</h2>
          <div id="ruleList"></div>
        </div>

        <div class="card">
          <h2>2026 ì‹ ë…„ìš´ì„¸ (ì›”ë³„)</h2>
          <div id="monthlyList"></div>
        </div>
      </div>

      <div class="card">
        <h2>íŠœë‹ (í•™ìŠµ ëŠë‚Œ)</h2>
        <div class="row">
          <span class="mini">íŠœë‹ ê°•ë„</span>
          <input type="range" min="0" max="2" step="0.1" value="1" id="tuneStrength" />
          <span id="tuneLabel" class="mini">1.0</span>
          <button class="btn outline" id="tuneReset">ì´ˆê¸°í™”</button>
        </div>
        <p class="mini" id="tuneStatus"></p>
      </div>

      <div class="card">
        <h2>ê³µìœ  Â· PDF</h2>
        <div class="row">
          <button class="btn" id="shareBtn">ê³µìœ  ì¹´ë“œ ë§Œë“¤ê¸°</button>
          <button class="btn outline" id="pdfBtn">PDF ì €ì¥</button>
        </div>
        <p class="mini share-note" id="shareStatus"></p>
        <canvas id="shareCanvas" width="1080" height="1350" style="display: none"></canvas>
      </div>
    </div>

    <script src="./vendor/html2canvas.min.js"></script>
    <script src="./vendor/jspdf.umd.min.js"></script>

    <script>
      /* ======================================================
  0. ê¸°ë³¸ DOM
====================================================== */
      const todayBadge = document.getElementById("todayBadge");
      todayBadge.textContent = new Date().toISOString().slice(0, 10);

      const aDate = document.getElementById("aDate");
      const aTime = document.getElementById("aTime");
      const aZiMode = document.getElementById("aZiMode");
      const aHiddenMode = document.getElementById("aHiddenMode");
      const bDate = document.getElementById("bDate");
      const bTime = document.getElementById("bTime");
      const bZiMode = document.getElementById("bZiMode");
      const bHiddenMode = document.getElementById("bHiddenMode");
      const toneSelect = document.getElementById("toneSelect");
      const calcBtn = document.getElementById("calcBtn");

      const todayCoupleLine = document.getElementById("todayCoupleLine");
      const todayCoupleMeta = document.getElementById("todayCoupleMeta");
      const sectionRadarSvg = document.getElementById("sectionRadarSvg");
      const summaryMain = document.getElementById("summaryMain");
      const summarySub = document.getElementById("summarySub");
      const totalScoreEl = document.getElementById("totalScore");
      const summaryPills = document.getElementById("summaryPills");
      const ruleList = document.getElementById("ruleList");
      const monthlyList = document.getElementById("monthlyList");
      const tuneStrength = document.getElementById("tuneStrength");
      const tuneLabel = document.getElementById("tuneLabel");
      const tuneReset = document.getElementById("tuneReset");
      const tuneStatus = document.getElementById("tuneStatus");
      const todayLuckBtn = document.getElementById("todayLuckBtn");
      const shareBtn = document.getElementById("shareBtn");
      const shareStatus = document.getElementById("shareStatus");
      const pdfBtn = document.getElementById("pdfBtn");
      const aPillarsEl = document.getElementById("aPillars");
      const bPillarsEl = document.getElementById("bPillars");

      /* ======================================================
  1. ìƒíƒœ
====================================================== */
      const INPUT_KEY = "compat:inputs:v1";
      const state = {
        A: null,
        B: null,
        aResult: null,
        bResult: null,
      };

      /* ======================================================
  2. ìœ í‹¸
====================================================== */
      const STEM_ELEM = {
        ê°‘: "ëª©",
        ì„: "ëª©",
        ë³‘: "í™”",
        ì •: "í™”",
        ë¬´: "í† ",
        ê¸°: "í† ",
        ê²½: "ê¸ˆ",
        ì‹ : "ê¸ˆ",
        ì„: "ìˆ˜",
        ê³„: "ìˆ˜",
      };
      const BRANCH_ELEM = {
        ì: "ìˆ˜",
        ì¶•: "í† ",
        ì¸: "ëª©",
        ë¬˜: "ëª©",
        ì§„: "í† ",
        ì‚¬: "í™”",
        ì˜¤: "í™”",
        ë¯¸: "í† ",
        ì‹ : "ê¸ˆ",
        ìœ : "ê¸ˆ",
        ìˆ : "í† ",
        í•´: "ìˆ˜",
      };
      const GENERATE = { ëª©: "í™”", í™”: "í† ", í† : "ê¸ˆ", ê¸ˆ: "ìˆ˜", ìˆ˜: "ëª©" };
      const OVERCOME = { ëª©: "í† ", í™”: "ê¸ˆ", í† : "ìˆ˜", ê¸ˆ: "ëª©", ìˆ˜: "í™”" };
      const CLASH = { ëª©: "ê¸ˆ", ê¸ˆ: "ëª©", í™”: "ìˆ˜", ìˆ˜: "í™”", í† : null };

      const LIUHE = [
        ["ì", "ì¶•"],
        ["ì¸", "í•´"],
        ["ë¬˜", "ìˆ "],
        ["ì§„", "ìœ "],
        ["ì‚¬", "ì‹ "],
        ["ì˜¤", "ë¯¸"],
      ];
      const CHUNG = [
        ["ì", "ì˜¤"],
        ["ì¶•", "ë¯¸"],
        ["ì¸", "ì‹ "],
        ["ë¬˜", "ìœ "],
        ["ì§„", "ìˆ "],
        ["ì‚¬", "í•´"],
      ];
      const HAE = [
        ["ì", "ë¯¸"],
        ["ì¶•", "ì˜¤"],
        ["ì¸", "ì‚¬"],
        ["ë¬˜", "ì§„"],
        ["ì‹ ", "í•´"],
        ["ìœ ", "ìˆ "],
      ];
      const SAMHAP = [
        ["ì‹ ", "ì", "ì§„"],
        ["í•´", "ë¬˜", "ë¯¸"],
        ["ì¸", "ì˜¤", "ìˆ "],
        ["ì‚¬", "ìœ ", "ì¶•"],
      ];
      const SELF_PUNISH = ["ì", "ì˜¤", "ìœ ", "í•´"];

      const MONTH_FLOW = {
        1: { monthBranch: "ì¶•", seasonTop: "í† " },
        2: { monthBranch: "ì¸", seasonTop: "ëª©" },
        3: { monthBranch: "ë¬˜", seasonTop: "ëª©" },
        4: { monthBranch: "ì§„", seasonTop: "í† " },
        5: { monthBranch: "ì‚¬", seasonTop: "í™”" },
        6: { monthBranch: "ì˜¤", seasonTop: "í™”" },
        7: { monthBranch: "ë¯¸", seasonTop: "í† " },
        8: { monthBranch: "ì‹ ", seasonTop: "ê¸ˆ" },
        9: { monthBranch: "ìœ ", seasonTop: "ê¸ˆ" },
        10: { monthBranch: "ìˆ ", seasonTop: "í† " },
        11: { monthBranch: "í•´", seasonTop: "ìˆ˜" },
        12: { monthBranch: "ì", seasonTop: "ìˆ˜" },
      };

      function hasPair(a, b, table) {
        return table.some(([x, y]) => (a === x && b === y) || (a === y && b === x));
      }
      function isLiuhe(a, b) {
        return hasPair(a, b, LIUHE);
      }
      function isChung(a, b) {
        return hasPair(a, b, CHUNG);
      }
      function isHae(a, b) {
        return hasPair(a, b, HAE);
      }
      function isSamhap(a, b) {
        return SAMHAP.some((g) => g.includes(a) && g.includes(b));
      }
      function isSelfPunish(b) {
        return SELF_PUNISH.includes(b);
      }
      function isSeasonClash(seasonElem, topElem) {
        return CLASH[seasonElem] === topElem;
      }
      function relationElem(a, b) {
        if (GENERATE[a] === b) return "ìƒ";
        if (OVERCOME[a] === b) return "ê·¹";
        if (GENERATE[b] === a) return "ë°›ìŒ";
        if (OVERCOME[b] === a) return "ëˆŒë¦¼";
        if (a === b) return "ë™";
        return "ì¤‘ë¦½";
      }
      function getTopWeak(elementsRaw) {
        const entries = Object.entries(elementsRaw).sort((a, b) => b[1] - a[1]);
        return { top: entries[0][0], weak: entries[entries.length - 1][0] };
      }
      function calcBalance(elementsRaw) {
        const vals = Object.values(elementsRaw);
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        return max ? (max - min) / max : 0;
      }
      function combineElements(a, b) {
        const keys = Object.keys(a);
        const out = {};
        keys.forEach((k) => {
          out[k] = (a[k] + b[k]) / 2;
        });
        return out;
      }
      function round1(x) {
        return Math.round(x * 10) / 10;
      }
      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function hashToIndex(str, mod) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        h >>>= 0;
        return mod ? h % mod : 0;
      }
      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, (c) => ({
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
        })[c]);
      }
      function fillTokens(text, tokens) {
        return text.replace(/\{([^}]+)\}/g, (_, key) => tokens[key] ?? "");
      }

      /* ======================================================
  3. ì¼ì§„(ì˜¤ëŠ˜ ìš´ì„¸)
====================================================== */
      const STEMS = ["ê°‘", "ì„", "ë³‘", "ì •", "ë¬´", "ê¸°", "ê²½", "ì‹ ", "ì„", "ê³„"];
      const BRANCHES = ["ì", "ì¶•", "ì¸", "ë¬˜", "ì§„", "ì‚¬", "ì˜¤", "ë¯¸", "ì‹ ", "ìœ ", "ìˆ ", "í•´"];
      const GANJI_60 = (() => {
        const arr = [];
        for (let i = 0; i < 60; i++) {
          arr.push({ stem: STEMS[i % 10], branch: BRANCHES[i % 12] });
        }
        return arr;
      })();

      const BASE_GAPJA_DAY = new Date("1984-02-02T00:00:00+09:00");
      const KOREA_DST = [
        {
          start: "1988-05-08T00:00:00+09:00",
          end: "1988-10-09T23:59:59+09:00",
          offsetHours: 1,
        },
      ];

      function applyDST(dateKST) {
        const t = dateKST.getTime();
        for (const d of KOREA_DST) {
          const s = new Date(d.start).getTime();
          const e = new Date(d.end).getTime();
          if (t >= s && t <= e) {
            return new Date(t + d.offsetHours * 3600 * 1000);
          }
        }
        return dateKST;
      }

      function getTodayGanji(date = new Date()) {
        const kst = new Date(date.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
        const adj = applyDST(kst);
        const days = Math.floor((adj - BASE_GAPJA_DAY) / (24 * 3600 * 1000));
        const idx = ((days % 60) + 60) % 60;
        return { index: idx, ...GANJI_60[idx] };
      }

      function getTodayElementFlow(date = new Date()) {
        const g = getTodayGanji(date);
        return {
          ganji: g,
          stemElem: STEM_ELEM[g.stem],
          branchElem: BRANCH_ELEM[g.branch],
        };
      }

      function todayAdvantage(aPerson, bPerson, date = new Date()) {
        const flow = getTodayElementFlow(date);
        const key1 = flow.stemElem;
        const key2 = flow.branchElem;
        const scoreA = aPerson.elements[key1] * 1.0 + aPerson.elements[key2] * 0.7;
        const scoreB = bPerson.elements[key1] * 1.0 + bPerson.elements[key2] * 0.7;
        const diff = scoreA - scoreB;
        const TH = 0.35;

        let winner = "even";
        if (diff > TH) winner = "A";
        else if (diff < -TH) winner = "B";

        const line = makeTodayCoupleLine(winner, key1, key2);
        return {
          winner,
          keys: [key1, key2],
          scoreA: round1(scoreA),
          scoreB: round1(scoreB),
          line,
        };
      }

      function makeTodayCoupleLine(winner, k1, k2) {
        if (winner === "A") {
          return `ì˜¤ëŠ˜ íë¦„ì€ ${k1}/${k2} ìª½ì´ ê°•í•´ì„œ, Aê°€ ì¡°ê¸ˆ ë” ìœ ë¦¬í•´. ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” Aê°€ ë¨¼ì € êº¼ë‚´ë©´ ì¢‹ì•„.`;
        }
        if (winner === "B") {
          return `ì˜¤ëŠ˜ íë¦„ì€ ${k1}/${k2} ìª½ì´ ê°•í•´ì„œ, Bê°€ ì¡°ê¸ˆ ë” ìœ ë¦¬í•´. ì•½ì†/ê²°ì •ì€ B ì»¨ë””ì…˜ì— ë§ì¶”ë©´ ë¶€ë“œëŸ½ê²Œ ê°„ë‹¤.`;
        }
        return `ì˜¤ëŠ˜ì€ ${k1}/${k2} íë¦„ì¸ë°, A/B ë‘˜ ë‹¤ ë¹„ìŠ·í•˜ê²Œ ë°›ëŠ”ë‹¤. ë§ì¶°ê°€ëŠ” ê²Œ ì´ë“ì´ì•¼.`;
      }

      function renderTodayCoupleBox(aPerson, bPerson) {
        const t = todayAdvantage(aPerson, bPerson);
        todayCoupleLine.textContent = t.line;
        todayCoupleMeta.textContent = `A ${t.scoreA} vs B ${t.scoreB} (ì˜¤ëŠ˜ ì˜¤í–‰: ${t.keys.join("/")})`;
      }

      /* ======================================================
  4. ì‚¬ì£¼ ê³„ì‚° (ì •ë°€ ì ˆê¸° ê¸°ë°˜)
====================================================== */
      const STEMS_H = ["ê°‘", "ì„", "ë³‘", "ì •", "ë¬´", "ê¸°", "ê²½", "ì‹ ", "ì„", "ê³„"];
      const BRANCHES_H = ["ì", "ì¶•", "ì¸", "ë¬˜", "ì§„", "ì‚¬", "ì˜¤", "ë¯¸", "ì‹ ", "ìœ ", "ìˆ ", "í•´"];

      const BRANCH_MAIN_ELEM = {
        ì: "ìˆ˜",
        ì¶•: "í† ",
        ì¸: "ëª©",
        ë¬˜: "ëª©",
        ì§„: "í† ",
        ì‚¬: "í™”",
        ì˜¤: "í™”",
        ë¯¸: "í† ",
        ì‹ : "ê¸ˆ",
        ìœ : "ê¸ˆ",
        ìˆ : "í† ",
        í•´: "ìˆ˜",
      };

      const HIDDEN_STEMS = {
        ì: [["ê³„", 1.0]],
        ì¶•: [
          ["ê¸°", 0.6],
          ["ê³„", 0.2],
          ["ì‹ ", 0.2],
        ],
        ì¸: [
          ["ê°‘", 0.6],
          ["ë³‘", 0.2],
          ["ë¬´", 0.2],
        ],
        ë¬˜: [["ì„", 1.0]],
        ì§„: [
          ["ë¬´", 0.6],
          ["ì„", 0.2],
          ["ê³„", 0.2],
        ],
        ì‚¬: [
          ["ë³‘", 0.6],
          ["ê²½", 0.2],
          ["ë¬´", 0.2],
        ],
        ì˜¤: [
          ["ì •", 0.7],
          ["ê¸°", 0.3],
        ],
        ë¯¸: [
          ["ê¸°", 0.6],
          ["ì •", 0.2],
          ["ì„", 0.2],
        ],
        ì‹ : [
          ["ê²½", 0.6],
          ["ì„", 0.2],
          ["ë¬´", 0.2],
        ],
        ìœ : [["ì‹ ", 1.0]],
        ìˆ : [
          ["ë¬´", 0.6],
          ["ì‹ ", 0.2],
          ["ì •", 0.2],
        ],
        í•´: [
          ["ì„", 0.7],
          ["ê°‘", 0.3],
        ],
      };

      const MONTH_BOUNDARIES = [
        { name: "ì…ì¶˜", lon: 315, branch: "ì¸" },
        { name: "ê²½ì¹©", lon: 345, branch: "ë¬˜" },
        { name: "ì²­ëª…", lon: 15, branch: "ì§„" },
        { name: "ì…í•˜", lon: 45, branch: "ì‚¬" },
        { name: "ë§ì¢…", lon: 75, branch: "ì˜¤" },
        { name: "ì†Œì„œ", lon: 105, branch: "ë¯¸" },
        { name: "ì…ì¶”", lon: 135, branch: "ì‹ " },
        { name: "ë°±ë¡œ", lon: 165, branch: "ìœ " },
        { name: "í•œë¡œ", lon: 195, branch: "ìˆ " },
        { name: "ì…ë™", lon: 225, branch: "í•´" },
        { name: "ëŒ€ì„¤", lon: 255, branch: "ì" },
        { name: "ì†Œí•œ", lon: 285, branch: "ì¶•" },
      ];

      function sunApparentEclipticLongitudeDeg(jd) {
        const T = (jd - 2451545.0) / 36525.0;
        let L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
        L0 = normalizeDeg(L0);
        let M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
        M = normalizeDeg(M);
        const Mr = deg2rad(M);
        const C =
          (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(Mr) +
          (0.019993 - 0.000101 * T) * Math.sin(2 * Mr) +
          0.000289 * Math.sin(3 * Mr);
        let trueLon = L0 + C;
        const omega = deg2rad(125.04 - 1934.136 * T);
        let lambda = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
        return normalizeDeg(lambda);
      }

      function findSolarLongitudeTimeUTC(year, targetLonDeg) {
        const approx = approximateDateForLon(year, targetLonDeg);
        let t0 = approx.getTime() - 3 * 86400e3;
        let t1 = approx.getTime() + 3 * 86400e3;

        const f = (t) => {
          const jd = toJulianDay(new Date(t));
          const lon = sunApparentEclipticLongitudeDeg(jd);
          return shortestAngleDiffDeg(lon, targetLonDeg);
        };

        let a = t0,
          b = t1;
        let fa = f(a),
          fb = f(b);
        let tries = 0;
        while (fa * fb > 0 && tries < 12) {
          a -= 2 * 86400e3;
          b += 2 * 86400e3;
          fa = f(a);
          fb = f(b);
          tries++;
        }
        if (fa * fb > 0) {
          return new Date(approx.getTime());
        }

        for (let i = 0; i < 60; i++) {
          const m = (a + b) / 2;
          const fm = f(m);
          if (Math.abs(fm) < 1e-6) {
            a = b = m;
            break;
          }
          if (fa * fm <= 0) {
            b = m;
            fb = fm;
          } else {
            a = m;
            fa = fm;
          }
        }
        return new Date((a + b) / 2);
      }

      function approximateDateForLon(year, lon) {
        const map = {
          315: [2, 4],
          345: [3, 6],
          15: [4, 5],
          45: [5, 6],
          75: [6, 6],
          105: [7, 7],
          135: [8, 7],
          165: [9, 7],
          195: [10, 8],
          225: [11, 7],
          255: [12, 7],
          285: [1, 6],
        };
        const [mm, dd] = map[lon] || [2, 4];
        return new Date(Date.UTC(year, mm - 1, dd, 12, 0, 0));
      }

      function computeMonthBoundaryTimesUTC(year) {
        return MONTH_BOUNDARIES.map((b) => ({ ...b, timeUTC: findSolarLongitudeTimeUTC(year, b.lon) }));
      }

      function computeSajuFiveElements(birthUTCDate, { ziMode, hiddenMode }) {
        const birthKST = toKSTDateParts(birthUTCDate);
        const year = birthKST.y;
        const boundariesThisYearUTC = computeMonthBoundaryTimesUTC(year);
        const boundariesPrevYearUTC = computeMonthBoundaryTimesUTC(year - 1);

        const ipchunThisKST = toKSTMillis(boundariesThisYearUTC[0].timeUTC);
        const birthMillisKST = kstMillisFromParts(birthKST);

        const sajuYear = birthMillisKST >= ipchunThisKST ? year : year - 1;
        const bdsUTC = sajuYear === year ? boundariesThisYearUTC : boundariesPrevYearUTC;
        const bdsKST = bdsUTC.map((x) => ({ ...x, kst: toKSTMillis(x.timeUTC) }));

        let monthBranch = "ì¸";
        let monthStartName = "ì…ì¶˜";
        let monthStartKST = bdsKST[0].kst;
        for (let i = 0; i < bdsKST.length; i++) {
          const cur = bdsKST[i];
          const next = bdsKST[(i + 1) % bdsKST.length];
          const nextKST =
            i === bdsKST.length - 1
              ? toKSTMillis(computeMonthBoundaryTimesUTC(sajuYear + 1)[0].timeUTC)
              : next.kst;

          if (birthMillisKST >= cur.kst && birthMillisKST < nextKST) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartKST = cur.kst;
            break;
          }
          if (i === bdsKST.length - 1 && birthMillisKST >= cur.kst) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartKST = cur.kst;
          }
          if (i === bdsKST.length - 1 && birthMillisKST < bdsKST[0].kst) {
            monthBranch = "ì¶•";
            monthStartName = "ì†Œí•œ";
            monthStartKST = cur.kst;
          }
        }

        const yearPillar = ganzhiYear(sajuYear);
        const monthPillar = ganzhiMonth(yearPillar.stem, monthBranch);
        const adjustedForDay = adjustForZiDayBoundary(birthKST, ziMode);
        const dayPillar = ganzhiDayFromGregorian(adjustedForDay.y, adjustedForDay.m, adjustedForDay.d);
        const hourBranch = getHourBranch(birthKST.hh, birthKST.mm, ziMode);
        const hourPillar = ganzhiHour(dayPillar.stem, hourBranch);

        const elements = tallyElements({ yearPillar, monthPillar, dayPillar, hourPillar }, { hiddenMode });

        return {
          input: {
            kst: `${pad2(birthKST.y)}-${pad2(birthKST.m)}-${pad2(birthKST.d)} ${pad2(birthKST.hh)}:${pad2(
              birthKST.mm
            )}`,
            ziMode,
            hiddenMode,
            sajuYear,
            monthStartName,
          },
          pillars: {
            year: yearPillar,
            month: monthPillar,
            day: dayPillar,
            hour: hourPillar,
            monthMeta: {
              start: new Date(monthStartKST).toISOString(),
              startName: monthStartName,
            },
          },
          elements,
        };
      }

      function ganzhiYear(year) {
        const baseYear = 1984;
        const idx = mod(year - baseYear, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiMonth(yearStem, monthBranch) {
        const startStemByYearStem = {
          ê°‘: "ë³‘",
          ê¸°: "ë³‘",
          ì„: "ë¬´",
          ê²½: "ë¬´",
          ë³‘: "ê²½",
          ì‹ : "ê²½",
          ì •: "ì„",
          ì„: "ì„",
          ë¬´: "ê°‘",
          ê³„: "ê°‘",
        };
        const startStem = startStemByYearStem[yearStem] || "ë³‘";
        const order = ["ì¸", "ë¬˜", "ì§„", "ì‚¬", "ì˜¤", "ë¯¸", "ì‹ ", "ìœ ", "ìˆ ", "í•´", "ì", "ì¶•"];
        const mIdx = order.indexOf(monthBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + mIdx) % 10;
        return { stem: STEMS_H[stemIdx], branch: monthBranch, text: `${STEMS_H[stemIdx]}${monthBranch}` };
      }

      function ganzhiDayFromGregorian(y, m, d) {
        const jd = toJulianDayFromGregorian(y, m, d, 12, 0, 0);
        const jdJiaZi = toJulianDayFromGregorian(1984, 2, 2, 12, 0, 0);
        const idx = mod(Math.round(jd - jdJiaZi), 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiHour(dayStem, hourBranch) {
        const startStemByDayStem = {
          ê°‘: "ê°‘",
          ê¸°: "ê°‘",
          ì„: "ë³‘",
          ê²½: "ë³‘",
          ë³‘: "ë¬´",
          ì‹ : "ë¬´",
          ì •: "ê²½",
          ì„: "ê²½",
          ë¬´: "ì„",
          ê³„: "ì„",
        };
        const startStem = startStemByDayStem[dayStem] || "ê°‘";
        const order = ["ì", "ì¶•", "ì¸", "ë¬˜", "ì§„", "ì‚¬", "ì˜¤", "ë¯¸", "ì‹ ", "ìœ ", "ìˆ ", "í•´"];
        const hIdx = order.indexOf(hourBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + hIdx) % 10;
        return { stem: STEMS_H[stemIdx], branch: hourBranch, text: `${STEMS_H[stemIdx]}${hourBranch}` };
      }

      function ganzhiFromIndex(idx) {
        const stem = STEMS_H[idx % 10];
        const branch = BRANCHES_H[idx % 12];
        return { stem, branch, text: `${stem}${branch}` };
      }

      function getHourBranch(hh, mm, ziMode) {
        const minutes = hh * 60 + mm;
        const ziStart = ziMode === "2330" ? 23 * 60 + 30 : 23 * 60;
        if (minutes >= ziStart || minutes < (ziMode === "2330" ? 90 : 60)) {
          return "ì";
        }
        const base = ziMode === "2330" ? 90 : 60;
        const order = ["ì¶•", "ì¸", "ë¬˜", "ì§„", "ì‚¬", "ì˜¤", "ë¯¸", "ì‹ ", "ìœ ", "ìˆ ", "í•´"];
        const delta = minutes - base;
        const idx = Math.floor(delta / 120);
        return order[Math.max(0, Math.min(order.length - 1, idx))] || "ì¶•";
      }

      function adjustForZiDayBoundary(kstParts, ziMode) {
        if (ziMode !== "2330") return kstParts;
        const minutes = kstParts.hh * 60 + kstParts.mm;
        if (minutes < 23 * 60 + 30) return kstParts;
        const dt = new Date(Date.UTC(kstParts.y, kstParts.m - 1, kstParts.d, 12, 0, 0));
        dt.setUTCDate(dt.getUTCDate() + 1);
        return {
          y: dt.getUTCFullYear(),
          m: dt.getUTCMonth() + 1,
          d: dt.getUTCDate(),
          hh: kstParts.hh,
          mm: kstParts.mm,
        };
      }

      function tallyElements(pillars, { hiddenMode }) {
        const base = { ëª©: 0, í™”: 0, í† : 0, ê¸ˆ: 0, ìˆ˜: 0 };
        function addElem(elem, w = 1) {
          base[elem] = (base[elem] || 0) + w;
        }
        const list = [pillars.yearPillar, pillars.monthPillar, pillars.dayPillar, pillars.hourPillar];
        list.forEach((p) => addElem(STEM_ELEM[p.stem], 1));
        list.forEach((p) => addElem(BRANCH_MAIN_ELEM[p.branch], 1));
        if (hiddenMode === "on") {
          list.forEach((p) => {
            const arr = HIDDEN_STEMS[p.branch] || [];
            arr.forEach(([hs, w]) => addElem(STEM_ELEM[hs], w));
          });
        }
        const sorted = Object.entries(base).sort((a, b) => b[1] - a[1]);
        return { raw: base, sorted };
      }

      function parseKSTDateTime(dateStr, timeStr) {
        const [y, m, d] = dateStr.split("-").map(Number);
        const [hh, mm] = timeStr.split(":").map(Number);
        const offsetMin = kstOffsetMinutesForLocal(y, m, d, hh, mm);
        const utcMillis = Date.UTC(y, m - 1, d, hh, mm, 0) - offsetMin * 60 * 1000;
        return new Date(utcMillis);
      }

      function kstOffsetMinutesForLocal(y, m, d, hh, mm) {
        let offset = 540;
        if (y === 1988) {
          const t = Date.UTC(y, m - 1, d, hh, mm, 0);
          const start = Date.UTC(1988, 4, 8, 2, 0, 0);
          const end = Date.UTC(1988, 9, 9, 3, 0, 0);
          if (t >= start && t < end) {
            offset = 600;
          }
        }
        return offset;
      }

      function toKSTDateParts(utcDate) {
        let ms = utcDate.getTime() + 540 * 60 * 1000;
        let d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth() + 1;
        const dd = d.getUTCDate();
        const hh = d.getUTCHours();
        const mm = d.getUTCMinutes();

        const off = kstOffsetMinutesForLocal(y, m, dd, hh, mm);
        ms = utcDate.getTime() + off * 60 * 1000;
        d = new Date(ms);

        return {
          y: d.getUTCFullYear(),
          m: d.getUTCMonth() + 1,
          d: d.getUTCDate(),
          hh: d.getUTCHours(),
          mm: d.getUTCMinutes(),
        };
      }

      function toKSTMillis(utcDate) {
        const parts = toKSTDateParts(utcDate);
        return Date.UTC(parts.y, parts.m - 1, parts.d, parts.hh, parts.mm, 0);
      }

      function kstMillisFromParts(p) {
        return Date.UTC(p.y, p.m - 1, p.d, p.hh, p.mm, 0);
      }

      function toJulianDay(dateUTC) {
        const y = dateUTC.getUTCFullYear();
        const m = dateUTC.getUTCMonth() + 1;
        const d = dateUTC.getUTCDate();
        const hh = dateUTC.getUTCHours();
        const mm = dateUTC.getUTCMinutes();
        const ss = dateUTC.getUTCSeconds();
        return toJulianDayFromGregorian(y, m, d, hh, mm, ss);
      }

      function toJulianDayFromGregorian(y, m, d, hh, mm, ss) {
        let Y = y,
          M = m;
        if (M <= 2) {
          Y -= 1;
          M += 12;
        }
        const A = Math.floor(Y / 100);
        const B = 2 - A + Math.floor(A / 4);
        const dayFrac = (hh + (mm + ss / 60) / 60) / 24;
        const JD =
          Math.floor(365.25 * (Y + 4716)) + Math.floor(30.6001 * (M + 1)) + d + dayFrac + B - 1524.5;
        return JD;
      }

      function normalizeDeg(x) {
        x = x % 360;
        if (x < 0) x += 360;
        return x;
      }
      function deg2rad(d) {
        return (d * Math.PI) / 180;
      }
      function shortestAngleDiffDeg(a, b) {
        let d = normalizeDeg(a) - normalizeDeg(b);
        d = ((d + 540) % 360) - 180;
        return d;
      }
      function mod(a, b) {
        return ((a % b) + b) % b;
      }
      function pad2(n) {
        return String(n).padStart(2, "0");
      }

      /* ======================================================
  5. ë£° + íŠœë‹ + ìš”ì•½ (50ê°œ)
====================================================== */
      const SECTION_WEIGHT = { ì„±í–¥: 0.25, ê´€ê³„: 0.25, ëˆ: 0.15, ì¼: 0.2, ê±´ê°•: 0.15 };

      const RULES = [
        {
          id: "ELEM_TOP_SAME",
          section: "ì„±í–¥",
          priority: 88,
          when: (a, b) => a.topElem === b.topElem && a.topScore >= 1.2 && b.topScore >= 1.2,
          evidence: "ë‘˜ ë‹¤ {topElem} ê¸°ìš´ì´ ê°€ì¥ ê°•í•´ ê¸°ì¤€ê³¼ ì†ë„ê°€ ë¹„ìŠ·í•´.",
          copies: ["ê¸°ë³¸ ê²°ì´ ì˜ ë§ì•„. ê°™ì´ ì›€ì§ì´ë©´ ë¹ ë¥´ë‹¤.", "ë‘˜ ë‹¤ ëª°ì…í•  ë• ë¸Œë ˆì´í¬ë§Œ ë§ì¶”ë©´ ì™„ë²½í•´."],
        },
        {
          id: "ELEM_TOP_COMPLEMENT",
          section: "ê´€ê³„",
          priority: 82,
          when: (a, b) => GENERATE[a.topElem] === b.topElem || GENERATE[b.topElem] === a.topElem,
          evidence: "ìƒìƒ ê´€ê³„ì˜ ê°•ì ì´ ì„œë¡œ ë§ë¬¼ë ¤ ìˆì–´.",
          copies: ["ì„œë¡œ ì—†ëŠ” ê±¸ ì±„ì›Œì£¼ëŠ” êµ¬ì¡°ë¼ ì˜¤ë˜ ê°€ê¸° ì¢‹ì•„.", "ì—­í•  ë¶„ë‹´ë§Œ ì˜ ë˜ë©´ ì‹œë„ˆì§€ê°€ í¬ê²Œ ë‚œë‹¤."],
        },
        {
          id: "ELEM_TOP_CLASH",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => OVERCOME[a.topElem] === b.topElem || OVERCOME[b.topElem] === a.topElem,
          evidence: "ì„œë¡œì˜ ê°•ì ì´ ë¶€ë”ªíˆëŠ” ìƒê·¹ ì¡°í•©ì´ì•¼.",
          copies: ["ì§„ì§œ ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” íƒ€ì´ë° ë§ì¶”ëŠ” ê²Œ í•µì‹¬.", "ê°ì • ì˜¬ë¼ì˜¬ ë• í•œ ë°•ì ì‰¬ì."],
        },
        {
          id: "ELEM_WEAK_SAME",
          section: "ê±´ê°•",
          priority: 60,
          when: (a, b) => a.weakElem === b.weakElem && a.weakScore <= 0.7 && b.weakScore <= 0.7,
          evidence: "ë‘˜ ë‹¤ {weakElem} ê¸°ìš´ì´ ë‚®ì•„ ê°™ì€ ë¶€ë¶„ì—ì„œ í”ë“¤ë¦¬ê¸° ì‰¬ì›Œ.",
          copies: ["ì•½ì ì´ ê°™ì•„ì„œ ì´í•´ëŠ” ì˜ ëœë‹¤.", "ì´ ë¶€ë¶„ë§Œ ì•½ì†ìœ¼ë¡œ ê´€ë¦¬í•˜ë©´ ì¶©ë¶„íˆ ì»¤ë²„ë¼."],
        },
        {
          id: "BALANCE_SIMILAR",
          section: "ì„±í–¥",
          priority: 78,
          when: (a, b) => Math.abs(a.balance - b.balance) <= 0.15,
          evidence: "ì˜¤í–‰ ë¶„í¬ ê· í˜•ë„ê°€ ê±°ì˜ ë¹„ìŠ·í•´.",
          copies: ["ì¼ìƒ ë¦¬ë“¬ì´ ë¹„ìŠ·í•´ì„œ í¸í•œ ì¡°í•©.", "ê°™ì´ ìˆì–´ë„ í”¼ë¡œë„ê°€ ì ë‹¤."],
        },
        {
          id: "BALANCE_DIFF",
          section: "ì„±í–¥",
          priority: 60,
          when: (a, b) => Math.abs(a.balance - b.balance) >= 0.45,
          evidence: "í•œìª½ì€ ì¹˜ìš°ì¹˜ê³  í•œìª½ì€ ì•ˆì •í˜•ì´ì•¼.",
          copies: ["ë°©ì‹ì€ ë‹¤ë¥¸ë° ëª©ì ì€ ê°™ë‹¤.", "ì„¤ëª…ë§Œ ì¡°ê¸ˆ ë” í•˜ë©´ ì˜¤íˆë ¤ ì¥ì ì´ ëœë‹¤."],
        },
        {
          id: "A_DOMINANT",
          section: "ê´€ê³„",
          priority: 64,
          when: (a, b) => a.balance - b.balance >= 0.25,
          evidence: "Aì˜ ê¸°ìš´ì´ ì „ë°˜ì ìœ¼ë¡œ ë” ê°•í•´.",
          copies: ["Aê°€ ë°©í–¥ ì¡ê³  Bê°€ ë³´ì™„í•˜ëŠ” êµ¬ì¡°.", "ì£¼ë„ê¶Œë§Œ ì¡°ì‹¬í•˜ë©´ ì•ˆì •ì ì´ì•¼."],
        },
        {
          id: "B_DOMINANT",
          section: "ê´€ê³„",
          priority: 64,
          when: (a, b) => b.balance - a.balance >= 0.25,
          evidence: "Bì˜ ê¸°ìš´ì´ ì „ë°˜ì ìœ¼ë¡œ ë” ê°•í•´.",
          copies: ["Bê°€ ë°©í–¥ ì¡ê³  Aê°€ ë³´ì™„í•˜ëŠ” êµ¬ì¡°.", "ì£¼ë„ê¶Œë§Œ ì¡°ì‹¬í•˜ë©´ ì•ˆì •ì ì´ì•¼."],
        },
        {
          id: "SEASON_SUPPORT",
          section: "ê´€ê³„",
          priority: 80,
          when: (a, b) => a.seasonTopElem === b.topElem || b.seasonTopElem === a.topElem,
          evidence: "í•œìª½ ê³„ì ˆ íë¦„ì´ ìƒëŒ€ ê°•ì ì„ ë°€ì–´ì£¼ëŠ” êµ¬ì¡°ì•¼.",
          copies: ["ìš”ì¦˜ íŠ¹íˆ ì˜ ë§ëŠ” ê¶í•©.", "ê°™ì´ ìˆì„ìˆ˜ë¡ íë¦„ì„ íƒ„ë‹¤."],
        },
        {
          id: "SEASON_CLASH",
          section: "ê´€ê³„",
          priority: 58,
          when: (a, b) => isSeasonClash(a.seasonTopElem, b.topElem) || isSeasonClash(b.seasonTopElem, a.topElem),
          evidence: "ê³„ì ˆ íë¦„ê³¼ ìƒëŒ€ ê°•ì ì´ ìƒê·¹ìœ¼ë¡œ ë¶€ë”ªí˜€.",
          copies: ["ìš”ì¦˜ ìœ ë… ì•ˆ ë§ëŠ” ëŠë‚Œì´ ë‚  ìˆ˜ ìˆì–´.", "ì‹œê¸° ì§€ë‚˜ë©´ ì™„í™”ëœë‹¤."],
        },
        {
          id: "BOTH_STRONG_MOK",
          section: "ì„±í–¥",
          priority: 76,
          when: (a, b) => a.elements["ëª©"] >= 1.4 && b.elements["ëª©"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ëª© ê¸°ìš´ì´ ê°•í•´ì„œ ì„±ì¥/ì‹œë„ê°€ ë¹ ë¥¸ í¸ì´ì•¼.",
          copies: ["ì‹œì‘ì€ ë¹ ë¥´ë‹¤. ë§ˆë¬´ë¦¬ ì²´í¬ë§Œ í•˜ì.", "ê³„íšì„ 1ê°œë¡œ ì¤„ì´ë©´ í›¨ì”¬ ê°•í•´."],
        },
        {
          id: "BOTH_STRONG_HWA",
          section: "ì¼",
          priority: 76,
          when: (a, b) => a.elements["í™”"] >= 1.4 && b.elements["í™”"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ í™” ê¸°ìš´ì´ ê°•í•´ì„œ ì¶”ì§„ë ¥ì´ ì¢‹ë‹¤.",
          copies: ["ì†ë„ëŠ” ìµœê³ . ê³¼ì—´ë§Œ ì¡°ì‹¬í•˜ë©´ ëœë‹¤.", "í”¼ë“œë°± íƒ€ì´ë°ë§Œ ë§ì¶”ì."],
        },
        {
          id: "BOTH_STRONG_TO",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => a.elements["í† "] >= 1.4 && b.elements["í† "] >= 1.4,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ê°•í•´ ì•ˆì •ê°ì´ ìˆë‹¤.",
          copies: ["ê¸°ì´ˆë¥¼ ë‹¨ë‹¨íˆ ë§Œë“¤ë©´ ì˜¤ë˜ ê°„ë‹¤.", "ì¥ê¸° ê³„íšì— ê°•í•œ ì¡°í•©."],
        },
        {
          id: "BOTH_STRONG_GEUM",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => a.elements["ê¸ˆ"] >= 1.4 && b.elements["ê¸ˆ"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ê°•í•´ì„œ ê´€ë¦¬ ê°ê°ì´ ì¢‹ë‹¤.",
          copies: ["ì§€ì¶œ í†µì œê°€ ì˜ ë˜ëŠ” ì¡°í•©.", "ëˆ ì–˜ê¸°ë§Œ ê·œì¹™ìœ¼ë¡œ ì •í•˜ë©´ í¸í•´."],
        },
        {
          id: "BOTH_STRONG_SU",
          section: "ê±´ê°•",
          priority: 74,
          when: (a, b) => a.elements["ìˆ˜"] >= 1.4 && b.elements["ìˆ˜"] >= 1.4,
          evidence: "ë‘˜ ë‹¤ ìˆ˜ ê¸°ìš´ì´ ê°•í•´ íšŒë³µ íƒ„ë ¥ì´ ì¢‹ë‹¤.",
          copies: ["ì‰¬ëŠ” íƒ€ì´ë°ë§Œ ë§ì¶”ë©´ ìµœê°•.", "ìˆ˜ë©´ë§Œ ì§€ì¼œë„ í¬ê²Œ ì´ë“."],
        },
        {
          id: "BOTH_WEAK_MOK",
          section: "ì„±í–¥",
          priority: 60,
          when: (a, b) => a.elements["ëª©"] <= 0.7 && b.elements["ëª©"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ëª© ê¸°ìš´ì´ ì•½í•´ì„œ ì‹œì‘ì´ ëŠë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì‹œì‘ë§Œ ì˜ ì¡ìœ¼ë©´ ì•ˆì •ì ì´ë‹¤.", "ì²˜ìŒ 1ì£¼ì¼ë§Œ ë°€ì–´ì£¼ì."],
        },
        {
          id: "BOTH_WEAK_HWA",
          section: "ì¼",
          priority: 60,
          when: (a, b) => a.elements["í™”"] <= 0.7 && b.elements["í™”"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ í™” ê¸°ìš´ì´ ì•½í•´ ì¶”ì§„ë ¥ì´ ë–¨ì–´ì§ˆ ìˆ˜ ìˆì–´.",
          copies: ["ì‹¤í–‰ ì†ë„ë§Œ ì˜ì‹ì ìœ¼ë¡œ ì˜¬ë¦¬ì.", "ì¼ë‹¨ ì‹œì‘í•˜ë©´ íë¦„ì´ ë¶™ëŠ”ë‹¤."],
        },
        {
          id: "BOTH_WEAK_TO",
          section: "ê±´ê°•",
          priority: 60,
          when: (a, b) => a.elements["í† "] <= 0.7 && b.elements["í† "] <= 0.7,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ì•½í•´ ë¦¬ë“¬ì´ í”ë“¤ë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ë£¨í‹´ì´ ë‹µì´ë‹¤.", "ì‹ì‚¬/ìˆ˜ë©´ë§Œ ê³ ì •í•˜ë©´ ì•ˆì •ëœë‹¤."],
        },
        {
          id: "BOTH_WEAK_GEUM",
          section: "ëˆ",
          priority: 58,
          when: (a, b) => a.elements["ê¸ˆ"] <= 0.7 && b.elements["ê¸ˆ"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ì•½í•´ ê´€ë¦¬ê°€ ëŠìŠ¨í•´ì§ˆ ìˆ˜ ìˆì–´.",
          copies: ["ì§€ì¶œ ê·œì¹™ë§Œ ì„¸ìš°ì.", "í°ëˆì€ ê³µë™ ê²°ì •ìœ¼ë¡œ."],
        },
        {
          id: "BOTH_WEAK_SU",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => a.elements["ìˆ˜"] <= 0.7 && b.elements["ìˆ˜"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ìˆ˜ ê¸°ìš´ì´ ì•½í•´ íšŒë³µì´ ëŠë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì‰¬ëŠ” ë‚ ì„ ì˜ˆì•½í•˜ì.", "ìˆ˜ë©´ê³¼ ë¬¼ ì„­ì·¨ê°€ í•µì‹¬."],
        },
        {
          id: "A_STRONG_MOK",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => a.elements["ëª©"] >= 1.5 && b.elements["ëª©"] <= 0.8,
          evidence: "Aì˜ ëª© ê¸°ìš´ì´ ê°•í•´ ë°©í–¥ì„ ì œì‹œí•˜ëŠ” ìª½ì´ì•¼.",
          copies: ["Aê°€ ì‹œì‘í•˜ë©´ Bê°€ ì•ˆì •ì ìœ¼ë¡œ ë”°ë¼ê°„ë‹¤.", "ì—­í• ë§Œ ëª…í™•íˆ í•˜ë©´ ì¢‹ì•„."],
        },
        {
          id: "A_STRONG_HWA",
          section: "ì¼",
          priority: 62,
          when: (a, b) => a.elements["í™”"] >= 1.5 && b.elements["í™”"] <= 0.8,
          evidence: "Aì˜ ì¶”ì§„ë ¥ì´ ë” ê°•í•´.",
          copies: ["ì†ë„ ì°¨ì´ë§Œ ì¡°ì ˆí•˜ë©´ ëœë‹¤.", "Aê°€ ë¨¼ì € ì¹˜ê³  Bê°€ ì •ë¦¬."],
        },
        {
          id: "A_STRONG_TO",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => a.elements["í† "] >= 1.5 && b.elements["í† "] <= 0.8,
          evidence: "Aê°€ ì•ˆì •ê³¼ ê´€ë¦¬ ìª½ì„ ì¡ì•„ì£¼ê¸° ì¢‹ì•„.",
          copies: ["ê³„íšì€ Aê°€ ì„¸ìš°ê³  Bê°€ ì‹¤í–‰í•˜ë©´ ì•ˆì •ì .", "ì¥ê¸° ê³„íšì— ê°•í•´."],
        },
        {
          id: "A_STRONG_GEUM",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => a.elements["ê¸ˆ"] >= 1.5 && b.elements["ê¸ˆ"] <= 0.8,
          evidence: "Aê°€ ëˆ ê´€ë¦¬ ê°ê°ì´ ë” ëšœë ·í•´.",
          copies: ["ì¬ì • ê´€ë¦¬ ì—­í•  ë¶„ë‹´ì´ í•„ìš”í•´.", "í°ëˆì€ Aê°€ ì²´í¬í•˜ë©´ ì•ˆì „."],
        },
        {
          id: "A_STRONG_SU",
          section: "ê±´ê°•",
          priority: 62,
          when: (a, b) => a.elements["ìˆ˜"] >= 1.5 && b.elements["ìˆ˜"] <= 0.8,
          evidence: "Aê°€ íšŒë³µ/ì •ì„œ ìª½ì„ ì˜ ë°›ì³ì¤˜.",
          copies: ["Aì˜ ë¦¬ë“¬ì„ ì°¸ê³ í•˜ë©´ ì»¨ë””ì…˜ì´ ì¢‹ì•„ì ¸.", "íœ´ì‹ ì•½ì†ì„ ë§Œë“¤ì."],
        },
        {
          id: "B_STRONG_MOK",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => b.elements["ëª©"] >= 1.5 && a.elements["ëª©"] <= 0.8,
          evidence: "Bì˜ ëª© ê¸°ìš´ì´ ê°•í•´ ë°©í–¥ì„ ì œì‹œí•˜ëŠ” ìª½ì´ì•¼.",
          copies: ["Bê°€ ì‹œì‘í•˜ë©´ Aê°€ ì•ˆì •ì ìœ¼ë¡œ ë”°ë¼ê°„ë‹¤.", "ì—­í• ë§Œ ëª…í™•íˆ í•˜ë©´ ì¢‹ì•„."],
        },
        {
          id: "B_STRONG_HWA",
          section: "ì¼",
          priority: 62,
          when: (a, b) => b.elements["í™”"] >= 1.5 && a.elements["í™”"] <= 0.8,
          evidence: "Bì˜ ì¶”ì§„ë ¥ì´ ë” ê°•í•´.",
          copies: ["ì†ë„ ì°¨ì´ë§Œ ì¡°ì ˆí•˜ë©´ ëœë‹¤.", "Bê°€ ë¨¼ì € ì¹˜ê³  Aê°€ ì •ë¦¬."],
        },
        {
          id: "B_STRONG_TO",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => b.elements["í† "] >= 1.5 && a.elements["í† "] <= 0.8,
          evidence: "Bê°€ ì•ˆì •ê³¼ ê´€ë¦¬ ìª½ì„ ì¡ì•„ì£¼ê¸° ì¢‹ì•„.",
          copies: ["ê³„íšì€ Bê°€ ì„¸ìš°ê³  Aê°€ ì‹¤í–‰í•˜ë©´ ì•ˆì •ì .", "ì¥ê¸° ê³„íšì— ê°•í•´."],
        },
        {
          id: "B_STRONG_GEUM",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => b.elements["ê¸ˆ"] >= 1.5 && a.elements["ê¸ˆ"] <= 0.8,
          evidence: "Bê°€ ëˆ ê´€ë¦¬ ê°ê°ì´ ë” ëšœë ·í•´.",
          copies: ["ì¬ì • ê´€ë¦¬ ì—­í•  ë¶„ë‹´ì´ í•„ìš”í•´.", "í°ëˆì€ Bê°€ ì²´í¬í•˜ë©´ ì•ˆì „."],
        },
        {
          id: "B_STRONG_SU",
          section: "ê±´ê°•",
          priority: 62,
          when: (a, b) => b.elements["ìˆ˜"] >= 1.5 && a.elements["ìˆ˜"] <= 0.8,
          evidence: "Bê°€ íšŒë³µ/ì •ì„œ ìª½ì„ ì˜ ë°›ì³ì¤˜.",
          copies: ["Bì˜ ë¦¬ë“¬ì„ ì°¸ê³ í•˜ë©´ ì»¨ë””ì…˜ì´ ì¢‹ì•„ì ¸.", "íœ´ì‹ ì•½ì†ì„ ë§Œë“¤ì."],
        },
        {
          id: "BRANCH_LIUHE",
          section: "ê´€ê³„",
          priority: 90,
          when: (a, b) => isLiuhe(a.dayBranch, b.dayBranch),
          evidence: "ì¼ì§€ ê¸°ì¤€ ìœ¡í•©ì´ ì„±ë¦½ë¼ ê¸°ë³¸ í˜¸í¡ì´ í¸í•´.",
          copies: ["ê°™ì´ ìˆìœ¼ë©´ ì´ìœ  ì—†ì´ í¸í•˜ë‹¤.", "ìƒí™œ ê¶í•©ì´ ì¢‹ì€ íƒ€ì…."],
        },
        {
          id: "BRANCH_SAMHAP",
          section: "ì¼",
          priority: 80,
          when: (a, b) => isSamhap(a.dayBranch, b.dayBranch),
          evidence: "ì‚¼í•© êµ¬ì¡°ë¼ ëª©í‘œë¥¼ í–¥í•´ í˜ì´ ëª¨ì—¬.",
          copies: ["ê°™ì€ ëª©í‘œë§Œ ìˆìœ¼ë©´ í­ë°œë ¥ì´ ì¢‹ë‹¤.", "í”„ë¡œì íŠ¸ ê¶í•©ì´ ìµœê³ ì•¼."],
        },
        {
          id: "BRANCH_CHUNG",
          section: "ê´€ê³„",
          priority: 62,
          when: (a, b) => isChung(a.dayBranch, b.dayBranch),
          evidence: "ì§€ì§€ ì¶©ìœ¼ë¡œ íƒ€ì´ë°ì´ ìì£¼ ì—‡ê°ˆë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ë§ëŠ” ë§ë„ íƒ€ì´ë°ì´ ì–´ê¸‹ë‚˜ë©´ ì‹¸ì›€ì´ ëœë‹¤.", "ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” ì»¨ë””ì…˜ ì¢‹ì„ ë•Œ."],
        },
        {
          id: "BRANCH_HAE",
          section: "ì„±í–¥",
          priority: 58,
          when: (a, b) => isHae(a.dayBranch, b.dayBranch),
          evidence: "í•´ ê´€ê³„ê°€ ìˆì–´ ì˜¤í•´ê°€ ìŒ“ì¼ ìˆ˜ ìˆì–´.",
          copies: ["ì‘ì€ ë§ì´ í¬ê²Œ ë“¤ë¦´ ìˆ˜ ìˆë‹¤.", "ì‚¬ì‹¤ í™•ì¸ ë¨¼ì € í•˜ë©´ ê´œì°®ì•„."],
        },
        {
          id: "BRANCH_SELF_PUNISH",
          section: "ê±´ê°•",
          priority: 55,
          when: (a, b) => a.dayBranch === b.dayBranch && isSelfPunish(a.dayBranch),
          evidence: "ê°™ì€ ì§€ì§€ë¼ ê°ì •ì„ ì•ˆìœ¼ë¡œ ìŒ“ê¸° ì‰¬ìš´ êµ¬ì¡°ì•¼.",
          copies: ["ì°¸ëŠ” ê²Œ ë¬¸ì œ í¬ì¸íŠ¸.", "ê¸°ë¶„ì€ ê·¸ë‚ ê·¸ë‚  í‘¸ëŠ” ê²Œ ë‹µ."],
        },
        {
          id: "BRANCH_SAME",
          section: "ê´€ê³„",
          priority: 70,
          when: (a, b) => a.dayBranch === b.dayBranch,
          evidence: "ì¼ì§€ê°€ ê°™ì•„ì„œ ê°ì • ì½”ë“œê°€ ë¹„ìŠ·í•´.",
          copies: ["ê°™ì´ ìˆìœ¼ë©´ ë§ì´ ì¤„ì–´ë„ í†µí•œë‹¤.", "ë‹¨, ê³ ì§‘ì´ ë¶€ë”ªíˆë©´ ë©ˆì¶”ì."],
        },
        {
          id: "BRANCH_ELEM_SAME",
          section: "ì„±í–¥",
          priority: 66,
          when: (a, b) => BRANCH_ELEM[a.dayBranch] === BRANCH_ELEM[b.dayBranch],
          evidence: "ì¼ì§€ ì˜¤í–‰ì´ ê°™ì•„ ê°ì • í‘œí˜„ ë°©ì‹ì´ ìœ ì‚¬í•´.",
          copies: ["ë§ì´ ì˜ í†µí•˜ëŠ” ì¡°í•©.", "í‘œí˜„ ë°©ì‹ì´ ë¹„ìŠ·í•´ ì˜¤í•´ê°€ ì ë‹¤."],
        },
        {
          id: "BRANCH_ELEM_CLASH",
          section: "ê´€ê³„",
          priority: 60,
          when: (a, b) => OVERCOME[BRANCH_ELEM[a.dayBranch]] === BRANCH_ELEM[b.dayBranch],
          evidence: "ì¼ì§€ ì˜¤í–‰ì´ ìƒê·¹ì´ë¼ ê¸°ë¶„ì´ ë¶€ë”ªí ìˆ˜ ìˆì–´.",
          copies: ["ê°ì • ì˜¬ë¼ì˜¤ë©´ í•œ ë°•ì ì‰¬ì.", "ì¤‘ìš”í•œ ì–˜ê¸°ëŠ” ì»¨ë””ì…˜ ì¢‹ì€ ë‚ ."],
        },
        {
          id: "MONEY_STYLE_MATCH",
          section: "ëˆ",
          priority: 74,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) <= 0.4,
          evidence: "ëˆ ì“°ëŠ” ê¸°ì¤€ì´ ë¹„ìŠ·í•´ì„œ ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì ì–´.",
          copies: ["ê³µë™ ì§€ì¶œ ê¸°ì¤€ë§Œ ì •í•˜ë©´ ëœë‹¤.", "ê¸ˆì „ ê°ˆë“±ì´ ì ì€ ì¡°í•©."],
        },
        {
          id: "MONEY_STYLE_DIFF",
          section: "ëˆ",
          priority: 62,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) >= 1.0,
          evidence: "ëˆ ì“°ëŠ” ê¸°ì¤€ì´ ê½¤ ë‹¤ë¥¼ ìˆ˜ ìˆì–´.",
          copies: ["ê·œì¹™ë§Œ ì •í•˜ë©´ ë¬¸ì œ ì—†ë‹¤.", "í°ëˆì€ í•¨ê»˜, ì‘ì€ ê±´ ê°ì."],
        },
        {
          id: "MONEY_SAVING_GOOD",
          section: "ëˆ",
          priority: 76,
          when: (a, b) => a.elements["í† "] >= 1.2 && b.elements["í† "] >= 1.2,
          evidence: "ë‘˜ ë‹¤ í† ê°€ ë°›ì³ì„œ ì•ˆì •í˜• ì €ì¶•ì— ê°•í•´.",
          copies: ["ì¥ê¸° ê³„íš ì„¸ìš°ê¸° ì¢‹ë‹¤.", "ì ê¸ˆ/ë¹„ìƒê¸ˆ ê´€ë¦¬ì— ê°•í•œ ì¡°í•©."],
        },
        {
          id: "MONEY_LEAK_RISK",
          section: "ëˆ",
          priority: 58,
          when: (a, b) => a.elements["ê¸ˆ"] <= 0.7 && b.elements["ê¸ˆ"] <= 0.7,
          evidence: "ë‘˜ ë‹¤ ê¸ˆ ê¸°ìš´ì´ ì•½í•´ ì§€ì¶œ í†µì œê°€ ëŠìŠ¨í•  ìˆ˜ ìˆì–´.",
          copies: ["ìë™ì´ì²´/í•œë„ ì„¤ì •ì´ ë‹µì´ì•¼.", "ì†Œì•¡ì´ë¼ë„ ê¸°ë¡í•´ë‘ë©´ í›¨ì”¬ ì•ˆì •ë¼."],
        },
        {
          id: "WORK_SPEED_MATCH",
          section: "ì¼",
          priority: 74,
          when: (a, b) => Math.abs(a.elements["í™”"] - b.elements["í™”"]) <= 0.3,
          evidence: "ì¼ ì²˜ë¦¬ ì†ë„ê°€ ë¹„ìŠ·í•´ í˜‘ì—…ì´ í¸í•´.",
          copies: ["ì†ë„ ì¡°ì ˆ ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì ì–´.", "ê°™ì€ í˜ì´ìŠ¤ë¡œ ë‹¬ë¦¬ë©´ ìµœê³ ."],
        },
        {
          id: "WORK_SPEED_DIFF",
          section: "ì¼",
          priority: 62,
          when: (a, b) => Math.abs(a.elements["í™”"] - b.elements["í™”"]) >= 0.8,
          evidence: "ì¼ ì²˜ë¦¬ ì†ë„ ì°¨ì´ê°€ ì»¤ì„œ ë§ˆì°°ì´ ìƒê¸¸ ìˆ˜ ìˆì–´.",
          copies: ["ê¸°í•œë§Œ ë¶„ëª…í•˜ê²Œ ë§ì¶”ì.", "ì†ë„ ì°¨ì´ëŠ” ì—­í•  ë¶„ë‹´ìœ¼ë¡œ í•´ê²°ëœë‹¤."],
        },
        {
          id: "WORK_IDEA_SUPPORT",
          section: "ì¼",
          priority: 72,
          when: (a, b) => (a.elements["ëª©"] >= 1.3 && b.elements["í™”"] >= 1.3) || (b.elements["ëª©"] >= 1.3 && a.elements["í™”"] >= 1.3),
          evidence: "í•œìª½ì€ ì•„ì´ë””ì–´, í•œìª½ì€ ì‹¤í–‰ì— ê°•í•´.",
          copies: ["ê¸°íšê³¼ ì‹¤í–‰ì´ ì˜ ë§ëŠ” ì¡°í•©.", "ì—­í• ë§Œ ëª…í™•íˆ í•˜ë©´ ì†ë„ê°€ ë‚œë‹¤."],
        },
        {
          id: "WORK_STRESS_CLASH",
          section: "ì¼",
          priority: 60,
          when: (a, b) => a.elements["í™”"] >= 1.5 && b.elements["ê¸ˆ"] <= 0.8 && b.elements["í™”"] >= 1.5 && a.elements["ê¸ˆ"] <= 0.8,
          evidence: "ë‘˜ ë‹¤ ì†ë„ëŠ” ë¹ ë¥¸ë° ì œì–´ê°€ ì•½í•´.",
          copies: ["ê³¼ì—´ë§Œ ì¡°ì‹¬í•˜ë©´ ì„±ê³¼ëŠ” í™•ì‹¤í•´.", "ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ í•œ ì¥ì”©ë§Œ ì¨ë„ ì¢‹ì•„."],
        },
        {
          id: "HEALTH_RECOVERY_GOOD",
          section: "ê±´ê°•",
          priority: 76,
          when: (a, b) => a.elements["ìˆ˜"] >= 1.2 && b.elements["ìˆ˜"] >= 1.2,
          evidence: "ë‘˜ ë‹¤ íšŒë³µ íƒ„ë ¥ì´ ì¢‹ì€ í¸ì´ì•¼.",
          copies: ["ì‰¬ëŠ” ë‚ ë§Œ ë§ì¶”ë©´ ì»¨ë””ì…˜ì´ í™• ì¢‹ì•„ì§„ë‹¤.", "ìˆ˜ë©´ë§Œ ì§€ì¼œë„ ë°˜ì€ ì„±ê³µ."],
        },
        {
          id: "HEALTH_RHYTHM_GAP",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => Math.abs(a.elements["ìˆ˜"] - b.elements["ìˆ˜"]) >= 0.8,
          evidence: "íšŒë³µ ë¦¬ë“¬ ì°¨ì´ê°€ ì»¤ì„œ í”¼ë¡œê°€ ì—‡ê°ˆë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì»¨ë””ì…˜ ì¢‹ì€ ë‚ ì— ì¤‘ìš”í•œ ì¼ ë°°ì¹˜.", "ê°ì ì‰¬ëŠ” íƒ€ì´ë°ì„ ì¡´ì¤‘í•˜ì."],
        },
        {
          id: "HEALTH_DIGEST",
          section: "ê±´ê°•",
          priority: 58,
          when: (a, b) => a.elements["í† "] <= 0.8 && b.elements["í† "] <= 0.8,
          evidence: "ë‘˜ ë‹¤ í†  ê¸°ìš´ì´ ì•½í•´ ì»¨ë””ì…˜ì´ í”ë“¤ë¦´ ìˆ˜ ìˆì–´.",
          copies: ["ì‹ì‚¬/ìˆ˜ë©´ ë£¨í‹´ë§Œ ì¡ì•„ë„ ì•ˆì •ëœë‹¤.", "ë¬´ë¦¬í•œ ì•½ì†ì„ ì¤„ì´ì."],
        },
        {
          id: "HEALTH_BALANCE_HELP",
          section: "ê±´ê°•",
          priority: 70,
          when: (a, b) => (a.elements["í† "] >= 1.3 && b.elements["ìˆ˜"] >= 1.3) || (b.elements["í† "] >= 1.3 && a.elements["ìˆ˜"] >= 1.3),
          evidence: "í•œìª½ì˜ ì•ˆì •ê°ê³¼ í•œìª½ì˜ íšŒë³µë ¥ì´ ì˜ ë§ì•„.",
          copies: ["ìƒí™œ ë¦¬ë“¬ì„ ê³µìœ í•˜ë©´ ì»¨ë””ì…˜ì´ ì¢‹ì•„ì§„ë‹¤.", "ê·œì¹™ì ì¸ íœ´ì‹ì´ ê°•ì ."],
        },
      ];

      const TUNE_KEY = "compat_rule_tuning_v1";
      const TUNE_CFG_KEY = "compat_rule_tuning_cfg_v1";

      function loadTune() {
        try {
          return JSON.parse(localStorage.getItem(TUNE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveTune(v) {
        localStorage.setItem(TUNE_KEY, JSON.stringify(v));
      }
      function loadTuneCfg() {
        try {
          return JSON.parse(localStorage.getItem(TUNE_CFG_KEY) || "{}") || { strength: 1 };
        } catch {
          return { strength: 1 };
        }
      }
      function saveTuneCfg(cfg) {
        localStorage.setItem(TUNE_CFG_KEY, JSON.stringify(cfg));
      }
      function getTuneStrength() {
        return loadTuneCfg().strength ?? 1;
      }
      function getTunedPriority(rule) {
        const tune = loadTune();
        const delta = tune[rule.id] || 0;
        const strength = getTuneStrength();
        const tuned = rule.priority + delta * strength;
        return Math.max(40, Math.min(100, tuned));
      }
      function feedback(ruleId) {
        const t = loadTune();
        t[ruleId] = (t[ruleId] || 0) + 1.5;
        saveTune(t);
        updateTuneStatus();
      }
      function updateTuneStatus() {
        const t = loadTune();
        const keys = Object.keys(t);
        const strength = getTuneStrength();
        tuneStatus.textContent = keys.length
          ? `íŠœë‹ ì ìš© ì¤‘: ${keys.length}ê°œ ë£° (ê°•ë„ ${strength.toFixed(1)})`
          : `íŠœë‹ ì—†ìŒ (ê°•ë„ ${strength.toFixed(1)})`;
      }

      function buildPerson(person) {
        const { top, weak } = getTopWeak(person.elements);
        const monthBranch = person.monthBranch || "";
        const seasonTopElem = monthBranch ? BRANCH_MAIN_ELEM[monthBranch] : "";
        return {
          ...person,
          topElem: top,
          weakElem: weak,
          topScore: person.elements[top],
          weakScore: person.elements[weak],
          balance: calcBalance(person.elements),
          seasonTopElem,
          moneyStyle: person.elements["ê¸ˆ"] + person.elements["ìˆ˜"],
        };
      }

      function evaluateRules(a, b) {
        return RULES.filter((r) => r.when(a, b)).map((r) => ({
          ...r,
          tunedPriority: getTunedPriority(r),
        }));
      }

      function calcSectionScores(firedRules) {
        const result = {};
        Object.keys(SECTION_WEIGHT).forEach((s) => (result[s] = { sum: 0, cnt: 0 }));
        firedRules.forEach((r) => {
          if (result[r.section]) {
            result[r.section].sum += r.tunedPriority;
            result[r.section].cnt += 1;
          }
        });
        const scores = {};
        Object.keys(result).forEach((s) => {
          scores[s] = result[s].cnt ? Math.round(result[s].sum / result[s].cnt) : 50;
        });
        return scores;
      }

      function calcTotalFromSections(sectionScores) {
        let total = 0;
        Object.entries(SECTION_WEIGHT).forEach(([k, w]) => {
          total += sectionScores[k] * w;
        });
        return Math.round(total);
      }

      function generateSummary(score) {
        if (score >= 85) return "ì „ë°˜ì ìœ¼ë¡œ ê¶í•©ì´ ê°•í•´. ê¸°ë³¸ ê²°ì´ ì˜ ë§ê³ , ì¥ê¸°ì ìœ¼ë¡œ ì•ˆì •ì ì´ì•¼.";
        if (score >= 70) return "ì¢‹ì€ í¸ì´ì•¼. í¬ì¸íŠ¸ ëª‡ ê°€ì§€ë§Œ ë§ì¶”ë©´ í›¨ì”¬ í¸í•´ì§ˆ ìˆ˜ ìˆì–´.";
        if (score >= 55) return "ë¬´ë‚œí•´. ì•½ì†ë§Œ ì˜ ì„¸ìš°ë©´ ì¶©ë¶„íˆ ì¢‹ì€ ê´€ê³„ë¡œ ê°ˆ ìˆ˜ ìˆì–´.";
        return "ë…¸ë ¥ì´ í•„ìš”í•œ ê¶í•©ì´ì•¼. ëŒ€ì‹  ê¸°ì¤€ë§Œ ë§ì¶”ë©´ ì˜ì™¸ë¡œ ë‹¨ë‹¨í•´ì§ˆ ìˆ˜ ìˆì–´.";
      }

      /* ======================================================
  6. í†¤ ë¶„ê¸°
====================================================== */
      const TONE = {
        couple: {
          title: "ì»¤í”Œ ëª¨ë“œ",
          soften: (s) =>
            s
              .replaceAll("ê·œì¹™", "ì•½ì†")
              .replaceAll("ê¸°í•œ", "íƒ€ì´ë°")
              .replaceAll("ë¦¬ìŠ¤í¬", "ì¡°ì‹¬ í¬ì¸íŠ¸"),
          tips: {
            conflict: ["ê°ì • ì˜¬ë¼ì˜¤ë©´ í•œ ë°•ì ì‰¬ê³  ë§í•˜ì.", "ë¬¸ìë³´ë‹¤ ì–¼êµ´ ë³´ê³  ì–˜ê¸°í•˜ëŠ” ê²Œ ë‹µ."],
            money: ["ëˆ ì–˜ê¸°ëŠ” ê¸°ì¤€ì„ ë¨¼ì € ë§ì¶”ëŠ” ê²Œ í¸í•´.", "í°ëˆë§Œ ê°™ì´ ê²°ì •í•˜ê³  ë‚˜ë¨¸ì§„ ììœ ë¡œ ê°€ì."],
          },
        },
        biz: {
          title: "ë™ì—…ì ëª¨ë“œ",
          soften: (s) =>
            s
              .replaceAll("ê°ì •", "ì»¤ë®¤ë‹ˆì¼€ì´ì…˜")
              .replaceAll("ì„œë¡œ", "ì–‘ì¸¡")
              .replaceAll("ì˜¤í•´", "ì •ë³´ ë¹„ëŒ€ì¹­"),
          tips: {
            conflict: ["ì˜ì‚¬ê²°ì • í”„ë¡œì„¸ìŠ¤ë¥¼ ë¬¸ì„œë¡œ ë°•ì•„.", "íšŒì˜ëŠ” ì˜ì œ 1ê°œì”©ë§Œ ì¡ì."],
            money: ["ì¬ë¬´ëŠ” ë£°ì´ ì•„ë‹ˆë¼ ì •ì±…ì´ë‹¤.", "ì§€ì¶œ ê¸°ì¤€/ìŠ¹ì¸ê¶Œì/í•œë„ë¥¼ ê³ ì •í•´."],
          },
        },
      };

      function applyTone(text, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        return t.soften(text);
      }
      function toneExtraTip(section, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        const pool = t.tips[section] || [];
        if (!pool.length) return "";
        return pool[hashToIndex(`${toneKey}|${section}`, pool.length)];
      }

      /* ======================================================
  7. ì„¹ì…˜ ë ˆì´ë” ë Œë”
====================================================== */
      function renderRadar(scores) {
        const svg = sectionRadarSvg;
        const keys = ["ì„±í–¥", "ê´€ê³„", "ëˆ", "ì¼", "ê±´ê°•"];
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [cx + R * v * Math.cos(ang(i)), cy + R * v * Math.sin(ang(i))];
        const polyPoints = (arr, scale = 1) =>
          arr.map((v, i) => pt(v * scale, i).map((n) => n.toFixed(2)).join(",")).join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", { x1: cx, y1: cy, x2: x, y2: y, stroke: "rgba(15,23,42,0.22)", "stroke-width": "1" })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = name;
          svg.appendChild(text);
        });

        const vals = keys.map((k) => clamp01((scores[k] ?? 50) / 100));
        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(37,99,235,0.28)",
          stroke: "rgba(37,99,235,0.9)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      /* ======================================================
  8. ì‹ ë…„ìš´ì„¸ ì›”ë³„
====================================================== */
      function pickMonthlyCopy(ctx) {
        const { month, seasonElem, top, weak, relTop, relWeak } = ctx;
        let mode = "steady";
        if (relTop === "ìƒ" || relTop === "ë™") mode = "push";
        if (relWeak === "ìƒ" || relWeak === "ë™") mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "ê·¹" || relTop === "ëˆŒë¦¼") mode = "brake";

        const monthLabel = `${month}ì›”`;
        const templates = {
          push: [
            [`${monthLabel}ì€ íë¦„ì´ ë„¤ í¸ì´ì•¼. ë°€ì–´ë¶™ì´ë©´ ì„±ê³¼ê°€ ë‚œë‹¤.`, "ê°€ì¥ ì¤‘ìš”í•œ ì¼ 1ê°œë§Œ ë¨¼ì € ëë‚´."],
            [`${monthLabel}ì€ ì†ë„ê°€ ë¶™ëŠ” ë‹¬ì´ì•¼. ë¯¸ë£¨ë˜ ê±° ì²˜ë¦¬í•˜ê¸° ë”± ì¢‹ì•„.`, "ì—°ë½/ê²°ì •/ì •ë¦¬ ì¤‘ í•˜ë‚˜ëŠ” ì´ë²ˆ ë‹¬ì— ëë‚´."],
          ],
          pushPlus: [
            [`${monthLabel}ì€ ì¢‹ì€ íë¦„ + íšŒë³µê¹Œì§€ ê°™ì´ ì˜¤ëŠ” ë‹¬ì´ì•¼.`, "ìš•ì‹¬ë‚´ë„ ë˜ëŠ”ë°, ìˆ˜ë©´ë§Œì€ ê¼­ ì§€ì¼œ."],
            [`${monthLabel}ì€ ì˜ í’€ë¦¬ë©´ì„œ í¸í•´ì§€ëŠ” ë‹¬ì´ì•¼.`, "ìƒˆë¡œ ë²Œë¦¬ê¸°ë³´ë‹¤ ê¸°ì¡´ ê±¸ ì—…ê·¸ë ˆì´ë“œí•˜ë©´ í¬ê²Œ ë‚¨ì•„."],
          ],
          recover: [
            [`${monthLabel}ì€ íšŒë³µì´ ë³µì´ë‹¤. ì»¨ë””ì…˜ë§Œ ì¡ì•„ë„ ì¼ì´ í’€ë¦°ë‹¤.`, "ë¬´ë¦¬í•œ ì•½ì† ì¤„ì´ê³  ë£¨í‹´ í•˜ë‚˜ ë¶™ì—¬."],
            [`${monthLabel}ì€ ì •ë¦¬í•˜ë©´ ìš´ì´ ë¶™ëŠ” ë‹¬ì´ì•¼.`, "ê³µê°„/ëˆ/ì¼ì • ì¤‘ í•˜ë‚˜ë§Œ ì •ë¦¬í•´ë„ ì²´ê° ì˜¨ë‹¤."],
          ],
          brake: [
            [`${monthLabel}ì€ ë¬´ë¦¬í•˜ë©´ ì†í•´ ë³´ëŠ” ë‹¬ì´ì•¼. ì†ë„ ì¤„ì´ëŠ” ê²Œ ì´ë“.`, "í° ê²°ì •ì€ 2ì£¼ë§Œ ë¯¸ë£¨ê³  í™•ì¸ë¶€í„° í•´."],
            [`${monthLabel}ì€ ì‹ ì¤‘ì´ ê³§ ëˆì´ë‹¤.`, "ê³„ì•½/íˆ¬ì/ì¶©ë™êµ¬ë§¤ëŠ” í•œ ë²ˆ ë” ì²´í¬."],
          ],
          steady: [
            [`${monthLabel}ì€ ìœ ì§€ê°€ ì´ê¸°ëŠ” ë‹¬ì´ì•¼. ê¸°ë³¸ë§Œ ì§€ì¼œë„ ì¶©ë¶„í•´.`, "ë£¨í‹´ 3ê°œ(ìˆ˜ë©´/ì‹ì‚¬/ì •ë¦¬)ë§Œ ì±™ê²¨."],
            [`${monthLabel}ì€ í° ë³€í™”ë³´ë‹¤ ì‘ì€ ê°œì„ ì´ ë§ì•„.`, "5% ê°œì„  ëª©í‘œë¡œ ê°€ë©´ ê¾¸ì¤€íˆ ì´ê¸´ë‹¤."],
          ],
        };

        const seed = `${month}|${seasonElem}|${top}|${weak}|${mode}`;
        const arr = templates[mode];
        const idx = hashToIndex(seed, arr.length);
        const [oneLine, tip] = arr[idx];
        return { oneLine, tip, tags: [mode, seasonElem] };
      }

      function makeMonthlyLuck(person) {
        const { top, weak } = getTopWeak(person.elements);
        const months = [];
        for (let m = 1; m <= 12; m++) {
          const flow = MONTH_FLOW[m];
          const s = flow.seasonTop;
          const relTop = relationElem(top, s);
          const relWeak = relationElem(weak, s);
          const { oneLine, tip, tags } = pickMonthlyCopy({ month: m, seasonElem: s, top, weak, relTop, relWeak });
          months.push({
            month: m,
            seasonElem: s,
            monthBranch: flow.monthBranch,
            summary: oneLine,
            tip,
            tags,
          });
        }
        return months;
      }

      function renderMonthly(person) {
        monthlyList.innerHTML = makeMonthlyLuck(person)
          .map(
            (m) => `
            <div class="rule-card">
              <div class="row" style="justify-content: space-between">
                <div class="section-title">${m.month}ì›” Â· ${m.seasonElem} íë¦„</div>
                <span class="mini">${m.tags.join(" Â· ")}</span>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              <p class="mini">íŒ: ${escapeHtml(m.tip)}</p>
            </div>`
          )
          .join("");
      }

      /* ======================================================
  9. ë Œë”
====================================================== */
      function renderSummary(totalScore, firedRules, toneKey, coupleElements) {
        const summary = generateSummary(totalScore);
        totalScoreEl.textContent = `${totalScore}ì `;
        summaryMain.textContent = summary;
        summarySub.textContent = "Asia/Seoul ê¸°ì¤€ Â· ì ˆê¸°/ì˜¤í–‰ ê·œì¹™";

        const { top, weak } = getTopWeak(coupleElements);
        const pills = [
          `í•µì‹¬ ì˜¤í–‰: ${top}`,
          `ì•½í•œ ì˜¤í–‰: ${weak}`,
          `ë°œë™ ë£°: ${firedRules.length}ê°œ`,
          TONE[toneKey]?.title || "ì»¤í”Œ ëª¨ë“œ",
        ];
        summaryPills.innerHTML = pills.map((p) => `<span class="pill">${escapeHtml(p)}</span>`).join("");
      }

      function renderRules(firedRules, toneKey, tokens) {
        if (!firedRules.length) {
          ruleList.innerHTML = `<p class="mini">ë°œë™ëœ ë£°ì´ ì•„ì§ ì—†ì–´. ì…ë ¥ê°’ì„ í™•ì¸í•´ì¤˜.</p>`;
          return;
        }

        ruleList.innerHTML = firedRules
          .sort((a, b) => b.tunedPriority - a.tunedPriority)
          .map((r) => {
            const evidence = applyTone(fillTokens(r.evidence, tokens), toneKey);
            const copy = applyTone(r.copies[0], toneKey);
            const extra = r.section === "ëˆ" ? toneExtraTip("money", toneKey) : toneExtraTip("conflict", toneKey);
            return `
            <div class="rule-card">
              <div class="rule-head">
                <b>${escapeHtml(r.id)}</b>
                <button class="like-btn" data-rule="${r.id}">ê³µê° ğŸ‘</button>
              </div>
              <p class="mini">ê·¼ê±°: ${escapeHtml(evidence)}</p>
              <p>${escapeHtml(copy)}${extra ? `<br/><span class="mini">+ ${escapeHtml(extra)}</span>` : ""}</p>
            </div>`;
          })
          .join("");
      }

      function renderPillars(targetEl, result) {
        if (!result) {
          targetEl.textContent = "â€”";
          return;
        }
        const p = result.pillars;
        targetEl.innerHTML = `ì…ë ¥: ${result.input.kst}<br/>
          ì—°: ${p.year.text} / ì›”: ${p.month.text}<br/>
          ì¼: ${p.day.text} / ì‹œ: ${p.hour.text}`;
      }

      function renderAll() {
        if (!state.A || !state.B) return;

        const a = buildPerson(state.A);
        const b = buildPerson(state.B);
        const toneKey = toneSelect.value;
        const firedRules = evaluateRules(a, b);
        const sectionScores = calcSectionScores(firedRules);
        const totalScore = calcTotalFromSections(sectionScores);
        const coupleElements = combineElements(a.elements, b.elements);
        const coupleStats = getTopWeak(coupleElements);

        renderSummary(totalScore, firedRules, toneKey, coupleElements);
        renderTodayCoupleBox(a, b);
        renderRadar(sectionScores);
        renderRules(firedRules, toneKey, {
          topElem: coupleStats.top,
          weakElem: coupleStats.weak,
          A_topElem: a.topElem,
          B_topElem: b.topElem,
          A_weakElem: a.weakElem,
          B_weakElem: b.weakElem,
          A_branch: a.dayBranch,
          B_branch: b.dayBranch,
          A_season: a.seasonTopElem,
          B_season: b.seasonTopElem,
        });
        renderMonthly({ elements: coupleElements });
        renderPillars(aPillarsEl, state.aResult);
        renderPillars(bPillarsEl, state.bResult);

        return { totalScore, firedRules, sectionScores, coupleElements };
      }

      /* ======================================================
  10. ê³µìœ  ì¹´ë“œ
====================================================== */
      function roundRect(ctx, x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let i = 0; i < words.length; i++) {
          const test = line + words[i] + " ";
          if (ctx.measureText(test).width > maxWidth && i > 0) {
            ctx.fillText(line, x, y);
            line = words[i] + " ";
            y += lineHeight;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, y);
      }

      async function generateShareCard(payload) {
        const c = document.getElementById("shareCanvas");
        const ctx = c.getContext("2d");

        const g = ctx.createLinearGradient(0, 0, 0, c.height);
        g.addColorStop(0, "#0b1621");
        g.addColorStop(0.5, "#101f2e");
        g.addColorStop(1, "#14273b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, c.width, c.height);

        const pad = 70;
        const cardX = pad;
        const cardY = pad;
        const cardW = c.width - pad * 2;
        const cardH = c.height - pad * 2;
        roundRect(ctx, cardX, cardY, cardW, cardH, 40, "rgba(255,255,255,0.92)");

        ctx.fillStyle = "#0f172a";
        ctx.font = "800 52px IBM Plex Sans KR";
        ctx.fillText(payload.title, cardX + 50, cardY + 120);

        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.toneLabel, cardX + 50, cardY + 170);

        ctx.font = "800 130px IBM Plex Sans KR";
        ctx.fillStyle = "#0f172a";
        ctx.fillText(String(payload.score), cardX + 50, cardY + 320);
        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText("ê¶í•© ì ìˆ˜", cardX + 50, cardY + 370);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.85)";
        ctx.fillText(`í•µì‹¬ ì˜¤í–‰: ${payload.topElem}`, cardX + 50, cardY + 450);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        wrapText(ctx, `ì´í‰: ${payload.summary}`, cardX + 50, cardY + 530, cardW - 100, 44);

        ctx.font = "700 28px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.78)";
        wrapText(ctx, `ì˜¤ëŠ˜: ${payload.todayLine}`, cardX + 50, cardY + 720, cardW - 100, 40);

        ctx.font = "700 26px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.6)";
        ctx.fillText("funnyfunny.cloud", cardX + 50, cardY + cardH - 70);

        return new Promise((resolve) => c.toBlob(resolve, "image/png", 1.0));
      }

      async function shareCard() {
        if (!state.A || !state.B) {
          alert("A/B ì…ë ¥ í›„ ê³„ì‚°í•´ì¤˜.");
          return;
        }
        const toneKey = toneSelect.value;
        const stateSnapshot = renderAll();
        const topElem = getTopWeak(stateSnapshot.coupleElements).top;
        const blob = await generateShareCard({
          title: "ê¶í•© ë¦¬í¬íŠ¸",
          score: stateSnapshot.totalScore,
          summary: summaryMain.textContent,
          todayLine: todayCoupleLine.textContent,
          topElem,
          toneLabel: TONE[toneKey]?.title || "ì»¤í”Œ ëª¨ë“œ",
        });

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `ê¶í•©ì¹´ë“œ_${new Date().toISOString().slice(0, 10)}.png`;
        a.click();

        try {
          await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
          shareStatus.textContent = "ì¹´ë“œë¥¼ ìƒì„±í•˜ê³  í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆì–´.";
        } catch {
          shareStatus.textContent = "ì¹´ë“œë¥¼ ìƒì„±í–ˆì–´. ë‹¤ìš´ë¡œë“œë¥¼ í™•ì¸í•´ì¤˜.";
        }
      }

      /* ======================================================
  11. PDF ì €ì¥ (html2canvas + jsPDF)
====================================================== */
      async function savePdfPretty() {
        if (!state.A || !state.B) {
          alert("A/B ì…ë ¥ í›„ ê³„ì‚°í•´ì¤˜.");
          return;
        }
        if (!window.html2canvas || !window.jspdf) {
          alert("PDF ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ì–´.");
          return;
        }
        const area = document.getElementById("pdfArea");
        const canvas = await html2canvas(area, {
          scale: 2,
          backgroundColor: null,
          useCORS: true,
          logging: false,
        });
        const imgData = canvas.toDataURL("image/png", 1.0);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;

        if (imgH <= pageH) {
          pdf.addImage(imgData, "PNG", 0, 0, imgW, imgH);
        } else {
          let y = 0;
          let remaining = imgH;
          while (remaining > 0) {
            pdf.addImage(imgData, "PNG", 0, -y, imgW, imgH);
            remaining -= pageH;
            y += pageH;
            if (remaining > 0) pdf.addPage();
          }
        }

        const fileName = `ê¶í•©ë¦¬í¬íŠ¸_${new Date().toISOString().slice(0, 10)}.pdf`;
        pdf.save(fileName);
      }

      /* ======================================================
  12. ì…ë ¥/ê³„ì‚° íŒŒì´í”„ë¼ì¸
====================================================== */
      function loadInputs() {
        try {
          return JSON.parse(localStorage.getItem(INPUT_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveInputs(data) {
        localStorage.setItem(INPUT_KEY, JSON.stringify(data));
      }

      function setInputs(data) {
        if (!data) return;
        aDate.value = data.aDate || "";
        aTime.value = data.aTime || "";
        aZiMode.value = data.aZiMode || "2300";
        aHiddenMode.value = data.aHiddenMode || "on";
        bDate.value = data.bDate || "";
        bTime.value = data.bTime || "";
        bZiMode.value = data.bZiMode || "2300";
        bHiddenMode.value = data.bHiddenMode || "on";
        toneSelect.value = data.tone || "couple";
      }

      function getInputData() {
        return {
          aDate: aDate.value,
          aTime: aTime.value,
          aZiMode: aZiMode.value,
          aHiddenMode: aHiddenMode.value,
          bDate: bDate.value,
          bTime: bTime.value,
          bZiMode: bZiMode.value,
          bHiddenMode: bHiddenMode.value,
          tone: toneSelect.value,
        };
      }

      function computePair() {
        const data = getInputData();
        if (!data.aDate || !data.aTime || !data.bDate || !data.bTime) {
          alert("A/B ë‚ ì§œì™€ ì‹œê°„ì„ ëª¨ë‘ ì…ë ¥í•´ì¤˜.");
          return;
        }
        saveInputs(data);

        const aBirth = parseKSTDateTime(data.aDate, data.aTime);
        const bBirth = parseKSTDateTime(data.bDate, data.bTime);

        const aResult = computeSajuFiveElements(aBirth, { ziMode: data.aZiMode, hiddenMode: data.aHiddenMode });
        const bResult = computeSajuFiveElements(bBirth, { ziMode: data.bZiMode, hiddenMode: data.bHiddenMode });

        state.aResult = aResult;
        state.bResult = bResult;
        state.A = {
          name: "A",
          elements: aResult.elements.raw,
          dayBranch: aResult.pillars.day.branch,
          monthBranch: aResult.pillars.month.branch,
        };
        state.B = {
          name: "B",
          elements: bResult.elements.raw,
          dayBranch: bResult.pillars.day.branch,
          monthBranch: bResult.pillars.month.branch,
        };

        renderAll();
      }

      /* ======================================================
  INIT
====================================================== */
      function init() {
        const cfg = loadTuneCfg();
        tuneStrength.value = String(cfg.strength ?? 1);
        tuneLabel.textContent = Number(tuneStrength.value).toFixed(1);
        updateTuneStatus();
        const saved = loadInputs();
        setInputs(saved);
        if (saved.aDate && saved.aTime && saved.bDate && saved.bTime) {
          computePair();
        }
      }

      document.addEventListener("click", (e) => {
        const btn = e.target.closest(".like-btn");
        if (!btn) return;
        const ruleId = btn.dataset.rule;
        feedback(ruleId);
        btn.textContent = "ê³µê°ë¨ âœ”";
        btn.disabled = true;
      });

      tuneStrength.addEventListener("input", () => {
        const v = Number(tuneStrength.value);
        tuneLabel.textContent = v.toFixed(1);
        saveTuneCfg({ strength: v });
        updateTuneStatus();
        renderAll();
      });

      tuneReset.addEventListener("click", () => {
        localStorage.removeItem(TUNE_KEY);
        updateTuneStatus();
        renderAll();
      });

      toneSelect.addEventListener("change", () => {
        saveInputs(getInputData());
        renderAll();
      });

      todayLuckBtn.addEventListener("click", () => {
        if (state.A && state.B) renderTodayCoupleBox(buildPerson(state.A), buildPerson(state.B));
      });

      shareBtn.addEventListener("click", shareCard);
      pdfBtn.addEventListener("click", savePdfPretty);
      calcBtn.addEventListener("click", computePair);

      init();
    </script>
  </body>
</html>
