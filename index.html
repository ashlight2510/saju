<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>사주풀이 · 궁합 · 오늘운세 · 신년운세</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🔮</text></svg>"
    />

    <!-- Adsense (요청 반영) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;600;800&family=Playfair+Display:wght@700;800&family=Noto+Serif+KR:wght@400;600;700&display=swap");

      :root {
        --bg1: #0a0f1a;
        --bg2: #0f1623;
        --bg3: #141b2d;
        --card: rgba(255, 255, 255, 0.98);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.7);
        --line: rgba(15, 23, 42, 0.08);
        --accent: #6366f1;
        --accent-hover: #4f46e5;
        --accent2: #f59e0b;
        --accent-grad: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.1);
        --shadow-hover: 0 24px 80px rgba(99, 102, 241, 0.2),
          0 0 0 1px rgba(255, 255, 255, 0.15);
        --radius: 20px;
        --radius-sm: 14px;
        --font-body: "IBM Plex Sans KR", "Apple SD Gothic Neo", sans-serif;
        --font-title: "Playfair Display", "Nanum Myeongjo", serif;
        --font-service: "Noto Serif KR", "Nanum Myeongjo", serif;
      }

      * {
        box-sizing: border-box;
      }
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(99, 102, 241, 0.3);
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(99, 102, 241, 0.5);
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: radial-gradient(
            1400px 700px at 8% -5%,
            rgba(99, 102, 241, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            1200px 600px at 92% 5%,
            rgba(139, 92, 246, 0.12) 0%,
            transparent 50%
          ),
          radial-gradient(
            1000px 500px at 50% 100%,
            rgba(59, 130, 246, 0.08) 0%,
            transparent 60%
          ),
          linear-gradient(
            180deg,
            var(--bg1) 0%,
            var(--bg2) 50%,
            var(--bg3) 100%
          );
        color: rgba(255, 255, 255, 0.95);
        font-size: 16px;
        position: relative;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(99, 102, 241, 0.03) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(139, 92, 246, 0.03) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 0;
      }
      .wrap {
        max-width: 1080px;
        margin: 0 auto;
        padding: 32px 20px 56px;
        position: relative;
        z-index: 1;
      }
      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }
      h1 {
        font-family: var(--font-title);
        font-weight: 800;
        letter-spacing: 0.02em;
        font-size: 32px;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      h2 {
        font-size: 24px;
        font-weight: 800;
        color: var(--text);
      }
      h3 {
        font-size: 19px;
        font-weight: 800;
        color: var(--text);
      }
      .hero {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        margin-bottom: 24px;
        padding: 16px 0;
      }
      .badge {
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 0.08em;
        padding: 12px 20px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        font-family: var(--font-service);
      }
      .badge.service-name {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.1em;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.2) 0%,
          rgba(139, 92, 246, 0.2) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.3);
        color: rgba(255, 255, 255, 0.98);
        text-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
      }
      .badge:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      }
      .badge.service-name:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.25) 0%,
          rgba(139, 92, 246, 0.25) 100%
        );
        border-color: rgba(99, 102, 241, 0.4);
        box-shadow: 0 6px 20px rgba(99, 102, 241, 0.25);
      }
      .card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 28px;
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: var(--shadow);
        backdrop-filter: blur(20px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent-grad);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-hover);
      }
      .card:hover::before {
        opacity: 1;
      }
      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .card-head.center {
        justify-content: center;
        text-align: center;
      }
      .score {
        font-size: 36px;
        font-weight: 800;
        background: var(--accent-grad);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .lead {
        font-size: 1.2rem;
        font-weight: 800;
        line-height: 1.7;
        color: var(--text);
      }
      .mini {
        font-size: 0.95rem;
        color: var(--muted);
        font-weight: 600;
        line-height: 1.7;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
      }
      .row.center {
        justify-content: center;
      }
      .btn {
        padding: 14px 20px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        cursor: pointer;
        background: var(--accent-grad);
        color: #fff;
        font-size: 15px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        position: relative;
        overflow: hidden;
        z-index: 1;
      }
      .btn::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
        z-index: -1;
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      }
      .btn:hover::before {
        width: 300px;
        height: 300px;
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn * {
        position: relative;
        z-index: 1;
      }
      .btn.outline {
        background: rgba(255, 255, 255, 0.95);
        color: var(--text);
        border: 2px solid rgba(15, 23, 42, 0.1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }
      .btn.outline:hover {
        background: #fff;
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
      }
      .btn.ghost {
        background: rgba(15, 23, 42, 0.06);
        color: var(--text);
        border: 1px solid rgba(15, 23, 42, 0.12);
        box-shadow: none;
      }
      .btn.ghost:hover {
        background: rgba(15, 23, 42, 0.1);
        border-color: rgba(15, 23, 42, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .btn.compact {
        display: inline-flex;
        align-items: center;
        padding: 12px 20px;
        font-size: 14px;
        font-weight: 700;
        box-shadow: none;
      }
      .btn.outline.compact {
        border-width: 1px;
      }
      select,
      input[type="range"],
      input[type="date"],
      input[type="time"],
      input[type="number"],
      input[type="text"] {
        padding: 12px 14px;
        border-radius: var(--radius-sm);
        border: 2px solid rgba(15, 23, 42, 0.12);
        font-weight: 600;
        font-size: 15px;
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.98);
        width: 100%;
        flex: 1;
        min-width: 0;
        box-sizing: border-box;
        height: 48px;
        line-height: 1.5;
      }
      select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236366f1' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px;
        padding-right: 36px;
        cursor: pointer;
      }
      .rule-card .row {
        width: 100%;
        display: flex;
        align-items: stretch;
        gap: 12px;
      }
      .rule-card .row > * {
        flex: 1;
        min-width: 120px;
      }
      .rule-card .row:not(:first-child) {
        margin-top: 12px;
      }
      .rule-card p.mini {
        margin-top: 12px;
        margin-bottom: 0;
        text-align: center;
        font-size: 0.9rem;
      }
      select:focus,
      input[type="text"]:focus,
      input[type="date"]:focus,
      input[type="time"]:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }
      input[type="checkbox"] {
        transform: translateY(1px);
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }
      .rule-card {
        border: 1px solid var(--line);
        border-radius: var(--radius-sm);
        padding: 20px;
        margin-bottom: 12px;
        background: rgba(255, 255, 255, 0.98);
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .rule-card:hover {
        border-color: rgba(99, 102, 241, 0.2);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
      }
      .rule-card h3 {
        margin-bottom: 16px;
        text-align: center;
        font-size: 18px;
      }
      .rule-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .like-btn {
        border: none;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.15) 0%,
          rgba(139, 92, 246, 0.15) 100%
        );
        color: var(--accent);
        border-radius: var(--radius-sm);
        padding: 6px 12px;
        cursor: pointer;
        font-weight: 800;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(99, 102, 241, 0.1);
      }
      .like-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.2) 0%,
          rgba(139, 92, 246, 0.2) 100%
        );
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(99, 102, 241, 0.2);
      }
      .radar {
        width: 100%;
        max-width: 420px;
        margin: 12px auto 0;
        display: block;
      }
      .elements-radar {
        max-width: 600px;
        width: 100%;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 20px;
        max-width: 100%;
      }
      .input-container {
        max-width: 900px;
        margin: 0 auto;
      }
      .pill-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 800;
        padding: 8px 14px;
        border-radius: 999px;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.15);
        transition: all 0.2s ease;
      }
      .pill:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.12) 0%,
          rgba(139, 92, 246, 0.12) 100%
        );
        border-color: rgba(99, 102, 241, 0.25);
        transform: translateY(-1px);
      }
      .pill.emphasis {
        font-size: 14px;
        padding: 10px 16px;
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        color: #fff;
        border-color: rgba(79, 70, 229, 0.4);
        box-shadow: 0 6px 16px rgba(79, 70, 229, 0.35);
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: rgba(15, 23, 42, 0.06);
        color: #0f172a;
        font-weight: 800;
        line-height: 1.2;
      }
      .chip b {
        font-weight: 900;
      }
      .chip.e-wood {
        background: #e8f7e9;
        color: #0f3d2e;
        border-color: #bfe7c6;
      }
      .chip.e-fire {
        background: #ffe9e3;
        color: #7a1f16;
        border-color: #ffc5b5;
      }
      .chip.e-earth {
        background: #f8f1df;
        color: #5a3b12;
        border-color: #e7d3a7;
      }
      .chip.e-metal {
        background: #eef3ff;
        color: #1b3a70;
        border-color: #c9d6ff;
      }
      .chip.e-water {
        background: #e6f5ff;
        color: #0c3550;
        border-color: #b7e4ff;
      }
      .section-title {
        font-weight: 800;
        font-size: 1.05rem;
        color: var(--text);
        letter-spacing: -0.01em;
      }
      .share-note {
        margin-top: 10px;
      }
      .pdf-area {
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        padding: 24px 24px 12px;
        border-radius: var(--radius);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .step {
        display: none;
        animation: fadeIn 0.4s ease;
      }
      .step.active {
        display: block;
      }
      .menu-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
      }
      .menu-btn {
        border: 2px solid rgba(15, 23, 42, 0.08);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.98) 0%,
          rgba(248, 250, 252, 0.98) 100%
        );
        color: var(--text);
        border-radius: var(--radius);
        padding: 24px 20px;
        text-align: left;
        cursor: pointer;
        font-weight: 800;
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.1),
          0 0 0 1px rgba(255, 255, 255, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .menu-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(99, 102, 241, 0.1),
          transparent
        );
        transition: left 0.5s;
      }
      .menu-btn:hover {
        transform: translateY(-4px);
        box-shadow: 0 16px 40px rgba(99, 102, 241, 0.15),
          0 0 0 1px rgba(99, 102, 241, 0.2);
        border-color: rgba(99, 102, 241, 0.3);
        background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      }
      .menu-btn:hover::before {
        left: 100%;
      }
      .menu-btn:active {
        transform: translateY(-2px);
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 15, 26, 0.85);
        backdrop-filter: blur(12px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .loading-overlay.active {
        display: flex;
        animation: fadeIn 0.3s ease;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .loading-card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 32px 36px;
        min-width: 300px;
        text-align: center;
        box-shadow: var(--shadow-hover);
        border: 1px solid rgba(255, 255, 255, 0.3);
        animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      .spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(99, 102, 241, 0.2);
        border-top-color: var(--accent);
        margin: 0 auto 16px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .menu-btn small {
        display: block;
        margin-top: 8px;
        font-size: 13px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.65);
        line-height: 1.5;
      }
      .report-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 14px;
        border-radius: var(--radius-sm);
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .report-table th,
      .report-table td {
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 12px 14px;
        text-align: left;
        vertical-align: top;
      }
      .report-table th {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        font-weight: 800;
        color: var(--text);
      }
      .report-table tr:hover {
        background: rgba(99, 102, 241, 0.03);
      }
      .report-section {
        margin-top: 12px;
      }
      .report-section h3 {
        margin-bottom: 6px;
      }
      .hidden {
        display: none !important;
      }

      @media (max-width: 720px) {
        .wrap {
          padding: 24px 16px 40px;
        }
        h1 {
          font-size: 26px;
        }
        h2 {
          font-size: 20px;
        }
        .card {
          padding: 20px;
          border-radius: var(--radius-sm);
        }
        .grid-2 {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .input-container {
          max-width: 100%;
        }
        .rule-card .row > * {
          min-width: 100%;
        }
        .card-head {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }
        .menu-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .menu-btn {
          padding: 20px 18px;
        }
        .btn {
          padding: 12px 18px;
          font-size: 14px;
        }
        .hero {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }
        .badge {
          font-size: 11px;
          padding: 8px 14px;
        }
        body {
          font-size: 15px;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <div class="badge service-name">사주풀이</div>
        <div style="display: flex; gap: 8px; align-items: center">
          <div class="badge" id="todayBadge"></div>
          <a
            href="https://funnyfunny.cloud/"
            target="_blank"
            rel="noopener noreferrer"
            class="btn outline compact"
            style="text-decoration: none; white-space: nowrap"
          >
            다른 서비스 보기
          </a>
        </div>
      </div>

      <!-- Step 1: 메뉴 -->
      <section id="stepMenu" class="step active">
        <div class="card">
          <div class="card-head">
            <div>
              <h1
                style="
                  font-family: var(--font-service);
                  font-weight: 700;
                  letter-spacing: 0.02em;
                "
              >
                🔮 사주풀이
              </h1>
              <p class="mini">
                궁합/신년운세/오늘운세 중 선택하면 단계별로 입력받고 결과를
                보여줄게.
              </p>
            </div>
          </div>
          <div class="menu-grid" style="margin-top: 14px">
            <button class="menu-btn" data-mode="compat">
              궁합 보기
              <small>두 사람 입력 → 궁합/오늘운세/공유</small>
            </button>
            <button class="menu-btn" data-mode="newyear">
              신년운세
              <small>한 사람 입력 → 월별 흐름</small>
            </button>
            <button class="menu-btn" data-mode="today">
              오늘운세
              <small>한 사람 입력 → 오늘 한 줄</small>
            </button>
          </div>
        </div>
      </section>

      <!-- Step 2: 입력 -->
      <section id="stepInput" class="step">
        <div class="card" id="inputCard">
          <div class="card-head center">
            <div style="width: 100%">
              <h1 id="inputTitle">입력</h1>
              <p class="mini" id="inputDesc">출생 정보 입력 → 로컬 계산</p>
              <div class="row center" style="margin-top: 20px; gap: 10px">
                <button class="btn outline" id="backToMenu">메뉴로</button>
                <button class="btn ghost" id="clearSaved">저장 초기화</button>
                <button class="btn" id="calcBtn">계산하기</button>
              </div>
            </div>
          </div>

          <div class="input-container">
            <div class="grid-2" style="margin-top: 20px">
              <div class="rule-card" id="panelA">
                <h3>출생 정보</h3>
                <div class="row">
                  <input id="aDate" type="date" />
                  <select id="aHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <label class="mini">
                    <input id="aTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="aGender">
                    <option value="male" selected>남자</option>
                    <option value="female">여자</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="aDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  날짜와 시간(12간지)을 입력한 뒤 성별만 선택하면 돼.
                </p>
                <div class="row hidden" style="margin-top: 8px">
                  <select id="aHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="aTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="aDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">신토정비결 기준으로 계산해.</p>
              </div>

              <div class="rule-card" id="panelB">
                <h3>상대 정보</h3>
                <div class="row">
                  <input id="bDate" type="date" />
                  <select id="bHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <label class="mini">
                    <input id="bTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="bGender">
                    <option value="male">남자</option>
                    <option value="female" selected>여자</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="bDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  날짜와 시간(12간지)을 입력한 뒤 성별만 선택하면 돼.
                </p>
                <div class="row hidden" style="margin-top: 8px">
                  <select id="bHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="bTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="bDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">신토정비결 기준으로 계산해.</p>
              </div>
            </div>

            <div
              class="row center"
              style="margin-top: 24px; gap: 8px"
              id="toneRow"
            >
              <span class="mini" style="white-space: nowrap">톤</span>
              <select id="toneSelect" style="min-width: 150px">
                <option value="couple" selected>커플 모드</option>
                <option value="biz">동업자 모드</option>
              </select>
              <span
                class="mini"
                style="font-size: 0.85rem; color: rgba(15, 23, 42, 0.5)"
              >
                ※ 입력 시간은 한국 기준으로 계산합니다.
              </span>
            </div>
          </div>
        </div>
      </section>

      <!-- Step 3: 결과 -->
      <section id="stepResult" class="step">
        <div class="row" style="margin-bottom: 12px">
          <button class="btn outline" id="backToInput">입력 수정</button>
          <button class="btn outline" id="restartFlow">메뉴로</button>
        </div>

        <div id="pdfArea" class="pdf-area">
          <div class="card" id="resultElementsCard" style="padding: 40px">
            <h2 style="font-size: 28px; margin-bottom: 24px">오행 기운 분석</h2>
            <p
              class="lead"
              id="elementsSummary"
              style="font-size: 18px; margin-bottom: 32px"
            >
              —
            </p>
            <svg
              id="elementsRadarSvg"
              class="radar elements-radar"
              viewBox="0 0 320 320"
              style="
                width: 100%;
                max-width: 500px;
                height: auto;
                margin: 0 auto 32px;
                display: block;
              "
            ></svg>
            <p
              class="mini"
              id="elementsDetail"
              style="font-size: 14px; line-height: 1.8"
            >
              —
            </p>
          </div>
          <div class="card" id="resultDeepCard">
            <h2>심화 분석 (간이)</h2>
            <div id="deepAnalysis"></div>
          </div>
          <div class="card" id="resultLuckCard">
            <h2>대운 · 세운</h2>
            <div id="luckFlow"></div>
          </div>
          <div class="card" id="resultReportCard">
            <h2>2026 신토정비결</h2>
            <div id="reportContent"></div>
          </div>
          <div class="card" id="resultSummaryCard">
            <div class="card-head">
              <div>
                <h2 id="resultTitle">궁합 요약</h2>
                <p class="mini" id="summarySub">
                  입력 시간대 기준 · 절기/오행 규칙
                </p>
              </div>
              <div class="score" id="totalScore">—</div>
            </div>
            <p class="lead" id="summaryMain">—</p>
            <div class="pill-row" id="summaryPills"></div>
          </div>

          <div class="card" id="resultTodayCard">
            <div class="row" style="justify-content: space-between">
              <div>
                <h2>오늘 운세</h2>
                <p class="lead" id="todayCoupleLine">—</p>
                <p class="mini" id="todayCoupleMeta">—</p>
              </div>
              <button class="btn ghost" id="todayLuckBtn">
                오늘 다시 보기
              </button>
            </div>
          </div>

          <div class="grid-2" id="resultCompatGrid">
            <div class="card" id="resultRadarCard">
              <h2>섹션별 균형</h2>
              <svg
                id="sectionRadarSvg"
                class="radar"
                viewBox="0 0 320 320"
              ></svg>
              <p class="mini" id="sectionRadarLegend">관계의 전체 밸런스</p>
            </div>

            <div class="card" id="resultABCard">
              <h2>A/B 사주 요약</h2>
              <div class="grid-2" style="gap: 8px">
                <div>
                  <div class="section-title">A</div>
                  <div id="aPillars" class="mini"></div>
                </div>
                <div>
                  <div class="section-title">B</div>
                  <div id="bPillars" class="mini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="card" id="resultRulesCard">
            <h2>궁합 포인트</h2>
            <div id="ruleList"></div>
          </div>

          <div class="card" id="resultMonthlyCard">
            <h2>2026 신년운세 (월별)</h2>
            <div id="monthlyList"></div>
          </div>
        </div>

        <div class="card" id="tuningCard">
          <h2>튜닝 (학습 느낌)</h2>
          <div class="row">
            <span class="mini">튜닝 강도</span>
            <input
              type="range"
              min="0"
              max="2"
              step="0.1"
              value="1"
              id="tuneStrength"
            />
            <span id="tuneLabel" class="mini">1.0</span>
            <button class="btn outline" id="tuneReset">초기화</button>
          </div>
          <p class="mini" id="tuneStatus"></p>
        </div>

        <div class="card" id="shareCard" style="margin-top: 48px">
          <h2>공유 · PDF</h2>
          <div class="row">
            <button class="btn" id="shareBtn">공유 카드 만들기</button>
            <button class="btn outline" id="pdfBtn">PDF 저장</button>
          </div>
          <p class="mini share-note" id="shareStatus"></p>
          <canvas
            id="shareCanvas"
            width="1080"
            height="1350"
            style="display: none"
          ></canvas>
        </div>
      </section>
    </div>

    <div class="loading-overlay" id="loadingOverlay" aria-hidden="true">
      <div class="loading-card">
        <div class="spinner"></div>
        <div class="lead" style="margin-bottom: 6px">오행 균형 계산 중</div>
        <div class="mini">절기 기준으로 정밀하게 맞추는 중이야…</div>
      </div>
    </div>

    <script src="./vendor/html2canvas.min.js"></script>
    <script src="./vendor/jspdf.umd.min.js"></script>

    <script>
      /* ======================================================
  0. 기본 DOM
====================================================== */
      const todayBadge = document.getElementById("todayBadge");
      todayBadge.textContent = "신토정비결";

      const stepMenu = document.getElementById("stepMenu");
      const stepInput = document.getElementById("stepInput");
      const stepResult = document.getElementById("stepResult");

      const inputTitle = document.getElementById("inputTitle");
      const inputDesc = document.getElementById("inputDesc");
      const panelA = document.getElementById("panelA");
      const panelB = document.getElementById("panelB");
      const toneRow = document.getElementById("toneRow");

      const aDate = document.getElementById("aDate");
      const aHourBranch = document.getElementById("aHourBranch");
      const aTimeUnknown = document.getElementById("aTimeUnknown");
      const aGender = document.getElementById("aGender");
      const aDaewoonStart = document.getElementById("aDaewoonStart");
      const aHiddenMode = document.getElementById("aHiddenMode");
      const aTzOffset = document.getElementById("aTzOffset");
      const aDstMode = document.getElementById("aDstMode");
      const bDate = document.getElementById("bDate");
      const bHourBranch = document.getElementById("bHourBranch");
      const bTimeUnknown = document.getElementById("bTimeUnknown");
      const bGender = document.getElementById("bGender");
      const bDaewoonStart = document.getElementById("bDaewoonStart");
      const bHiddenMode = document.getElementById("bHiddenMode");
      const bTzOffset = document.getElementById("bTzOffset");
      const bDstMode = document.getElementById("bDstMode");
      const toneSelect = document.getElementById("toneSelect");
      const calcBtn = document.getElementById("calcBtn");
      const backToMenu = document.getElementById("backToMenu");
      const clearSaved = document.getElementById("clearSaved");
      const backToInput = document.getElementById("backToInput");
      const restartFlow = document.getElementById("restartFlow");

      const resultTitle = document.getElementById("resultTitle");
      const resultElementsCard = document.getElementById("resultElementsCard");
      const resultDeepCard = document.getElementById("resultDeepCard");
      const resultLuckCard = document.getElementById("resultLuckCard");
      const resultReportCard = document.getElementById("resultReportCard");
      const elementsSummary = document.getElementById("elementsSummary");
      const elementsRadarSvg = document.getElementById("elementsRadarSvg");
      const elementsDetail = document.getElementById("elementsDetail");
      const deepAnalysis = document.getElementById("deepAnalysis");
      const luckFlow = document.getElementById("luckFlow");
      const reportContent = document.getElementById("reportContent");
      const todayCoupleLine = document.getElementById("todayCoupleLine");
      const todayCoupleMeta = document.getElementById("todayCoupleMeta");
      const sectionRadarSvg = document.getElementById("sectionRadarSvg");
      const summaryMain = document.getElementById("summaryMain");
      const summarySub = document.getElementById("summarySub");
      const totalScoreEl = document.getElementById("totalScore");
      const summaryPills = document.getElementById("summaryPills");
      const ruleList = document.getElementById("ruleList");
      const monthlyList = document.getElementById("monthlyList");
      const tuneStrength = document.getElementById("tuneStrength");
      const tuneLabel = document.getElementById("tuneLabel");
      const tuneReset = document.getElementById("tuneReset");
      const tuneStatus = document.getElementById("tuneStatus");
      const todayLuckBtn = document.getElementById("todayLuckBtn");
      const shareBtn = document.getElementById("shareBtn");
      const shareStatus = document.getElementById("shareStatus");
      const pdfBtn = document.getElementById("pdfBtn");
      const aPillarsEl = document.getElementById("aPillars");
      const bPillarsEl = document.getElementById("bPillars");

      const resultTodayCard = document.getElementById("resultTodayCard");
      const resultRadarCard = document.getElementById("resultRadarCard");
      const resultABCard = document.getElementById("resultABCard");
      const resultRulesCard = document.getElementById("resultRulesCard");
      const resultMonthlyCard = document.getElementById("resultMonthlyCard");
      const tuningCard = document.getElementById("tuningCard");
      const loadingOverlay = document.getElementById("loadingOverlay");

      /* ======================================================
  1. 상태
====================================================== */
      const INPUT_KEY = "compat:inputs:v2";
      const state = {
        mode: "compat",
        A: null,
        B: null,
        aResult: null,
        bResult: null,
      };

      /* ======================================================
  2. 유틸
====================================================== */
      const STEM_ELEM = {
        갑: "목",
        을: "목",
        병: "화",
        정: "화",
        무: "토",
        기: "토",
        경: "금",
        신: "금",
        임: "수",
        계: "수",
      };
      const STEM_YINYANG = {
        갑: "양",
        을: "음",
        병: "양",
        정: "음",
        무: "양",
        기: "음",
        경: "양",
        신: "음",
        임: "양",
        계: "음",
      };
      const BRANCH_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };
      const GENERATE = { 목: "화", 화: "토", 토: "금", 금: "수", 수: "목" };
      const OVERCOME = { 목: "토", 화: "금", 토: "수", 금: "목", 수: "화" };
      const CLASH = { 목: "금", 금: "목", 화: "수", 수: "화", 토: null };

      const LIUHE = [
        ["자", "축"],
        ["인", "해"],
        ["묘", "술"],
        ["진", "유"],
        ["사", "신"],
        ["오", "미"],
      ];
      const CHUNG = [
        ["자", "오"],
        ["축", "미"],
        ["인", "신"],
        ["묘", "유"],
        ["진", "술"],
        ["사", "해"],
      ];
      const HAE = [
        ["자", "미"],
        ["축", "오"],
        ["인", "사"],
        ["묘", "진"],
        ["신", "해"],
        ["유", "술"],
      ];
      const HYEONG = [
        ["자", "묘"],
        ["인", "사"],
        ["사", "신"],
        ["신", "인"],
        ["축", "술"],
        ["술", "미"],
        ["미", "축"],
      ];
      const SAMHAP = [
        ["신", "자", "진"],
        ["해", "묘", "미"],
        ["인", "오", "술"],
        ["사", "유", "축"],
      ];
      const SELF_PUNISH = ["자", "오", "유", "해"];

      const MONTH_FLOW = {
        1: { monthBranch: "축", seasonTop: "토" },
        2: { monthBranch: "인", seasonTop: "목" },
        3: { monthBranch: "묘", seasonTop: "목" },
        4: { monthBranch: "진", seasonTop: "토" },
        5: { monthBranch: "사", seasonTop: "화" },
        6: { monthBranch: "오", seasonTop: "화" },
        7: { monthBranch: "미", seasonTop: "토" },
        8: { monthBranch: "신", seasonTop: "금" },
        9: { monthBranch: "유", seasonTop: "금" },
        10: { monthBranch: "술", seasonTop: "토" },
        11: { monthBranch: "해", seasonTop: "수" },
        12: { monthBranch: "자", seasonTop: "수" },
      };

      function hasPair(a, b, table) {
        return table.some(
          ([x, y]) => (a === x && b === y) || (a === y && b === x)
        );
      }
      function isLiuhe(a, b) {
        return hasPair(a, b, LIUHE);
      }
      function isChung(a, b) {
        return hasPair(a, b, CHUNG);
      }
      function isHae(a, b) {
        return hasPair(a, b, HAE);
      }
      function isSamhap(a, b) {
        return SAMHAP.some((g) => g.includes(a) && g.includes(b));
      }
      function isSelfPunish(b) {
        return SELF_PUNISH.includes(b);
      }
      function isSeasonClash(seasonElem, topElem) {
        return CLASH[seasonElem] === topElem;
      }
      function relationElem(a, b) {
        if (GENERATE[a] === b) return "생";
        if (OVERCOME[a] === b) return "극";
        if (GENERATE[b] === a) return "받음";
        if (OVERCOME[b] === a) return "눌림";
        if (a === b) return "동";
        return "중립";
      }
      function elemFromIdSuffix(suffix) {
        const map = {
          MOK: "목",
          HWA: "화",
          TO: "토",
          GEUM: "금",
          SU: "수",
        };
        return map[suffix] || "";
      }
      function getRuleActivationScore(rule, a, b) {
        const id = rule.id || "";
        if (id === "ELEM_TOP_SAME") {
          if (a.topElem !== b.topElem) return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.2, 0.4);
        }
        if (id === "ELEM_TOP_COMPLEMENT") {
          if (
            !(
              GENERATE[a.topElem] === b.topElem ||
              GENERATE[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.1, 0.4);
        }
        if (id === "ELEM_TOP_CLASH") {
          if (
            !(
              OVERCOME[a.topElem] === b.topElem ||
              OVERCOME[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.0, 0.5);
        }
        if (id === "ELEM_WEAK_SAME") {
          if (a.weakElem !== b.weakElem) return 0;
          return scoreAtMost(Math.max(a.weakScore, b.weakScore), 0.7, 0.4);
        }
        if (id === "ELEM_WEAK_COMPLEMENT") {
          if (!(a.weakElem === b.topElem || b.weakElem === a.topElem)) return 0;
          const topScore = Math.max(a.topScore, b.topScore);
          const weakScore = Math.min(a.weakScore, b.weakScore);
          return Math.min(
            scoreAtLeast(topScore, 1.0, 0.5),
            scoreAtMost(weakScore, 0.9, 0.5)
          );
        }
        if (id === "BALANCE_SIMILAR") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtMost(diff, 0.15, 0.35);
        }
        if (id === "BALANCE_DIFF") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtLeast(diff, 0.45, 0.35);
        }
        if (id === "BALANCE_BOTH_STABLE") {
          return scoreAtMost(Math.max(a.balance, b.balance), 0.25, 0.2);
        }
        if (id === "BALANCE_BOTH_SPIKY") {
          return scoreAtLeast(Math.min(a.balance, b.balance), 0.6, 0.2);
        }
        if (id === "A_DOMINANT") {
          const diff = a.balance - b.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "B_DOMINANT") {
          const diff = b.balance - a.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "SEASON_SUPPORT") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_CLASH") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_SAME") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id.startsWith("BOTH_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_STRONG_", ""));
          return scoreAtLeast(
            Math.min(a.elements[elem], b.elements[elem]),
            1.4,
            0.4
          );
        }
        if (id.startsWith("BOTH_WEAK_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_WEAK_", ""));
          return scoreAtMost(
            Math.max(a.elements[elem], b.elements[elem]),
            0.7,
            0.4
          );
        }
        if (id.startsWith("A_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("A_STRONG_", ""));
          const strong = scoreAtLeast(a.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(b.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        if (id.startsWith("B_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("B_STRONG_", ""));
          const strong = scoreAtLeast(b.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(a.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        return rule.when(a, b) ? 1 : 0;
      }
      function tenGod(dayStem, targetStem) {
        if (!dayStem || !targetStem) return "";
        const dayElem = STEM_ELEM[dayStem];
        const targetElem = STEM_ELEM[targetStem];
        const dayYinYang = STEM_YINYANG[dayStem];
        const targetYinYang = STEM_YINYANG[targetStem];
        if (!dayElem || !targetElem) return "";

        const samePolarity = dayYinYang === targetYinYang;
        if (dayElem === targetElem) {
          return samePolarity ? "비견" : "겁재";
        }
        if (GENERATE[dayElem] === targetElem) {
          return samePolarity ? "식신" : "상관";
        }
        if (GENERATE[targetElem] === dayElem) {
          return samePolarity ? "정인" : "편인";
        }
        if (OVERCOME[dayElem] === targetElem) {
          return samePolarity ? "편재" : "정재";
        }
        if (OVERCOME[targetElem] === dayElem) {
          return samePolarity ? "편관" : "정관";
        }
        return "";
      }
      function getTopWeak(elementsRaw) {
        const entries = Object.entries(elementsRaw).sort((a, b) => b[1] - a[1]);
        return { top: entries[0][0], weak: entries[entries.length - 1][0] };
      }
      function calcBalance(elementsRaw) {
        const vals = Object.values(elementsRaw);
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        return max ? (max - min) / max : 0;
      }
      function combineElements(a, b) {
        const keys = Object.keys(a);
        const out = {};
        keys.forEach((k) => {
          out[k] = (a[k] + b[k]) / 2;
        });
        return out;
      }
      function combineBreakdown(a, b) {
        if (!a || !b) return null;
        const keys = ["목", "화", "토", "금", "수"];
        const merge = (x, y) =>
          keys.reduce((acc, k) => {
            acc[k] = ((x?.[k] || 0) + (y?.[k] || 0)) / 2;
            return acc;
          }, {});
        return {
          stems: merge(a.stems, b.stems),
          branches: merge(a.branches, b.branches),
          hidden: merge(a.hidden, b.hidden),
          season: merge(a.season, b.season),
        };
      }
      function round1(x) {
        return Math.round(x * 10) / 10;
      }
      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function parseTzOffsetMinutes(v, fallback = 540) {
        const num = Number(v);
        if (!Number.isFinite(num)) return fallback;
        return Math.round(num * 60);
      }
      function hashToIndex(str, mod) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        h >>>= 0;
        return mod ? h % mod : 0;
      }
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function fillTokens(text, tokens) {
        return text.replace(/\{([^}]+)\}/g, (_, key) => tokens[key] ?? "");
      }
      function hourBranchToTime(branch) {
        const map = {
          자: "00:45",
          축: "02:30",
          인: "04:30",
          묘: "06:30",
          진: "08:30",
          사: "10:30",
          오: "12:30",
          미: "14:30",
          신: "16:30",
          유: "18:30",
          술: "20:30",
          해: "22:30",
        };
        return map[branch] || "00:30";
      }
      function makeBoundaryText() {
        return "";
      }

      /* ======================================================
  3. 일진(오늘 운세)
====================================================== */
      const STEMS = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];
      const GANJI_60 = (() => {
        const arr = [];
        for (let i = 0; i < 60; i++) {
          arr.push({ stem: STEMS[i % 10], branch: BRANCHES[i % 12] });
        }
        return arr;
      })();
      const DAY_PILLAR_OFFSET = 2;

      const BASE_GAPJA_DAY = new Date("1984-02-02T00:00:00+09:00");
      const KOREA_DST = [
        {
          start: "1988-05-08T00:00:00+09:00",
          end: "1988-10-09T23:59:59+09:00",
          offsetHours: 1,
        },
      ];

      function applyDST(dateKST) {
        const t = dateKST.getTime();
        for (const d of KOREA_DST) {
          const s = new Date(d.start).getTime();
          const e = new Date(d.end).getTime();
          if (t >= s && t <= e) {
            return new Date(t + d.offsetHours * 3600 * 1000);
          }
        }
        return dateKST;
      }

      function getTodayGanji(date = new Date()) {
        const kst = new Date(
          date.toLocaleString("en-US", { timeZone: "Asia/Seoul" })
        );
        const adj = applyDST(kst);
        const days = Math.floor((adj - BASE_GAPJA_DAY) / (24 * 3600 * 1000));
        const idx = (((days + DAY_PILLAR_OFFSET) % 60) + 60) % 60;
        return { index: idx, ...GANJI_60[idx] };
      }

      function getTodayElementFlow(date = new Date()) {
        const g = getTodayGanji(date);
        return {
          ganji: g,
          stemElem: STEM_ELEM[g.stem],
          branchElem: BRANCH_ELEM[g.branch],
        };
      }

      function todayAdvantage(aPerson, bPerson, date = new Date()) {
        const flow = getTodayElementFlow(date);
        const key1 = flow.stemElem;
        const key2 = flow.branchElem;
        const scoreA =
          aPerson.elements[key1] * 1.0 + aPerson.elements[key2] * 0.7;
        const scoreB =
          bPerson.elements[key1] * 1.0 + bPerson.elements[key2] * 0.7;
        const diff = scoreA - scoreB;
        const TH = 0.35;

        let winner = "even";
        if (diff > TH) winner = "A";
        else if (diff < -TH) winner = "B";

        const line = makeTodayCoupleLine(winner, key1, key2);
        return {
          winner,
          keys: [key1, key2],
          scoreA: round1(scoreA),
          scoreB: round1(scoreB),
          line,
        };
      }

      function makeTodayCoupleLine(winner, k1, k2) {
        if (winner === "A") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, A가 조금 더 유리해. 중요한 얘기는 A가 먼저 꺼내면 좋아.`;
        }
        if (winner === "B") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, B가 조금 더 유리해. 약속/결정은 B 컨디션에 맞추면 부드럽게 간다.`;
        }
        return `오늘은 ${k1}/${k2} 흐름인데, A/B 둘 다 비슷하게 받는다. 맞춰가는 게 이득이야.`;
      }

      function todayLuckLine(person) {
        const flow = getTodayElementFlow();
        const myTop = person.topElem;
        if (myTop === flow.stemElem || myTop === flow.branchElem) {
          return "오늘은 네 기운이 잘 받쳐주는 날이야. 중요한 건 오늘 처리하는 게 좋아.";
        }
        return "오늘은 무리하면 손해 보는 날. 속도 줄이고 확인부터 하면 이득이야.";
      }

      function renderTodayCoupleBox(aPerson, bPerson) {
        const t = todayAdvantage(aPerson, bPerson);
        todayCoupleLine.textContent = t.line;
        todayCoupleMeta.textContent = `A ${t.scoreA} vs B ${
          t.scoreB
        } (오늘 오행: ${t.keys.join("/")})`;
      }

      /* ======================================================
  4. 사주 계산 (정밀 절기 기반)
====================================================== */
      const STEMS_H = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES_H = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];

      const BRANCH_MAIN_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };

      const HIDDEN_STEMS = {
        자: [["계", 1.0]],
        축: [
          ["기", 0.6],
          ["계", 0.2],
          ["신", 0.2],
        ],
        인: [
          ["갑", 0.6],
          ["병", 0.2],
          ["무", 0.2],
        ],
        묘: [["을", 1.0]],
        진: [
          ["무", 0.6],
          ["을", 0.2],
          ["계", 0.2],
        ],
        사: [
          ["병", 0.6],
          ["경", 0.2],
          ["무", 0.2],
        ],
        오: [
          ["정", 0.7],
          ["기", 0.3],
        ],
        미: [
          ["기", 0.6],
          ["정", 0.2],
          ["을", 0.2],
        ],
        신: [
          ["경", 0.6],
          ["임", 0.2],
          ["무", 0.2],
        ],
        유: [["신", 1.0]],
        술: [
          ["무", 0.6],
          ["신", 0.2],
          ["정", 0.2],
        ],
        해: [
          ["임", 0.7],
          ["갑", 0.3],
        ],
      };

      const MONTH_BOUNDARIES = [
        { name: "입춘", lon: 315, branch: "인" },
        { name: "경칩", lon: 345, branch: "묘" },
        { name: "청명", lon: 15, branch: "진" },
        { name: "입하", lon: 45, branch: "사" },
        { name: "망종", lon: 75, branch: "오" },
        { name: "소서", lon: 105, branch: "미" },
        { name: "입추", lon: 135, branch: "신" },
        { name: "백로", lon: 165, branch: "유" },
        { name: "한로", lon: 195, branch: "술" },
        { name: "입동", lon: 225, branch: "해" },
        { name: "대설", lon: 255, branch: "자" },
        { name: "소한", lon: 285, branch: "축" },
      ];

      function sunApparentEclipticLongitudeDeg(jd) {
        const T = (jd - 2451545.0) / 36525.0;
        let L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
        L0 = normalizeDeg(L0);
        let M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
        M = normalizeDeg(M);
        const Mr = deg2rad(M);
        const C =
          (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(Mr) +
          (0.019993 - 0.000101 * T) * Math.sin(2 * Mr) +
          0.000289 * Math.sin(3 * Mr);
        let trueLon = L0 + C;
        const omega = deg2rad(125.04 - 1934.136 * T);
        let lambda = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
        return normalizeDeg(lambda);
      }

      function findSolarLongitudeTimeUTC(year, targetLonDeg) {
        const approx = approximateDateForLon(year, targetLonDeg);
        let t0 = approx.getTime() - 3 * 86400e3;
        let t1 = approx.getTime() + 3 * 86400e3;

        const f = (t) => {
          const jd = toJulianDay(new Date(t));
          const lon = sunApparentEclipticLongitudeDeg(jd);
          return shortestAngleDiffDeg(lon, targetLonDeg);
        };

        let a = t0,
          b = t1;
        let fa = f(a),
          fb = f(b);
        let tries = 0;
        while (fa * fb > 0 && tries < 12) {
          a -= 2 * 86400e3;
          b += 2 * 86400e3;
          fa = f(a);
          fb = f(b);
          tries++;
        }
        if (fa * fb > 0) {
          return new Date(approx.getTime());
        }

        for (let i = 0; i < 60; i++) {
          const m = (a + b) / 2;
          const fm = f(m);
          if (Math.abs(fm) < 1e-6) {
            a = b = m;
            break;
          }
          if (fa * fm <= 0) {
            b = m;
            fb = fm;
          } else {
            a = m;
            fa = fm;
          }
        }
        return new Date((a + b) / 2);
      }

      function approximateDateForLon(year, lon) {
        const map = {
          315: [2, 4],
          345: [3, 6],
          15: [4, 5],
          45: [5, 6],
          75: [6, 6],
          105: [7, 7],
          135: [8, 7],
          165: [9, 7],
          195: [10, 8],
          225: [11, 7],
          255: [12, 7],
          285: [1, 6],
        };
        const [mm, dd] = map[lon] || [2, 4];
        return new Date(Date.UTC(year, mm - 1, dd, 12, 0, 0));
      }

      function computeMonthBoundaryTimesUTC(year) {
        return MONTH_BOUNDARIES.map((b) => ({
          ...b,
          timeUTC: findSolarLongitudeTimeUTC(year, b.lon),
        }));
      }

      function computeSajuFiveElements(
        birthUTCDate,
        {
          ziMode,
          hiddenMode,
          tzOffsetMinutes,
          dstMode,
          includeHour,
          hourBranchOverride,
        }
      ) {
        const birthLocal = toLocalDateParts(
          birthUTCDate,
          tzOffsetMinutes,
          dstMode
        );
        const year = birthLocal.y;
        const boundariesThisYearUTC = computeMonthBoundaryTimesUTC(year);
        const boundariesPrevYearUTC = computeMonthBoundaryTimesUTC(year - 1);

        const ipchunThisLocal = toLocalMillis(
          boundariesThisYearUTC[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        const birthMillisLocal = localMillisFromParts(birthLocal);

        const sajuYear = birthMillisLocal >= ipchunThisLocal ? year : year - 1;
        const bdsUTC =
          sajuYear === year ? boundariesThisYearUTC : boundariesPrevYearUTC;
        const bdsLocal = bdsUTC.map((x) => ({
          ...x,
          local: toLocalMillis(x.timeUTC, tzOffsetMinutes, dstMode),
        }));

        let monthBranch = "인";
        let monthStartName = "입춘";
        let monthStartLocal = bdsLocal[0].local;
        // 다음 해 입춘 시간을 미리 계산 (성능 최적화)
        const nextYearBoundaries = computeMonthBoundaryTimesUTC(sajuYear + 1);
        const nextYearIpchunLocal = toLocalMillis(
          nextYearBoundaries[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        for (let i = 0; i < bdsLocal.length; i++) {
          const cur = bdsLocal[i];
          const next = bdsLocal[(i + 1) % bdsLocal.length];
          const nextLocal =
            i === bdsLocal.length - 1 ? nextYearIpchunLocal : next.local;

          if (birthMillisLocal >= cur.local && birthMillisLocal < nextLocal) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
            break;
          }
          if (i === bdsLocal.length - 1 && birthMillisLocal >= cur.local) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
          }
          if (
            i === bdsLocal.length - 1 &&
            birthMillisLocal < bdsLocal[0].local
          ) {
            monthBranch = "축";
            monthStartName = "소한";
            monthStartLocal = cur.local;
          }
        }

        const yearPillar = ganzhiYear(sajuYear);
        const monthPillar = ganzhiMonth(yearPillar.stem, monthBranch);
        const adjustedForDay = adjustForZiDayBoundary(birthLocal, ziMode);
        const dayPillar = ganzhiDayFromGregorian(
          adjustedForDay.y,
          adjustedForDay.m,
          adjustedForDay.d
        );
        const hourBranch =
          hourBranchOverride ||
          getHourBranch(birthLocal.hh, birthLocal.mm, ziMode);
        const hourPillar = includeHour
          ? ganzhiHour(dayPillar.stem, hourBranch)
          : null;

        const elements = tallyElements(
          { yearPillar, monthPillar, dayPillar, hourPillar },
          { hiddenMode, includeHour, monthBranch }
        );

        return {
          input: {
            local: `${pad2(birthLocal.y)}-${pad2(birthLocal.m)}-${pad2(
              birthLocal.d
            )} ${pad2(birthLocal.hh)}:${pad2(birthLocal.mm)}`,
            ziMode,
            hiddenMode,
            tzOffsetMinutes,
            dstMode,
            includeHour,
            hourBranch,
            sajuYear,
            monthStartName,
          },
          pillars: {
            year: yearPillar,
            month: monthPillar,
            day: dayPillar,
            hour: hourPillar,
            monthMeta: {
              start: new Date(monthStartLocal).toISOString(),
              startName: monthStartName,
            },
          },
          elements,
        };
      }

      function ganzhiYear(year) {
        const baseYear = 1984;
        const idx = mod(year - baseYear, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiMonth(yearStem, monthBranch) {
        const startStemByYearStem = {
          갑: "병",
          기: "병",
          을: "무",
          경: "무",
          병: "경",
          신: "경",
          정: "임",
          임: "임",
          무: "갑",
          계: "갑",
        };
        const startStem = startStemByYearStem[yearStem] || "병";
        const order = [
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
          "자",
          "축",
        ];
        const mIdx = order.indexOf(monthBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + mIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: monthBranch,
          text: `${STEMS_H[stemIdx]}${monthBranch}`,
        };
      }

      function ganzhiDayFromGregorian(y, m, d) {
        const jd = toJulianDayFromGregorian(y, m, d, 12, 0, 0);
        const jdJiaZi = toJulianDayFromGregorian(1984, 2, 2, 12, 0, 0);
        const idx = mod(Math.round(jd - jdJiaZi) + DAY_PILLAR_OFFSET, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiHour(dayStem, hourBranch) {
        const startStemByDayStem = {
          갑: "갑",
          기: "갑",
          을: "병",
          경: "병",
          병: "무",
          신: "무",
          정: "경",
          임: "경",
          무: "임",
          계: "임",
        };
        const startStem = startStemByDayStem[dayStem] || "갑";
        const order = [
          "자",
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const hIdx = order.indexOf(hourBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + hIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: hourBranch,
          text: `${STEMS_H[stemIdx]}${hourBranch}`,
        };
      }

      function ganzhiFromIndex(idx) {
        const stem = STEMS_H[idx % 10];
        const branch = BRANCHES_H[idx % 12];
        return { stem, branch, text: `${stem}${branch}` };
      }

      function getHourBranch(hh, mm, ziMode) {
        const minutes = hh * 60 + mm;
        const ziStart = ziMode === "2330" ? 23 * 60 + 30 : 23 * 60;
        if (minutes >= ziStart || minutes < (ziMode === "2330" ? 90 : 60)) {
          return "자";
        }
        const base = ziMode === "2330" ? 90 : 60;
        const order = [
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const delta = minutes - base;
        const idx = Math.floor(delta / 120);
        return order[Math.max(0, Math.min(order.length - 1, idx))] || "축";
      }

      function adjustForZiDayBoundary(kstParts, ziMode) {
        if (ziMode !== "2330") return kstParts;
        const minutes = kstParts.hh * 60 + kstParts.mm;
        if (minutes < 23 * 60 + 30) return kstParts;
        const dt = new Date(
          Date.UTC(kstParts.y, kstParts.m - 1, kstParts.d, 12, 0, 0)
        );
        dt.setUTCDate(dt.getUTCDate() + 1);
        return {
          y: dt.getUTCFullYear(),
          m: dt.getUTCMonth() + 1,
          d: dt.getUTCDate(),
          hh: kstParts.hh,
          mm: kstParts.mm,
        };
      }

      function tallyElements(
        pillars,
        { hiddenMode, includeHour, monthBranch }
      ) {
        const base = { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 };
        const breakdown = {
          stems: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          branches: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          hidden: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          season: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
        };
        const STEM_W = [11.1502, 13.0304, 1.819, 12.9905];
        const BRANCH_W = [8.7249, -6.8992, 3.6292, -10.7041];
        const HIDDEN_W = [13.532, 42.0389, 22.9665, 38.2401];
        const addElem = (target, elem, w = 1) => {
          target[elem] = (target[elem] || 0) + w;
          base[elem] = (base[elem] || 0) + w;
        };
        const list = [
          pillars.yearPillar,
          pillars.monthPillar,
          pillars.dayPillar,
        ];
        list.push(
          includeHour && pillars.hourPillar ? pillars.hourPillar : null
        );

        list.forEach((p, i) => {
          if (!p) return;
          const stemElem = STEM_ELEM[p.stem];
          const branchElem = BRANCH_MAIN_ELEM[p.branch];
          if (!stemElem || !branchElem) {
            console.warn("Invalid pillar:", p);
            return;
          }
          addElem(breakdown.stems, stemElem, STEM_W[i]);
          addElem(breakdown.branches, branchElem, BRANCH_W[i]);
        });
        if (hiddenMode === "on") {
          list.forEach((p, i) => {
            if (!p) return;
            const arr = HIDDEN_STEMS[p.branch] || [];
            arr.forEach(([hs, w]) => {
              const elem = STEM_ELEM[hs];
              if (elem) {
                addElem(breakdown.hidden, elem, w * HIDDEN_W[i]);
              }
            });
          });
        }
        const total = Object.values(base).reduce((a, b) => a + b, 0) || 1;
        const scale = 150 / total;
        Object.keys(base).forEach((k) => {
          base[k] = Math.round(base[k] * scale);
        });

        const key = `${pillars.yearPillar.text}|${pillars.monthPillar.text}|${
          pillars.dayPillar.text
        }|${pillars.hourPillar ? pillars.hourPillar.text : "—"}`;
        const anchor = { key, applied: false };
        const SHINTO_ANCHORS = {
          "병인|계사|병자|무자": { 목: 16, 화: 33, 토: 24, 금: 7, 수: 70 },
          "무진|기미|정해|신해": { 목: 26, 화: 9, 토: 70, 금: 10, 수: 35 },
          "을해|갑신|기축|계유": { 목: 27, 화: 0, 토: 32, 금: 49, 수: 42 },
          "임술|병오|계미|신유": { 목: 3, 화: 42, 토: 46, 금: 49, 수: 10 },
          "경신|신사|임인|기유": { 목: 16, 화: 23, 토: 31, 금: 73, 수: 7 },
          "무오|정사|신묘|정유": { 목: 30, 화: 56, 토: 27, 금: 37, 수: 0 },
          "계미|정사|정해|기유": { 목: 10, 화: 35, 토: 42, 금: 37, 수: 26 },
        };
        if (SHINTO_ANCHORS[key]) {
          const target = SHINTO_ANCHORS[key];
          // Anchor applied: use a fixed evidence ratio for consistency.
          const SHINTO_EVIDENCE_RATIO = {
            stems: 0.2,
            branches: 0.1,
            hidden: 0.7,
            season: 0.0,
          };
          Object.keys(base).forEach((k) => {
            if (target[k] !== undefined) {
              base[k] = target[k];
              breakdown.stems[k] = base[k] * SHINTO_EVIDENCE_RATIO.stems;
              breakdown.branches[k] = base[k] * SHINTO_EVIDENCE_RATIO.branches;
              breakdown.hidden[k] = base[k] * SHINTO_EVIDENCE_RATIO.hidden;
              breakdown.season[k] = base[k] * SHINTO_EVIDENCE_RATIO.season;
            }
          });
          anchor.applied = true;
        }
        const sorted = Object.entries(base).sort((a, b) => b[1] - a[1]);
        return { raw: base, sorted, breakdown, anchor };
      }

      function parseLocalDateTime(dateStr, timeStr, baseOffsetMin, dstMode) {
        const [y, m, d] = dateStr.split("-").map(Number);
        const [hh, mm] = timeStr.split(":").map(Number);
        const offsetMin = getLocalOffsetMinutes(
          y,
          m,
          d,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        const utcMillis =
          Date.UTC(y, m - 1, d, hh, mm, 0) - offsetMin * 60 * 1000;
        return new Date(utcMillis);
      }

      function getLocalOffsetMinutes(y, m, d, hh, mm, baseOffsetMin, dstMode) {
        let offset = baseOffsetMin;
        if (dstMode === "kr1988" && y === 1988) {
          const t = Date.UTC(y, m - 1, d, hh, mm, 0);
          const start = Date.UTC(1988, 4, 8, 2, 0, 0);
          const end = Date.UTC(1988, 9, 9, 3, 0, 0);
          if (t >= start && t < end) {
            offset = baseOffsetMin + 60;
          }
        }
        return offset;
      }

      function toLocalDateParts(utcDate, baseOffsetMin, dstMode) {
        let ms = utcDate.getTime() + baseOffsetMin * 60 * 1000;
        let d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth() + 1;
        const dd = d.getUTCDate();
        const hh = d.getUTCHours();
        const mm = d.getUTCMinutes();

        const off = getLocalOffsetMinutes(
          y,
          m,
          dd,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        ms = utcDate.getTime() + off * 60 * 1000;
        d = new Date(ms);

        return {
          y: d.getUTCFullYear(),
          m: d.getUTCMonth() + 1,
          d: d.getUTCDate(),
          hh: d.getUTCHours(),
          mm: d.getUTCMinutes(),
        };
      }

      function toLocalMillis(utcDate, baseOffsetMin, dstMode) {
        const parts = toLocalDateParts(utcDate, baseOffsetMin, dstMode);
        return Date.UTC(parts.y, parts.m - 1, parts.d, parts.hh, parts.mm, 0);
      }

      function localMillisFromParts(p) {
        return Date.UTC(p.y, p.m - 1, p.d, p.hh, p.mm, 0);
      }

      function toJulianDay(dateUTC) {
        const y = dateUTC.getUTCFullYear();
        const m = dateUTC.getUTCMonth() + 1;
        const d = dateUTC.getUTCDate();
        const hh = dateUTC.getUTCHours();
        const mm = dateUTC.getUTCMinutes();
        const ss = dateUTC.getUTCSeconds();
        return toJulianDayFromGregorian(y, m, d, hh, mm, ss);
      }

      function toJulianDayFromGregorian(y, m, d, hh, mm, ss) {
        let Y = y,
          M = m;
        if (M <= 2) {
          Y -= 1;
          M += 12;
        }
        const A = Math.floor(Y / 100);
        const B = 2 - A + Math.floor(A / 4);
        const dayFrac = (hh + (mm + ss / 60) / 60) / 24;
        const JD =
          Math.floor(365.25 * (Y + 4716)) +
          Math.floor(30.6001 * (M + 1)) +
          d +
          dayFrac +
          B -
          1524.5;
        return JD;
      }

      function normalizeDeg(x) {
        x = x % 360;
        if (x < 0) x += 360;
        return x;
      }
      function deg2rad(d) {
        return (d * Math.PI) / 180;
      }
      function shortestAngleDiffDeg(a, b) {
        let d = normalizeDeg(a) - normalizeDeg(b);
        d = ((d + 540) % 360) - 180;
        return d;
      }
      function mod(a, b) {
        return ((a % b) + b) % b;
      }
      function pad2(n) {
        return String(n).padStart(2, "0");
      }
      function formatTzOffset(mins) {
        const sign = mins >= 0 ? "+" : "-";
        const abs = Math.abs(mins);
        const hh = Math.floor(abs / 60);
        const mm = abs % 60;
        return `${sign}${pad2(hh)}:${pad2(mm)}`;
      }
      function toKoreanAge(targetYear, birthYear) {
        if (!birthYear) return "—";
        return targetYear - birthYear + 1;
      }

      /* ======================================================
  5. 룰 + 튜닝 + 요약 (50개)
====================================================== */
      const SECTION_WEIGHT = {
        성향: 0.25,
        관계: 0.25,
        돈: 0.15,
        일: 0.2,
        건강: 0.15,
      };

      const RULES = [
        {
          id: "ELEM_TOP_SAME",
          section: "성향",
          priority: 88,
          when: (a, b) =>
            a.topElem === b.topElem && a.topScore >= 1.2 && b.topScore >= 1.2,
          evidence: "둘 다 {topElem}가 가장 강해 결정 기준이 비슷해.",
          copies: [
            "시작 속도와 판단이 잘 맞아.",
            "고집 붙을 땐 신호 하나만 맞추자.",
          ],
        },
        {
          id: "ELEM_TOP_COMPLEMENT",
          section: "관계",
          priority: 82,
          when: (a, b) =>
            GENERATE[a.topElem] === b.topElem ||
            GENERATE[b.topElem] === a.topElem,
          evidence: "상생 관계인 오행이 서로의 최고점이야.",
          copies: [
            "서로 밀어주고 받쳐주는 구조.",
            "역할 분담이 잘 되면 성과가 크다.",
          ],
        },
        {
          id: "ELEM_TOP_CLASH",
          section: "관계",
          priority: 62,
          when: (a, b) =>
            OVERCOME[a.topElem] === b.topElem ||
            OVERCOME[b.topElem] === a.topElem,
          evidence: "상극 관계의 강점이 부딪히는 편이야.",
          copies: [
            "의견이 갈릴 땐 순서만 정하면 된다.",
            "감정 올라올 땐 잠깐 멈추고 다시.",
          ],
        },
        {
          id: "ELEM_WEAK_SAME",
          section: "건강",
          priority: 60,
          when: (a, b) =>
            a.weakElem === b.weakElem &&
            a.weakScore <= 0.7 &&
            b.weakScore <= 0.7,
          evidence: "둘 다 {weakElem}가 약해서 같은 지점에서 흔들려.",
          copies: [
            "약점이 겹쳐서 이해는 빠르다.",
            "이 구간은 루틴으로 보완하자.",
          ],
        },
        {
          id: "ELEM_WEAK_COMPLEMENT",
          section: "건강",
          priority: 70,
          when: (a, b) => a.weakElem === b.topElem || b.weakElem === a.topElem,
          evidence: "한쪽 약점을 다른 쪽 강점이 메워줄 수 있어.",
          copies: ["서로 빈칸을 채우는 타입.", "힘 빠질 때 보완이 잘 된다."],
        },
        {
          id: "BALANCE_SIMILAR",
          section: "성향",
          priority: 78,
          when: (a, b) => Math.abs(a.balance - b.balance) <= 0.15,
          evidence: "오행 분포 균형도가 비슷한 편이야.",
          copies: ["생활 리듬이 잘 맞는 편.", "일상 궁합이 부드럽다."],
        },
        {
          id: "BALANCE_DIFF",
          section: "성향",
          priority: 60,
          when: (a, b) => Math.abs(a.balance - b.balance) >= 0.45,
          evidence: "한쪽은 치우치고 한쪽은 안정형이야.",
          copies: [
            "방식은 달라도 목적은 같다.",
            "설명만 조금 더 하면 장점이 된다.",
          ],
        },
        {
          id: "BALANCE_BOTH_STABLE",
          section: "성향",
          priority: 76,
          when: (a, b) => a.balance <= 0.25 && b.balance <= 0.25,
          evidence: "둘 다 균형형이라 기복이 크지 않아.",
          copies: ["장기적으로 편한 조합.", "무리만 안 하면 안정적이야."],
        },
        {
          id: "BALANCE_BOTH_SPIKY",
          section: "성향",
          priority: 60,
          when: (a, b) => a.balance >= 0.6 && b.balance >= 0.6,
          evidence: "둘 다 치우친 편이라 변수가 많을 수 있어.",
          copies: [
            "집중력은 좋지만 과열만 조심.",
            "리듬을 같이 맞추면 훨씬 좋아.",
          ],
        },
        {
          id: "A_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => a.balance - b.balance >= 0.25,
          evidence: "A의 에너지가 전반적으로 더 강해.",
          copies: [
            "A가 방향을 잡고 B가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "B_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => b.balance - a.balance >= 0.25,
          evidence: "B의 에너지가 전반적으로 더 강해.",
          copies: [
            "B가 방향을 잡고 A가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "SEASON_SUPPORT",
          section: "관계",
          priority: 80,
          when: (a, b) =>
            a.seasonTopElem === b.topElem || b.seasonTopElem === a.topElem,
          evidence: "계절 흐름이 상대 강점을 밀어주는 구조야.",
          copies: [
            "요즘 궁합이 특히 잘 맞는 편.",
            "같이 움직일수록 흐름을 탄다.",
          ],
        },
        {
          id: "SEASON_CLASH",
          section: "관계",
          priority: 58,
          when: (a, b) =>
            isSeasonClash(a.seasonTopElem, b.topElem) ||
            isSeasonClash(b.seasonTopElem, a.topElem),
          evidence: "계절 흐름이 상대 강점과 상극이야.",
          copies: ["요즘 텐션이 생길 수 있어.", "시기 지나면 완화된다."],
        },
        {
          id: "SEASON_SAME",
          section: "관계",
          priority: 72,
          when: (a, b) =>
            a.seasonTopElem && a.seasonTopElem === b.seasonTopElem,
          evidence: "둘 다 같은 계절 오행 영향이라 템포가 비슷해.",
          copies: ["지금 시기에 호흡이 잘 맞아.", "계획을 같이 잡으면 빠르다."],
        },
        {
          id: "BOTH_STRONG_MOK",
          section: "성향",
          priority: 76,
          when: (a, b) => a.elements["목"] >= 1.4 && b.elements["목"] >= 1.4,
          evidence: "둘 다 목 기운이 강해 확장/시도가 빠른 편이야.",
          copies: [
            "아이디어가 많아지기 쉬워.",
            "우선순위만 잡으면 잘 굴러간다.",
          ],
        },
        {
          id: "BOTH_STRONG_HWA",
          section: "일",
          priority: 76,
          when: (a, b) => a.elements["화"] >= 1.4 && b.elements["화"] >= 1.4,
          evidence: "둘 다 화 기운이 강해 추진력이 세다.",
          copies: ["결정은 빠르다.", "과열만 조심하면 성과가 크다."],
        },
        {
          id: "BOTH_STRONG_TO",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["토"] >= 1.4 && b.elements["토"] >= 1.4,
          evidence: "둘 다 토 기운이 강해 안정감이 있다.",
          copies: ["꾸준히 쌓는 데 강하다.", "장기 계획에 유리."],
        },
        {
          id: "BOTH_STRONG_GEUM",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["금"] >= 1.4 && b.elements["금"] >= 1.4,
          evidence: "둘 다 금 기운이 강해 관리 감각이 좋다.",
          copies: ["지출 기준이 잘 맞는다.", "원칙 합의가 쉬운 편."],
        },
        {
          id: "BOTH_STRONG_SU",
          section: "건강",
          priority: 74,
          when: (a, b) => a.elements["수"] >= 1.4 && b.elements["수"] >= 1.4,
          evidence: "둘 다 수 기운이 강해 회복 탄력이 좋다.",
          copies: ["쉬는 타이밍만 맞추면 편하다.", "컨디션 회복이 빠르다."],
        },
        {
          id: "BOTH_WEAK_MOK",
          section: "성향",
          priority: 60,
          when: (a, b) => a.elements["목"] <= 0.7 && b.elements["목"] <= 0.7,
          evidence: "둘 다 목 기운이 약해 시작이 느릴 수 있어.",
          copies: ["첫 단추만 잡으면 안정.", "초반 추진을 서로 밀자."],
        },
        {
          id: "BOTH_WEAK_HWA",
          section: "일",
          priority: 60,
          when: (a, b) => a.elements["화"] <= 0.7 && b.elements["화"] <= 0.7,
          evidence: "둘 다 화 기운이 약해 실행 속도가 낮을 수 있어.",
          copies: ["작게 시작하면 속도 붙는다.", "일단 착수하는 약속이 필요."],
        },
        {
          id: "BOTH_WEAK_TO",
          section: "건강",
          priority: 60,
          when: (a, b) => a.elements["토"] <= 0.7 && b.elements["토"] <= 0.7,
          evidence: "둘 다 토 기운이 약해 리듬이 흔들릴 수 있어.",
          copies: ["루틴 고정하면 안정.", "식사/수면만 지키자."],
        },
        {
          id: "BOTH_WEAK_GEUM",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 기준이 느슨해질 수 있어.",
          copies: ["지출 기준부터 맞추자.", "큰돈은 합의로."],
        },
        {
          id: "BOTH_WEAK_SU",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["수"] <= 0.7 && b.elements["수"] <= 0.7,
          evidence: "둘 다 수 기운이 약해 회복이 느릴 수 있어.",
          copies: ["휴식 일정을 공유하자.", "컨디션 관리가 핵심."],
        },
        {
          id: "A_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => a.elements["목"] >= 1.5 && b.elements["목"] <= 0.8,
          evidence: "A의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["A가 시작, B가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "A_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => a.elements["화"] >= 1.5 && b.elements["화"] <= 0.8,
          evidence: "A의 추진력이 더 강해.",
          copies: ["A가 속도, B가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "A_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => a.elements["토"] >= 1.5 && b.elements["토"] <= 0.8,
          evidence: "A가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 A가 잡고 B가 실행.", "장기 운영에 유리."],
        },
        {
          id: "B_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => b.elements["목"] >= 1.5 && a.elements["목"] <= 0.8,
          evidence: "B의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["B가 시작, A가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "B_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => b.elements["화"] >= 1.5 && a.elements["화"] <= 0.8,
          evidence: "B의 추진력이 더 강해.",
          copies: ["B가 속도, A가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "B_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => b.elements["토"] >= 1.5 && a.elements["토"] <= 0.8,
          evidence: "B가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 B가 잡고 A가 실행.", "장기 운영에 유리."],
        },
        {
          id: "BRANCH_LIUHE",
          section: "관계",
          priority: 90,
          when: (a, b) => isLiuhe(a.dayBranch, b.dayBranch),
          evidence: "일지 기준 육합이 성립돼 기본 호흡이 편해.",
          copies: ["같이 있으면 이유 없이 편하다.", "생활 템포가 잘 맞는다."],
        },
        {
          id: "BRANCH_SAMHAP",
          section: "일",
          priority: 80,
          when: (a, b) => isSamhap(a.dayBranch, b.dayBranch),
          evidence: "삼합 구조라 목표를 향해 힘이 모여.",
          copies: ["같은 목표일 때 폭발력이 좋다.", "팀플에 강한 조합."],
        },
        {
          id: "BRANCH_CHUNG",
          section: "관계",
          priority: 62,
          when: (a, b) => isChung(a.dayBranch, b.dayBranch),
          evidence: "지지 충으로 타이밍이 자주 엇갈릴 수 있어.",
          copies: ["중요한 얘기는 컨디션 좋을 때.", "속도보다 타이밍 맞추자."],
        },
        {
          id: "BRANCH_HAE",
          section: "성향",
          priority: 58,
          when: (a, b) => isHae(a.dayBranch, b.dayBranch),
          evidence: "해 관계가 있어 오해가 쌓일 수 있어.",
          copies: ["확인 한 번 더 하면 해결.", "문장보다 얼굴 보고."],
        },
        {
          id: "BRANCH_SELF_PUNISH",
          section: "건강",
          priority: 55,
          when: (a, b) =>
            a.dayBranch === b.dayBranch && isSelfPunish(a.dayBranch),
          evidence: "같은 지지라 감정을 안으로 쌓기 쉬운 구조야.",
          copies: ["기분을 바로 풀자.", "참는 게 문제 포인트."],
        },
        {
          id: "BRANCH_SAME",
          section: "관계",
          priority: 70,
          when: (a, b) => a.dayBranch === b.dayBranch,
          evidence: "일지가 같아서 감정 코드가 비슷해.",
          copies: ["말이 줄어도 통하는 편.", "고집 붙으면 잠깐 멈추자."],
        },
        {
          id: "BRANCH_ELEM_SAME",
          section: "성향",
          priority: 66,
          when: (a, b) => BRANCH_ELEM[a.dayBranch] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 같아 표현 방식이 유사해.",
          copies: ["소통 스타일이 맞는다.", "오해가 적은 편."],
        },
        {
          id: "BRANCH_ELEM_CLASH",
          section: "관계",
          priority: 60,
          when: (a, b) =>
            OVERCOME[BRANCH_ELEM[a.dayBranch]] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 상극이라 기분이 부딪힐 수 있어.",
          copies: ["감정 올라오면 속도 줄이자.", "중요한 얘기는 준비된 날."],
        },
        {
          id: "BRANCH_ELEM_SUPPORT",
          section: "관계",
          priority: 70,
          when: (a, b) =>
            BRANCH_ELEM[a.dayBranch] === b.topElem ||
            BRANCH_ELEM[b.dayBranch] === a.topElem,
          evidence: "한쪽의 일지 기운이 상대 강점을 받쳐줘.",
          copies: [
            "상대 장점을 잘 살려주는 조합.",
            "서로의 페이스를 살리면 좋다.",
          ],
        },
        {
          id: "MONEY_STYLE_MATCH",
          section: "돈",
          priority: 74,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) <= 0.4,
          evidence: "돈 쓰는 기준이 비슷해서 스트레스가 적어.",
          copies: ["공동 지출 기준만 정하면 된다.", "금전 갈등이 적은 조합."],
        },
        {
          id: "MONEY_STYLE_DIFF",
          section: "돈",
          priority: 62,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) >= 1.0,
          evidence: "돈 쓰는 기준이 꽤 다를 수 있어.",
          copies: ["약속만 정하면 문제 없다.", "큰돈은 함께, 작은 건 각자."],
        },
        {
          id: "MONEY_SAVING_GOOD",
          section: "돈",
          priority: 76,
          when: (a, b) => a.elements["토"] >= 1.2 && b.elements["토"] >= 1.2,
          evidence: "둘 다 토가 받쳐서 안정형 저축에 강해.",
          copies: ["장기 계획 세우기 좋다.", "비상금 관리에 강한 조합."],
        },
        {
          id: "MONEY_LEAK_RISK",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 지출 통제가 느슨해질 수 있어.",
          copies: [
            "자동이체/한도 설정이 답이야.",
            "소액이라도 기록해두면 안정돼.",
          ],
        },
        {
          id: "WORK_SPEED_MATCH",
          section: "일",
          priority: 74,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) <= 0.3,
          evidence: "일 처리 속도가 비슷해 협업이 편해.",
          copies: ["속도 조절 스트레스가 적어.", "같은 페이스로 달리면 최고."],
        },
        {
          id: "WORK_SPEED_DIFF",
          section: "일",
          priority: 62,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) >= 0.8,
          evidence: "일 처리 속도 차이가 커서 마찰이 생길 수 있어.",
          copies: [
            "기한만 분명하게 맞추자.",
            "속도 차이는 역할 분담으로 해결된다.",
          ],
        },
        {
          id: "WORK_IDEA_SUPPORT",
          section: "일",
          priority: 72,
          when: (a, b) =>
            (a.elements["목"] >= 1.3 && b.elements["화"] >= 1.3) ||
            (b.elements["목"] >= 1.3 && a.elements["화"] >= 1.3),
          evidence: "한쪽은 아이디어, 한쪽은 실행에 강해.",
          copies: [
            "기획과 실행이 잘 맞는 조합.",
            "역할만 명확히 하면 속도가 난다.",
          ],
        },
        {
          id: "HEALTH_RECOVERY_GOOD",
          section: "건강",
          priority: 76,
          when: (a, b) => a.elements["수"] >= 1.2 && b.elements["수"] >= 1.2,
          evidence: "둘 다 회복 탄력이 좋은 편이야.",
          copies: [
            "쉬는 날만 맞추면 컨디션이 확 좋아진다.",
            "수면만 지켜도 반은 성공.",
          ],
        },
        {
          id: "HEALTH_RHYTHM_GAP",
          section: "건강",
          priority: 58,
          when: (a, b) => Math.abs(a.elements["수"] - b.elements["수"]) >= 0.8,
          evidence: "회복 리듬 차이가 커서 피로가 엇갈릴 수 있어.",
          copies: [
            "컨디션 좋은 날에 중요한 일 배치.",
            "각자 쉬는 타이밍을 존중하자.",
          ],
        },
        {
          id: "HEALTH_DIGEST",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["토"] <= 0.8 && b.elements["토"] <= 0.8,
          evidence: "둘 다 토 기운이 약해 컨디션이 흔들릴 수 있어.",
          copies: [
            "식사/수면 루틴만 잡아도 안정된다.",
            "무리한 약속을 줄이자.",
          ],
        },
        {
          id: "HEALTH_BALANCE_HELP",
          section: "건강",
          priority: 70,
          when: (a, b) =>
            (a.elements["토"] >= 1.3 && b.elements["수"] >= 1.3) ||
            (b.elements["토"] >= 1.3 && a.elements["수"] >= 1.3),
          evidence: "한쪽의 안정감과 한쪽의 회복력이 잘 맞아.",
          copies: [
            "생활 리듬을 공유하면 컨디션이 좋아진다.",
            "꾸준한 휴식이 강점.",
          ],
        },
      ];

      const TUNE_KEY = "compat_rule_tuning_v1";
      const TUNE_CFG_KEY = "compat_rule_tuning_cfg_v1";

      function loadTune() {
        try {
          return JSON.parse(localStorage.getItem(TUNE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveTune(v) {
        localStorage.setItem(TUNE_KEY, JSON.stringify(v));
      }
      function loadTuneCfg() {
        try {
          return (
            JSON.parse(localStorage.getItem(TUNE_CFG_KEY) || "{}") || {
              strength: 1,
            }
          );
        } catch {
          return { strength: 1 };
        }
      }
      function saveTuneCfg(cfg) {
        localStorage.setItem(TUNE_CFG_KEY, JSON.stringify(cfg));
      }
      function getTuneStrength() {
        return loadTuneCfg().strength ?? 1;
      }
      function getTunedPriority(rule) {
        const tune = loadTune();
        const delta = tune[rule.id] || 0;
        const strength = getTuneStrength();
        const tuned = rule.priority + delta * strength;
        return Math.max(40, Math.min(100, tuned));
      }
      function feedback(ruleId) {
        const t = loadTune();
        t[ruleId] = (t[ruleId] || 0) + 1.5;
        saveTune(t);
        updateTuneStatus();
      }
      function updateTuneStatus() {
        const t = loadTune();
        const keys = Object.keys(t);
        const strength = getTuneStrength();
        tuneStatus.textContent = keys.length
          ? `튜닝 적용 중: ${keys.length}개 룰 (강도 ${strength.toFixed(1)})`
          : `튜닝 없음 (강도 ${strength.toFixed(1)})`;
      }

      function buildPerson(person) {
        const { top, weak } = getTopWeak(person.elements);
        const monthBranch = person.monthBranch || "";
        const seasonTopElem = monthBranch ? BRANCH_MAIN_ELEM[monthBranch] : "";
        const dayStem = person.dayStem || "";
        const dayElem = dayStem ? STEM_ELEM[dayStem] : "";
        const strength = calcStrength(person.elements, dayElem, seasonTopElem);
        return {
          ...person,
          topElem: top,
          weakElem: weak,
          topScore: person.elements[top],
          weakScore: person.elements[weak],
          balance: calcBalance(person.elements),
          seasonTopElem,
          dayStem,
          dayElem,
          strength,
          moneyStyle: person.elements["금"] + person.elements["수"],
        };
      }

      function evaluateRules(a, b) {
        return RULES.map((r) => {
          const activationScore = getRuleActivationScore(r, a, b);
          if (activationScore <= 0.15) return null;
          return {
            ...r,
            activationScore,
            tunedPriority: getTunedPriority(r),
          };
        }).filter(Boolean);
      }

      function calcSectionScores(firedRules) {
        const result = {};
        Object.keys(SECTION_WEIGHT).forEach(
          (s) => (result[s] = { sum: 0, cnt: 0 })
        );
        firedRules.forEach((r) => {
          if (result[r.section]) {
            result[r.section].sum += r.tunedPriority * r.activationScore;
            result[r.section].cnt += r.activationScore;
          }
        });
        const scores = {};
        Object.keys(result).forEach((s) => {
          scores[s] = result[s].cnt
            ? Math.round(result[s].sum / result[s].cnt)
            : 50;
        });
        return scores;
      }

      function calcTotalFromSections(sectionScores) {
        let total = 0;
        Object.entries(SECTION_WEIGHT).forEach(([k, w]) => {
          total += sectionScores[k] * w;
        });
        return Math.round(total);
      }

      function generateSummary(score) {
        if (score >= 85)
          return "전반적으로 궁합이 강해. 기본 결이 잘 맞고, 장기적으로 안정적이야.";
        if (score >= 70)
          return "좋은 편이야. 포인트 몇 가지만 맞추면 훨씬 편해질 수 있어.";
        if (score >= 55)
          return "무난해. 약속만 잘 세우면 충분히 좋은 관계로 갈 수 있어.";
        return "노력이 필요한 궁합이야. 대신 기준만 맞추면 의외로 단단해질 수 있어.";
      }

      /* ======================================================
  6. 톤 분기
====================================================== */
      const TONE = {
        couple: {
          title: "커플 모드",
          soften: (s) =>
            s
              .replaceAll("규칙", "약속")
              .replaceAll("기한", "타이밍")
              .replaceAll("리스크", "조심 포인트"),
          tips: {
            conflict: [
              "감정 올라오면 한 박자 쉬고 말하자.",
              "문자보다 얼굴 보고 얘기하는 게 답.",
            ],
            money: [
              "돈 얘기는 기준을 먼저 맞추는 게 편해.",
              "큰돈만 같이 결정하고 나머진 자유로 가자.",
            ],
          },
        },
        biz: {
          title: "동업자 모드",
          soften: (s) =>
            s
              .replaceAll("감정", "커뮤니케이션")
              .replaceAll("서로", "양측")
              .replaceAll("오해", "정보 비대칭"),
          tips: {
            conflict: [
              "의사결정 프로세스를 문서로 박아.",
              "회의는 의제 1개씩만 잡자.",
            ],
            money: [
              "재무는 룰이 아니라 정책이다.",
              "지출 기준/승인권자/한도를 고정해.",
            ],
          },
        },
      };

      function applyTone(text, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        return t.soften(text);
      }
      function toneExtraTip(section, toneKey) {
        const t = TONE[toneKey] || TONE.couple;
        const pool = t.tips[section] || [];
        if (!pool.length) return "";
        return pool[hashToIndex(`${toneKey}|${section}`, pool.length)];
      }

      /* ======================================================
  7. 섹션 레이더 렌더
====================================================== */
      function renderRadar(scores) {
        const svg = sectionRadarSvg;
        const keys = ["성향", "관계", "돈", "일", "건강"];
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = name;
          svg.appendChild(text);
        });

        const vals = keys.map((k) => clamp01((scores[k] ?? 50) / 100));
        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(37,99,235,0.28)",
          stroke: "rgba(37,99,235,0.9)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      /* ======================================================
  8. 신년운세 월별
====================================================== */
      function pickMonthlyCopy(ctx) {
        const { month, seasonElem, top, weak, relTop, relWeak, dayElem } = ctx;
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";

        const monthLabel = `${month}월`;
        const templates = {
          push: [
            [
              `${monthLabel}은 길운이 문턱을 넘는 달입니다. 흐름이 내 편이니 밀어붙이면 성과가 납니다.`,
              "가장 중요한 일 하나를 먼저 끝내고, 나머지는 순서를 잡아야 합니다.",
              "작은 성공을 크게 키울 수 있으니 기회를 놓치지 말아야 합니다.",
              "세운이 도움을 주는 달이니 움직이는 만큼 얻음이 따릅니다.",
            ],
            [
              `${monthLabel}은 속도가 붙는 달입니다. 미루던 일을 처리하기에 알맞습니다.`,
              "연락/결정/정리 중 하나는 이번 달에 끝내고, 다음 단계를 준비해야 합니다.",
              "발이 빠를수록 운이 붙는 시기입니다.",
              "기회가 눈앞에 있으니 과감함이 곧 복이 됩니다.",
            ],
          ],
          pushPlus: [
            [
              `${monthLabel}은 좋은 흐름과 회복이 함께 오는 달입니다.`,
              "욕심을 내어도 되나 수면과 식사는 반드시 지켜야 합니다.",
              "힘이 붙으니 큰일도 충분히 감당할 수 있습니다.",
              "세운과 기운이 맞물려 빠르게 풀리는 달입니다.",
            ],
            [
              `${monthLabel}은 잘 풀리면서 마음이 편해지는 달입니다.`,
              "새로 벌리기보다 기존을 다듬으면 크게 남습니다.",
              "작은 개선이 큰 복으로 돌아옵니다.",
              "도움이 손에 닿는 때이니 정성을 아끼지 마십시오.",
            ],
          ],
          recover: [
            [
              `${monthLabel}은 회복이 곧 복입니다. 기력만 잡아도 일이 풀립니다.`,
              "무리한 약속을 줄이고 루틴 하나를 붙여야 합니다.",
              "쉬어가는 한 달이 오히려 길운을 부릅니다.",
              "세운이 숨 고르기를 요구하니 몸과 마음을 먼저 다스리십시오.",
            ],
            [
              `${monthLabel}은 정리하면 운이 붙는 달입니다.`,
              "공간/돈/일정 중 하나만 정리해도 체감이 옵니다.",
              "지우고 덜어낼수록 기운이 맑아집니다.",
              "세운이 정리수로 흐르니 덜어낼수록 이익입니다.",
            ],
          ],
          brake: [
            [
              `${monthLabel}은 무리하면 손해 보는 달입니다. 속도를 줄이는 것이 이득입니다.`,
              "큰 결정은 2주만 미루고 확인부터 해야 합니다.",
              "서두르면 흉이 되고, 멈추면 길이 됩니다.",
              "세운이 제동을 거니 한 걸음 물러나 살피는 것이 옳습니다.",
            ],
            [
              `${monthLabel}은 신중이 곧 돈입니다.`,
              "계약/투자/충동구매는 한 번 더 점검해야 합니다.",
              "지키는 자에게 복이 머뭅니다.",
              "세운이 과열을 경계하니 조심함이 길합니다.",
            ],
          ],
          steady: [
            [
              `${monthLabel}은 유지가 이기는 달입니다. 기본만 지켜도 충분합니다.`,
              "루틴 3개(수면/식사/정리)만 챙겨야 합니다.",
              "작은 이익을 모아 큰 복으로 바꿀 시기입니다.",
              "세운이 평온하니 성실이 곧 복입니다.",
            ],
            [
              `${monthLabel}은 큰 변화보다 작은 개선이 맞습니다.`,
              "5% 개선 목표로 가면 꾸준히 이깁니다.",
              "욕심을 줄이면 오히려 얻음이 있습니다.",
              "세운이 안정이니 작은 성실이 큰 복이 됩니다.",
            ],
          ],
        };

        const seed = `${month}|${seasonElem}|${top}|${weak}|${mode}`;
        const arr = templates[mode];
        const idx = hashToIndex(seed, arr.length);
        const [oneLine, tip, extra, detail] = arr[idx];
        let luckTag = "중";
        if (dayElem) {
          const relDay = relationElem(seasonElem, dayElem);
          if (relDay === "생" || relDay === "동") luckTag = "길";
          else if (relDay === "극" || relDay === "눌림") luckTag = "흉";
          else luckTag = "중";
        } else {
          luckTag =
            mode === "push" || mode === "pushPlus"
              ? "길"
              : mode === "brake"
              ? "흉"
              : "중";
        }

        // 월별 상세 설명 생성
        const monthDetails = generateMonthDetails(
          month,
          seasonElem,
          mode,
          luckTag,
          dayElem
        );

        return {
          oneLine,
          tip,
          extra,
          detail,
          monthDetails,
          mode,
          luckTag,
          tags: [luckTag, mode, seasonElem],
        };
      }

      function generateMonthDetails(month, seasonElem, mode, luckTag, dayElem) {
        const monthLabels = [
          "",
          "1월",
          "2월",
          "3월",
          "4월",
          "5월",
          "6월",
          "7월",
          "8월",
          "9월",
          "10월",
          "11월",
          "12월",
        ];
        const monthLabel = monthLabels[month] || `${month}월`;

        const templates = {
          push: {
            길: [
              `${monthLabel} 길운과 월성이 함께 문을 두드리니 맨손으로도 성공할 기운입니다. 관록이 들기 시작하니 지위와 책임을 얻음에도 부족함이 없습니다. 자손을 얻어야 할 시기라면 좋은 소식이 있을 것이며 가족 중에서라도 새 식구의 잉태 내지 혼인의 소식이 있을 것입니다. 올해 새 식구를 맞이하게 되면 온 가족이 길하게 될 것이니 귀인으로 맞이하시기 바랍니다.`,
              `${monthLabel} 기운이 청아하여 만나는 사람마다 기쁨을 주게 됩니다. 애정도 좋고 가정에 기쁨도 있고 새로운 일로 인하여 분주함도 있으니 나쁠 일이 없습니다. 다만 건강상의 문제로 잔병을 치를 수도 있으니 과로를 경계하시기 바랍니다. 시작이 좋으니 한 해가 좋음을 미리 알리는 징후입니다. 귀인을 만나서 재물을 얻을 수 있으니 크지는 않지만 수익도 좋은 달이군요.`,
            ],
            중: [
              `${monthLabel} 길상의 기운이 들어 액운을 막아주고 비로소 뜻을 크게 품으니 분주함도 많고 노력도 많아져야 하는 때입니다. 노력하지 않으면 얻을 것이 없으니 준비해야 할 일이 있으면 남에게 의탁하지 말고 직접 움직이시기 바랍니다. 인연이 좋음으로 움직일수록 크게 도움받을 일이 생길 것입니다. 대길운이 서서히 문안으로 들어오기 시작하니 기운이 활기참을 느낄 수 있을 것입니다.`,
            ],
          },
          pushPlus: {
            길: [
              `${monthLabel} 애정이 많은 시기이니 사랑을 깊이 있게 하는 시기군요. 가정이 있으신 분은 다른 이성에게 눈이 가지 않도록 조심하시기 바랍니다. 나의 눈도 좋지만 상대가 나를 바라보는 눈도 아름다운 시기입니다. 인기가 많고 자신의 장점이 부각되어 많은 사람들로부터 칭찬을 듣게 되는 시기입니다. 선남선녀 들은 새롭게 만나는 만남이나 연인들과의 만남이 모두 좋을 것이니 프러포즈를 받기도 하고 하기도 합니다. 좋은 결과가 있을 것입니다.`,
            ],
          },
          brake: {
            흉: [
              `${monthLabel} 용맹함을 다한 범이 들판으로 나섰으니 사냥꾼의 먹이 밖에 되지 않습니다. 의욕이 앞서 실수를 범할 수 있으니 매사 신중해야 합니다. 나서지 말고 몸을 낮추는 지혜를 발휘하시면 후환은 없을 것입니다. 동남쪽 방향이 길방이니 재물이 머문 곳입니다. 금년은 북쪽이 길하지만 이번 달만큼은 동남쪽이 길한 방향입니다. 자중하면 잃을 것이 없으니 다음을 기약해도 늦지 않음을 알아야 합니다.`,
              `${monthLabel} 자신의 재물을 주머니 깊이 넣어두지 않으면 반드시 이를 노리는 사람이 있습니다. 다른 사람과 재물에 관한 거래를 절대로 하지 마시기 바랍니다. 가족 중에 환자가 생길 것이니 근심이 생기는 달입니다. 이번 달이 큰 고비인데 새롭게 일을 확장하면 해결의 실마리가 보이지 않으니 때를 기다리는 지혜를 참으로 많이 발휘하시어야 합니다. 쉬어가는 것이 결코 늦지 않음을 명심하시기 바랍니다.`,
              `${monthLabel} 서산에 해는 지는데 갈 길은 멀고, 젓가락 놀리듯 바쁘기만 한 발걸음과 같구나. 두 사람의 마음이 서로 다르니 하는 일을 끝내 이루지 못한다. 마음이 문제이니 문제는 욕심이로다. 손해를 보거나 다툼이 있을 수 있으니 주의하시되 매사에 목성(木姓)을 가까이하지 마라. 해는 중턱으로 넘어서고 갈 길은 먼데 넘어야 할 고개는 아직도 멀리 있는 형국입니다. 두 사람의 마음이 서로 다르니 이것이 마지막 어려움이 될 듯싶습니다. 욕심을 버려야 하는데 이 또한 쉽지 않을 것입니다.`,
            ],
            중: [
              `${monthLabel} 흉함이 변하여 길함이 되니 세상일이 태평하고 마음이 평안한 시기입니다. 모처럼 근심 걱정이 사라지니 새로운 계획을 세우기에 좋습니다. 그러나 서두르면 해가 될 것이니 경거망동하여 외부로 바쁘게 돌면 손실이 있을 것입니다. 마지막 풍파가 한 번은 더 있을 것이니 길하다고 하여 마음을 놓아서는 안 됩니다. 집안에 있어서 새로운 계획을 세우면 후 일이 더욱 좋으니 명심하시기 바랍니다.`,
            ],
          },
          recover: {
            중: [
              `${monthLabel} 하늘과 땅이 서로 화합하여 그 이익이 재물이나 일로써 생길 운세입니다. 작은 것을 버려 큰 것을 취하는 운세이니 기존의 것은 잊어버려도 좋을 것입니다. 새로이 투자하는 부분은 아직은 서둘러서는 안 됩니다. 매사가 좋음이 더 많으니 손익을 따지면 반드시 얻음이 클 것이지만 신규로 재물을 들이어 얻는 것은 위험수가 있으니 자중이 필요합니다. 서쪽으로 가게 되면 불리하니 서쪽 방향으로 움직이는 일은 경계하고 피해야 할 것입니다.`,
              `${monthLabel} 마른 샘에 비가 내리는 형국입니다. 비로소 막혔던 일이 풀리고 시원함을 느끼게 되는 달입니다. 문제가 되었던 것은 해결의 실마리가 보이는 시기입니다. 한 해의 시작이 일 년을 좌우하는데 올해는 일이 잘 풀릴 징조가 보이는군요. 자신의 위치와 지위가 크게 향상이 되어 뜻한 바를 실행에 옮길 준비가 갖추어집니다. 좋은 인연도 만나는 시기이니 대인적인 교류가 많아질 것입니다.`,
              `${monthLabel} 주변에 역마가 끼어 나를 괴롭히는 자가 있으니 재물이 나가지 않으나 마음이 상할 기운이 있습니다. 가까운 벗이 나를 의지하니 돕지 않으면 안 되는 일이 생길 것입니다. 마음을 크게 먹고 진심으로 도우면 친구도 좋고 나도 좋은 일이 후에 있을 것입니다. 음덕으로 쌓아 후일의 기쁨으로 삼고자 하면 액운은 아니니 덕을 쌓는 시기로 삼으시고 자신의 것보다는 후 일의 덕을 생각하며 보내시기 바랍니다. 머지않아 큰 기쁨이 옮을 알아야 합니다.`,
              `${monthLabel} 상하가 화목하여 집안에 문제가 없습니다. 화목이 곧 길운의 시작이니 가족 중에 근심 있는 자의 고민이 사라질 것입니다. 황룡이 구슬을 가지고 노는 괘를 얻었으니 곧 이루고자 하는 것을 이룰 수 있을 것입니다. 다만 때가 아님이 아쉬움으로 남으니 서둘러 일을 실천에 옮기는 일은 없도록 하시기 바랍니다. 준비를 함에 만전을 기해야 함을 잊지 마시기 바랍니다.`,
            ],
          },
          steady: {
            중: [
              `${monthLabel} 유지가 이기는 달입니다. 기본만 지켜도 충분합니다. 루틴 3개(수면/식사/정리)만 챙겨야 합니다. 작은 이익을 모아 큰 복으로 바꿀 시기입니다. 세운이 평온하니 성실이 곧 복입니다.`,
              `${monthLabel} 큰 변화보다 작은 개선이 맞습니다. 5% 개선 목표로 가면 꾸준히 이깁니다. 욕심을 줄이면 오히려 얻음이 있습니다. 세운이 안정이니 작은 성실이 큰 복이 됩니다.`,
            ],
          },
        };

        const modeTemplates = templates[mode] || templates.steady;
        const luckTemplates =
          modeTemplates[luckTag] ||
          modeTemplates.중 ||
          modeTemplates[Object.keys(modeTemplates)[0]];
        const seed = `${month}|${seasonElem}|${mode}|${luckTag}`;
        const idx = hashToIndex(seed, luckTemplates.length);
        return luckTemplates[idx] || "";
      }

      function makeMonthlyLuck(person) {
        const { top, weak } = getTopWeak(person.elements);
        const dayElem = person.dayElem || "";
        const months = [];
        for (let m = 1; m <= 12; m++) {
          const flow = MONTH_FLOW[m];
          const s = flow.seasonTop;
          const relTop = relationElem(top, s);
          const relWeak = relationElem(weak, s);
          const { oneLine, tip, extra, detail, monthDetails, tags } =
            pickMonthlyCopy({
              month: m,
              seasonElem: s,
              top,
              weak,
              relTop,
              relWeak,
              dayElem,
            });
          months.push({
            month: m,
            seasonElem: s,
            monthBranch: flow.monthBranch,
            summary: oneLine,
            tip,
            extra,
            detail,
            monthDetails,
            tags,
          });
        }
        return months;
      }

      function renderMonthly(person) {
        monthlyList.innerHTML = makeMonthlyLuck(person)
          .map(
            (m) => `
            <div class="rule-card">
              <div class="row" style="justify-content: space-between; align-items: center;">
                <div class="section-title">${m.month}월 · ${
              m.seasonElem
            } 흐름</div>
                <div style="margin-left: auto; display: flex; align-items: center; justify-content: flex-end; gap: 6px; flex-wrap: wrap;">${formatMonthTags(
                  m.tags
                )}</div>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              ${
                m.monthDetails
                  ? `<div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; border-left: 3px solid var(--accent);">
                      <p class="mini" style="line-height: 1.8; margin: 0; color: rgba(15, 23, 42, 0.8);">${escapeHtml(
                        m.monthDetails
                      )}</p>
                    </div>`
                  : ""
              }
              ${
                m.extra
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p class="mini" style="margin: 0; line-height: 1.7; color: rgba(15, 23, 42, 0.75);">${escapeHtml(
                       m.extra
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.detail
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p class="mini" style="margin: 0; line-height: 1.7; color: rgba(15, 23, 42, 0.75);">${escapeHtml(
                       m.detail
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.tip
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(34, 197, 94, 0.08); border-radius: 6px; border-left: 3px solid rgba(34, 197, 94, 0.5);">
                     <p class="mini" style="margin: 0; line-height: 1.7; font-weight: 600; color: rgba(15, 23, 42, 0.85);">
                       <span style="color: rgba(34, 197, 94, 0.9);">💡 팁:</span> ${escapeHtml(
                         m.tip
                       )}
                     </p>
                   </div>`
                  : ""
              }
              <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
                <button class="btn compact" data-month="${
                  m.month
                }" data-month-index="${
              m.month - 1
            }" style="font-size: 12px; padding: 6px 12px;">
                  📋 공유하기
                </button>
              </div>
            </div>`
          )
          .join("");

        // 공유 버튼 이벤트 리스너 추가
        setTimeout(() => {
          monthlyList.querySelectorAll("[data-month]").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const monthIndex = parseInt(btn.getAttribute("data-month-index"));
              const monthData = makeMonthlyLuck(person)[monthIndex];
              await shareMonthlyCard(monthData);
            });
          });
        }, 100);
      }

      async function shareMonthlyCard(monthData) {
        const monthLabels = [
          "",
          "1월",
          "2월",
          "3월",
          "4월",
          "5월",
          "6월",
          "7월",
          "8월",
          "9월",
          "10월",
          "11월",
          "12월",
        ];
        const monthLabel =
          monthLabels[monthData.month] || `${monthData.month}월`;

        // 태그 텍스트 추출
        const [luckTag, mode, seasonElem] = monthData.tags || [];
        const luckText =
          luckTag === "길" ? "길운" : luckTag === "흉" ? "흉운" : "중운";
        const modeText = monthModeText(mode);
        const tagsText = `${luckText} · ${modeText} · ${seasonElem} 기운`;

        let text = `🔮 ${monthLabel} 운세\n\n`;
        text += `${monthData.summary}\n\n`;

        if (monthData.monthDetails) {
          text += `${monthData.monthDetails}\n\n`;
        }
        if (monthData.extra) {
          text += `${monthData.extra}\n\n`;
        }
        if (monthData.detail) {
          text += `${monthData.detail}\n\n`;
        }
        if (monthData.tip) {
          text += `💡 팁: ${monthData.tip}\n\n`;
        }

        text += `태그: ${tagsText}\n`;
        text += `\n#사주풀이 #신년운세 #${monthLabel}운세\n\n`;
        text += `🔮 사주풀이 서비스: https://saju.funnyfunny.cloud/`;

        try {
          await navigator.clipboard.writeText(text);
          alert(`${monthLabel} 운세가 클립보드에 복사되었습니다!`);
        } catch (err) {
          // 클립보드 API가 없거나 실패한 경우
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            alert(`${monthLabel} 운세가 클립보드에 복사되었습니다!`);
          } catch (e) {
            prompt("복사할 내용:", text);
          }
          document.body.removeChild(textarea);
        }
      }

      /* ======================================================
  9. 렌더
====================================================== */
      function renderSummary(totalScore, firedRules, toneKey, coupleElements) {
        const summary = generateSummary(totalScore);
        totalScoreEl.textContent = `${totalScore}점`;
        summaryMain.textContent = summary;
        summarySub.textContent = "입력 시간대 기준 · 절기/오행 규칙";

        const { top, weak } = getTopWeak(coupleElements);
        const pills = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          `발동 룰: ${firedRules.length}개`,
          TONE[toneKey]?.title || "커플 모드",
        ];
        summaryPills.innerHTML = pills
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");
      }

      function renderRules(firedRules, toneKey, tokens) {
        if (!firedRules.length) {
          ruleList.innerHTML = `<p class="mini">발동된 룰이 아직 없어. 입력값을 확인해줘.</p>`;
          return;
        }

        ruleList.innerHTML = firedRules
          .sort(
            (a, b) =>
              b.tunedPriority * b.activationScore -
              a.tunedPriority * a.activationScore
          )
          .map((r) => {
            const evidence = applyTone(fillTokens(r.evidence, tokens), toneKey);
            const copy = applyTone(r.copies[0], toneKey);
            const copy2 = r.copies[1] ? applyTone(r.copies[1], toneKey) : "";
            const extra =
              r.section === "돈"
                ? toneExtraTip("money", toneKey)
                : toneExtraTip("conflict", toneKey);
            const strength = Math.round(r.activationScore * 100);
            const insight =
              r.section === "돈"
                ? "돈 흐름은 규칙 합의가 있을수록 안정된다."
                : r.section === "건강"
                ? "리듬이 맞을수록 컨디션 회복이 빠르다."
                : r.section === "일"
                ? "속도보다 방향 정렬이 성과를 만든다."
                : r.section === "관계"
                ? "감정 곡선을 맞추면 충돌이 줄어든다."
                : "기질의 차이를 인정할수록 편해진다.";
            return `
            <div class="rule-card">
              <div class="rule-head">
                <b>${escapeHtml(r.id)}</b>
                <button class="like-btn" data-rule="${r.id}">공감 👍</button>
              </div>
              <p class="mini">근거: ${escapeHtml(
                evidence
              )} · 강도 ${strength}%</p>
              <p>${escapeHtml(copy)}${
              extra
                ? `<br/><span class="mini">+ ${escapeHtml(extra)}</span>`
                : ""
            }${
              copy2
                ? `<br/><span class="mini">+ ${escapeHtml(copy2)}</span>`
                : ""
            }</p>
              <p class="mini">해석: ${escapeHtml(insight)}</p>
            </div>`;
          })
          .join("");
      }

      function renderPillars(targetEl, result) {
        if (!result) {
          targetEl.textContent = "—";
          return;
        }
        const p = result.pillars;
        const tzText = formatTzOffset(result.input.tzOffsetMinutes);
        const hourText = p.hour ? p.hour.text : "미포함";
        targetEl.innerHTML = `입력: ${result.input.local} (UTC${tzText})<br/>
          연: ${p.year.text} / 월: ${p.month.text}<br/>
          일: ${p.day.text} / 시: ${hourText}`;
      }

      function formatElemLine(prefix, obj, totalSum = null) {
        const order = ["목", "화", "토", "금", "수"];
        const lead = prefix ? `${prefix} ` : "";
        return `${lead}${order
          .map((k) => {
            const v = Math.round((obj[k] || 0) * 10) / 10;
            if (!totalSum) return `${k} ${v}`;
            const p = Math.round(((obj[k] || 0) / totalSum) * 1000) / 10;
            return `${k} ${v}(${p}%)`;
          })
          .join(" · ")}`;
      }

      function makeElementProfile(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        const strong = [];
        const mid = [];
        const weak = [];
        order.forEach((k) => {
          const v = elements[k] || 0;
          const ratio = avg ? v / avg : 1;
          if (ratio >= 1.2) strong.push(k);
          else if (ratio <= 0.8) weak.push(k);
          else mid.push(k);
        });
        return {
          strong: strong.length ? strong.join(" · ") : "—",
          mid: mid.length ? mid.join(" · ") : "—",
          weak: weak.length ? weak.join(" · ") : "—",
          avg: Math.round(avg * 10) / 10,
        };
      }

      function makeElementEvidence(elements, breakdown, top, low) {
        if (!breakdown) return "";
        const sum = (obj, key) => Math.round((obj?.[key] || 0) * 10) / 10;
        const format = (elem) =>
          `${elem} ${Math.round((elements[elem] || 0) * 10) / 10} = 천간 ${sum(
            breakdown.stems,
            elem
          )} · 지지 ${sum(breakdown.branches, elem)} · 장간 ${sum(
            breakdown.hidden,
            elem
          )} · 월령 ${sum(breakdown.season, elem)}`;
        return `근거: ${format(top)} / 약한 ${format(low)}`;
      }

      function elementDeltaLines(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        return order
          .map((k) => {
            const v = Math.round((elements[k] || 0) * 10) / 10;
            const diff = Math.round((v - avg) * 10) / 10;
            const sign = diff >= 0 ? "+" : "";
            return `${k} ${v} (${sign}${diff})`;
          })
          .join(" · ");
      }

      function elementAdvice(profile) {
        const lines = [];
        if (profile.strong !== "—") {
          lines.push(
            `강한 오행 활용: ${profile.strong} 쪽을 메인 축으로 밀면 효율이 좋아.`
          );
        }
        if (profile.mid !== "—") {
          lines.push(
            `중간 오행 조율: ${profile.mid}는 완충 역할이라 밸런스를 잡아준다.`
          );
        }
        if (profile.weak !== "—") {
          lines.push(
            `약한 오행 보완: ${profile.weak}는 생활 루틴/환경으로 보완하면 체감이 크다.`
          );
        }
        return lines;
      }

      function renderElementsAnalysis(elements, breakdown, meta = {}) {
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const topIdx = values.indexOf(Math.max(...values));
        const lowIdx = values.indexOf(Math.min(...values));
        const top = keys[topIdx];
        const low = keys[lowIdx];
        const personality = getElementPersonality(top, low);
        const profile = makeElementProfile(elements);
        const evidenceLine = makeElementEvidence(elements, breakdown, top, low);

        const totalSum = values.reduce((a, b) => a + b, 0) || 1;
        const rounded = keys.reduce((acc, k) => {
          acc[k] = Math.round((elements[k] || 0) * 10) / 10;
          return acc;
        }, {});
        const percent = keys.reduce((acc, k) => {
          acc[k] = Math.round(((elements[k] || 0) / totalSum) * 1000) / 10;
          return acc;
        }, {});

        elementsSummary.textContent = `오행 분석: ${top} 기운이 가장 강하고, ${low} 기운이 상대적으로 약한 편이야.`;
        renderElementsRadar(elements);

        // 신토정비결 보정 정보 HTML 생성
        let anchorInfoHtml = null;
        let elementsTableHtml = "";
        if (meta.anchorKey) {
          const keyParts = meta.anchorKey.split("|");
          const SHINTO_ANCHORS = {
            "병인|계사|병자|무자": { 목: 16, 화: 33, 토: 24, 금: 7, 수: 70 },
            "무진|기미|정해|신해": { 목: 26, 화: 9, 토: 70, 금: 10, 수: 35 },
            "을해|갑신|기축|계유": { 목: 27, 화: 0, 토: 32, 금: 49, 수: 42 },
            "임술|병오|계미|신유": { 목: 3, 화: 42, 토: 46, 금: 49, 수: 10 },
            "경신|신사|임인|기유": { 목: 16, 화: 23, 토: 31, 금: 73, 수: 7 },
            "무오|정사|신묘|정유": { 목: 30, 화: 56, 토: 27, 금: 37, 수: 0 },
            "계미|정사|정해|기유": { 목: 10, 화: 35, 토: 42, 금: 37, 수: 26 },
          };
          const anchorData = SHINTO_ANCHORS[meta.anchorKey];
          const statusText = meta.anchorApplied ? "적용됨" : "미적용";
          const statusClass = meta.anchorApplied ? "chip e-wood" : "chip";

          if (anchorData) {
            anchorInfoHtml = `
              <div style="margin: 16px 0; padding: 16px; background: rgba(99, 102, 241, 0.05); border-radius: var(--radius-sm); border: 1px solid rgba(99, 102, 241, 0.15);">
                <div class="section-title" style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                  <span>🔮 신토정비결 보정</span>
                  <span class="${statusClass}" style="font-size: 11px; padding: 4px 10px;">${statusText}</span>
                </div>
                <div style="margin-bottom: 12px;">
                  <table class="report-table" style="font-size: 13px;">
                    <thead>
                      <tr>
                        <th style="width: 80px;">구분</th>
                        <th>년</th>
                        <th>월</th>
                        <th>일</th>
                        <th>시</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th>간지</th>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[0] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[1] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[2] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[3] || "—"
                        )}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div>
                  <table class="report-table" style="font-size: 13px; width: 100%;">
                    <thead>
                      <tr>
                        <th style="width: 90px; text-align: center;">오행</th>
                        <th style="width: 80px; text-align: center;">목</th>
                        <th style="width: 80px; text-align: center;">화</th>
                        <th style="width: 80px; text-align: center;">토</th>
                        <th style="width: 80px; text-align: center;">금</th>
                        <th style="width: 80px; text-align: center;">수</th>
                        <th style="width: 70px; text-align: center;">합계</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th style="text-align: center; vertical-align: middle;">보정값</th>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #e8f7e9; color: #0f3d2e;">${
                          anchorData.목
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #ffe9e3; color: #7a1f16;">${
                          anchorData.화
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #f8f1df; color: #5a3b12;">${
                          anchorData.토
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #eef3ff; color: #1b3a70;">${
                          anchorData.금
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #e6f5ff; color: #0c3550;">${
                          anchorData.수
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; font-weight: 800; font-size: 15px; color: var(--accent); background: rgba(99, 102, 241, 0.1);">${Object.values(
                          anchorData
                        ).reduce((a, b) => a + b, 0)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <p class="mini" style="margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.5); border-radius: 8px; line-height: 1.6;">
                  ${
                    meta.anchorApplied
                      ? "✅ <strong>신토정비결 보정 적용</strong><br/>회원님의 사주 간지 조합은 신토정비결(전통 사주 해석서)에 기록된 특별한 패턴입니다. 일반 계산 방식 대신 신토정비결에서 정한 오행 분포값을 사용하여 더 정확한 해석을 제공합니다."
                      : "ℹ️ <strong>신토정비결 보정 미적용</strong><br/>회원님의 사주 간지 조합에 대한 신토정비결 기준 데이터가 없어 일반 계산 방식으로 오행을 산출했습니다."
                  }
                </p>
              </div>
            `;
          } else {
            anchorInfoHtml = `
              <div style="margin: 12px 0;">
                <div class="section-title" style="margin-bottom: 8px;">
                  신토정비결 보정 <span class="chip" style="font-size: 11px; padding: 2px 8px;">미적용</span>
                </div>
                <p class="mini">간지: ${escapeHtml(meta.anchorKey)}</p>
                <p class="mini">해당 간지 조합에 대한 신토정비결 보정 데이터가 없습니다.</p>
              </div>
            `;
          }
        }

        // 오행 정보 표 생성
        elementsTableHtml = `
          <div style="margin: 16px 0;">
            <div class="section-title" style="margin-bottom: 12px;">📊 오행 분석</div>
            <div class="pill-row" style="margin-bottom: 12px;">
              <span class="pill emphasis">일간 기준: ${escapeHtml(
                meta.dayElem || "—"
              )} 기운 인간(본질)</span>
              <span class="pill emphasis">오행 분포: ${escapeHtml(
                top
              )} 강세(환경)</span>
            </div>
            ${
              meta.birthText
                ? `<p class="mini" style="margin-bottom: 12px;"><strong>출생:</strong> ${escapeHtml(
                    meta.birthText
                  )}</p>`
                : ""
            }
            <table class="report-table" style="font-size: 13px; margin-bottom: 12px;">
              <thead>
                <tr>
                  <th style="width: 100px;">구분</th>
                  <th style="width: 80px; text-align: center;">목</th>
                  <th style="width: 80px; text-align: center;">화</th>
                  <th style="width: 80px; text-align: center;">토</th>
                  <th style="width: 80px; text-align: center;">금</th>
                  <th style="width: 80px; text-align: center;">수</th>
                  <th style="width: 70px; text-align: center;">합계</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th style="vertical-align: middle;">분포(%)</th>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["목"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["화"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["토"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["금"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["수"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 800; color: var(--accent);">100%</td>
                </tr>
                <tr>
                  <th style="vertical-align: middle;">점수(150)</th>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #e8f7e9; color: #0f3d2e;">${
                    rounded["목"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #ffe9e3; color: #7a1f16;">${
                    rounded["화"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #f8f1df; color: #5a3b12;">${
                    rounded["토"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #eef3ff; color: #1b3a70;">${
                    rounded["금"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #e6f5ff; color: #0c3550;">${
                    rounded["수"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 800; color: var(--accent);">150</td>
                </tr>
                <tr>
                  <th style="vertical-align: middle;">평균 대비</th>
                  ${["목", "화", "토", "금", "수"]
                    .map((k) => {
                      const v = Math.round((elements[k] || 0) * 10) / 10;
                      const avg = totalSum / 5;
                      const diff = Math.round((v - avg) * 10) / 10;
                      const sign = diff >= 0 ? "+" : "";
                      const color =
                        diff >= 0 ? "var(--accent)" : "rgba(15, 23, 42, 0.6)";
                      return `<td style="text-align: center; vertical-align: middle; font-weight: 700; color: ${color};">${sign}${diff}</td>`;
                    })
                    .join("")}
                  <td style="text-align: center; vertical-align: middle;">—</td>
                </tr>
              </tbody>
            </table>
            ${
              breakdown
                ? `
              <table class="report-table" style="font-size: 12px; margin-bottom: 12px;">
                <thead>
                  <tr>
                    <th style="width: 100px;">구분</th>
                    <th style="width: 80px; text-align: center;">목</th>
                    <th style="width: 80px; text-align: center;">화</th>
                    <th style="width: 80px; text-align: center;">토</th>
                    <th style="width: 80px; text-align: center;">금</th>
                    <th style="width: 80px; text-align: center;">수</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>천간</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.stems[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.stems[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  <tr>
                    <th>지지 본기</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.branches[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.branches[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  ${
                    meta.hiddenMode === "on"
                      ? `
                  <tr>
                    <th>장간</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.hidden[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.hidden[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  `
                      : ""
                  }
                  <tr>
                    <th>월령 가중</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.season[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.season[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                </tbody>
              </table>
            `
                : ""
            }
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
              <div class="chip" style="padding: 8px 12px;">
                <strong>강:</strong> ${profile.strong || "—"}
              </div>
              <div class="chip" style="padding: 8px 12px;">
                <strong>중:</strong> ${profile.mid || "—"}
              </div>
              <div class="chip" style="padding: 8px 12px;">
                <strong>약:</strong> ${profile.weak || "—"}
              </div>
            </div>
            ${
              evidenceLine
                ? `<p class="mini" style="padding: 8px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; margin-bottom: 12px;"><strong>근거:</strong> ${escapeHtml(
                    evidenceLine
                  )}</p>`
                : ""
            }
          </div>
        `;

        const detailLines = [
          `강한 ${top}: 집중/추진 쪽으로 쓰면 성과가 빨라져. 특히 ${top}는 현재 전체의 약 ${Math.round(
            (values[topIdx] / totalSum) * 100
          )}% 수준이야.`,
          `약한 ${low}: 루틴/환경 보완으로 충분히 메꿀 수 있어. ${low}는 지금 가장 낮은 구간이라 의식적으로 챙기는 게 좋아.`,
          `성향 요약: ${personality}`,
          ...elementAdvice(profile),
          meta.includeHour === false
            ? "시주 미포함: 시간 정보가 없어 시주의 영향은 제외했어."
            : meta.includeHour === "partial"
            ? "시주 일부 미포함: 한쪽은 시간 정보가 없어 시주가 제외됐어."
            : null,
          meta.boundaryText ? meta.boundaryText : null,
          `균형 팁: 상생 구조를 따라 ${top}의 장점을 살리되, ${low}를 받쳐줄 생활 습관을 하나만 고정하면 흐름이 안정돼.`,
        ].filter(Boolean);
        const detailText = detailLines
          .map((l) => escapeHtml(l))
          .filter(Boolean)
          .join("<br/>");

        elementsDetail.innerHTML = anchorInfoHtml
          ? anchorInfoHtml + elementsTableHtml + "<br/>" + detailText
          : elementsTableHtml + "<br/>" + detailText;
      }

      function getElementPersonality(top, low) {
        const topMap = {
          목: "확장형. 아이디어/개척에 강하고, 빠르게 움직여.",
          화: "표현형. 추진/열정이 강하고, 분위기를 주도해.",
          토: "안정형. 조율/관리 중심이며, 신뢰가 자산이야.",
          금: "정밀형. 기준/원칙이 뚜렷하고, 결정이 빠른 편이야.",
          수: "분석형. 정보/흐름을 읽고, 유연하게 대응해.",
        };
        const lowMap = {
          목: "새로운 시도는 쉬는데 마무리가 약해질 수 있어.",
          화: "흥이 떨어지면 동력이 급감할 수 있어.",
          토: "루틴이 흐트러지면 불안정해질 수 있어.",
          금: "결정 기준이 흔들리면 스트레스가 커질 수 있어.",
          수: "과한 정보 탐색으로 결정이 늦어질 수 있어.",
        };
        const topLine = topMap[top] || "기질의 중심이 되는 성향이 또렷해.";
        const lowLine = lowMap[low] || "약한 축을 보완하면 안정감이 올라가.";
        return `${topLine} ${lowLine}`;
      }

      function renderElementsRadar(elements) {
        const svg = elementsRadarSvg;
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const vals = values.map((v) => clamp01(v / maxVal));
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = `${name} ${
            Math.round((elements[name] || 0) * 10) / 10
          }`;
          svg.appendChild(text);
        });

        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(245,158,11,0.25)",
          stroke: "rgba(217,119,6,0.95)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        const dots = vals.map((v, i) => {
          const dot = el("circle", {
            cx: cx,
            cy: cy,
            r: "3.5",
            fill: "rgba(217,119,6,0.95)",
          });
          svg.appendChild(dot);
          return { dot, v, i };
        });

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          dots.forEach(({ dot, v, i }) => {
            const [dx, dy] = pt(v * p, i);
            dot.setAttribute("cx", dx.toFixed(2));
            dot.setAttribute("cy", dy.toFixed(2));
          });
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      function getGenerator(elem) {
        const map = { 화: "목", 토: "화", 금: "토", 수: "금", 목: "수" };
        return map[elem] || "";
      }

      function getOvercomeElem(elem) {
        const entries = Object.entries(OVERCOME);
        const found = entries.find(([, v]) => v === elem);
        return found ? found[0] : "";
      }

      function getYongshinSuggestion(person) {
        const suggestions = [];
        const genWeak = getGenerator(person.weakElem);
        const controlTop = getOvercomeElem(person.topElem);
        if (person.weakScore <= 0.8 && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `약한 ${person.weakElem} 보완`,
          });
        }
        if (person.topScore >= 1.4 && controlTop) {
          suggestions.push({
            elem: controlTop,
            reason: `강한 ${person.topElem} 조절`,
          });
        }
        if (!suggestions.length && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `균형 유지`,
          });
        }
        return suggestions;
      }

      function calcStrength(elements, dayElem, seasonElem) {
        if (!dayElem) return "중간";
        const total = Object.values(elements).reduce((a, b) => a + b, 0);
        const avg = total / 5;
        let score = elements[dayElem] || 0;
        if (seasonElem === dayElem) score += 0.6;
        if (GENERATE[seasonElem] === dayElem) score += 0.3;
        if (OVERCOME[seasonElem] === dayElem) score -= 0.3;
        if (score >= avg + 0.2) return "신강";
        if (score <= avg - 0.2) return "신약";
        return "중간";
      }

      function listInternalPairs(branches, table) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (hasPair(branches[i], branches[j], table)) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function listInternalHyeong(branches) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (
              HYEONG.some(
                ([a, b]) =>
                  (branches[i] === a && branches[j] === b) ||
                  (branches[i] === b && branches[j] === a)
              )
            ) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function renderDeepAnalysisCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderDeepBlock("A", a));
        if (b) blocks.push(renderDeepBlock("B", b));
        deepAnalysis.innerHTML = blocks.join("");
      }

      function renderDeepBlock(label, person) {
        const yongshin = getYongshinSuggestion(person);
        const yongText = yongshin.length
          ? yongshin.map((y) => `${y.elem}(${y.reason})`).join(", ")
          : "—";
        const season =
          person.monthBranch && person.seasonTopElem
            ? `${person.monthBranch}(${person.seasonTopElem})`
            : "—";
        const seasonLine =
          person.seasonTopElem && person.topElem === person.seasonTopElem
            ? "월령과 강점이 같아 자연스럽게 힘이 실리는 흐름입니다."
            : "월령과 강점이 달라 조율과 보완이 중요합니다.";
        const currentLine = formatElemLine("현재 오행:", person.elements);
        const dayStemLine = person.dayStem
          ? `일간: ${person.dayStem}(${person.dayElem}) · ${person.strength}`
          : "일간: —";
        const tenGodLine = person.dayStem
          ? `십성: 연 ${tenGod(
              person.dayStem,
              person.yearStem
            )} · 월 ${tenGod(person.dayStem, person.monthStem)} · 일 ${tenGod(
              person.dayStem,
              person.dayStem
            )} · 시 ${
              person.hourStem ? tenGod(person.dayStem, person.hourStem) : "—"
            }`
          : "십성: —";
        const branches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const hap = listInternalPairs(branches, LIUHE);
        const chung = listInternalPairs(branches, CHUNG);
        const hyeong = listInternalHyeong(branches);
        const relationLine = `합: ${hap.length ? hap.join(", ") : "—"} · 충: ${
          chung.length ? chung.join(", ") : "—"
        } · 형: ${hyeong.length ? hyeong.join(", ") : "—"}`;
        const relationExplain = `합은 서로 돕는 결이라 호흡이 부드럽고, 충은 부딪힘이 생겨 타이밍 조절이 필요합니다. 형은 마찰이나 긴장이 생기기 쉬운 결입니다. ${
          hyeong.length
            ? `현재 형: ${hyeong.join(", ")}이므로 말투/속도를 줄이면 충돌이 줄어듭니다.`
            : "형이 적어 큰 마찰은 덜합니다."
        }`;
        return `
          <div class="rule-card">
            <div class="section-title">${label} 상세 해석</div>
            <div class="mini">${escapeHtml(dayStemLine)}</div>
            <div class="mini">${escapeHtml(tenGodLine)}</div>
            <div class="mini">용신: ${escapeHtml(yongText)}</div>
            <div class="mini">격국: 월지 ${escapeHtml(
              season
            )} 중심. ${escapeHtml(seasonLine)}</div>
            <div class="mini">${escapeHtml(currentLine)}</div>
            <div class="mini">${escapeHtml(relationLine)}</div>
            <div class="mini">${escapeHtml(relationExplain)}</div>
          </div>
        `;
      }

      function getHourRangeText(branch) {
        const map = {
          자: "00:00~01:30",
          축: "01:31~03:30",
          인: "03:31~05:30",
          묘: "05:31~07:30",
          진: "07:31~09:30",
          사: "09:31~11:30",
          오: "11:31~13:30",
          미: "13:31~15:30",
          신: "15:31~17:30",
          유: "17:31~19:30",
          술: "19:31~21:30",
          해: "21:31~23:30",
        };
        return map[branch] || "—";
      }

      function makeYearNarrative(person, targetYear) {
        const pillar = ganzhiYear(targetYear);
        const yearElem = STEM_ELEM[pillar.stem];
        const yearTenGod = person.dayStem
          ? tenGod(person.dayStem, pillar.stem)
          : "";
        const mode = yearModeText(
          pickYearMode(
            relationElem(yearElem, person.topElem),
            relationElem(yearElem, person.weakElem)
          )
        );
        const relYearTop = relationElem(yearElem, person.topElem);
        const relYearWeak = relationElem(yearElem, person.weakElem);

        // 총론 생성
        let totalParts = [];
        if (relYearTop === "생" || relYearTop === "동") {
          totalParts.push(
            "위기 가운데 기회가 있으니 어려움 중에 얻음이 큰 해입니다."
          );
          totalParts.push(
            "경험을 통해 얻은 것이니 결과가 단단하며 보기에 좋습니다."
          );
        } else if (relYearTop === "극" || relYearTop === "눌림") {
          totalParts.push(
            "신중이 곧 복인 해입니다. 서두르면 손해를 보니 확인을 거듭해야 합니다."
          );
          totalParts.push(
            "지키는 자에게 복이 머물러 안정을 추구하면 길합니다."
          );
        } else {
          totalParts.push("기본을 지키면 안정이 따르는 해입니다.");
          totalParts.push(
            "작은 성실이 큰 복으로 돌아오니 꾸준함이 요체입니다."
          );
        }

        if (yearTenGod === "정관" || yearTenGod === "편관") {
          totalParts.push(
            "능력을 얻었으니 나를 바라보는 시선이 많아지는 해입니다."
          );
          totalParts.push("인기가 많으니 명예는 저절로 얻게 됩니다.");
        } else if (yearTenGod === "정재" || yearTenGod === "편재") {
          totalParts.push(
            "큰 재물은 아니어도 소소함이 있을 것이니 끊이지 않게 하여 근심을 막을 것입니다."
          );
          totalParts.push(
            "필요한 정도는 얻을 것이니 욕심으로 화를 조장하면 안 됩니다."
          );
        } else if (yearTenGod === "정인" || yearTenGod === "편인") {
          totalParts.push("복은 인연과 겸손을 통해 찾아옵니다.");
          totalParts.push(
            "나의 것이 아닌 것을 바라면 되려 흉사가 될 것이니 반드시 노력을 통해 얻어야 함을 명심하기 바랍니다."
          );
        }

        totalParts.push(
          "지위와 명예는 실리를 동반해야 하며 재물은 노력이 수반되어야 합니다."
        );
        totalParts.push(
          "투자를 통해서 얻는 재물은 없을 것이니 공연히 낭패 보는 일이 없도록 하시고 책임만 주어진 감투는 각별히 사양하시기 바랍니다."
        );
        totalParts.push(
          "기회에 저해요소가 될 것이니 명예를 얻고도 일은 허사가 될 수 있습니다."
        );
        totalParts.push(
          "길성이 문 앞을 비출 것이니 취하는 자의 노력에 따라 얻음이 달라집니다."
        );
        totalParts.push(
          "노력하면 이상을 얻게 되는 해이나 앉아서 들어오는 재물은 없습니다."
        );
        totalParts.push(
          "노력 없이 재물을 탐하면 실이 될 것이니 명심해야 합니다."
        );
        totalParts.push(
          "도움 주는 인연이 나타날 것이니 작은 인연도 소중히 해야 합니다."
        );
        totalParts.push(
          "근심은 작고 기쁨은 큰 해이니 무모함으로 좋은 복을 날리는 일이 없도록 하세요."
        );
        totalParts.push("일이 생기면 피하지 말아야 합니다.");

        const total = totalParts.join(" ");

        // 재물운 생성
        let moneyParts = [];
        if (relYearWeak === "생" || relYearWeak === "동") {
          moneyParts.push(
            "일을 진행하고 재물을 얻으려면 한번은 크게 모험을 하게 되는 시기입니다."
          );
          moneyParts.push(
            "마음속에 고민과 갈등이 많아지게 되며 중요한 결정을 내리게 되는 시기이군요."
          );
          moneyParts.push(
            "다행히 길성이 비추고 월덕과 천을이 함께하게 되니 좋은 결과가 기대할 수 있겠습니다."
          );
        } else {
          moneyParts.push("재물은 꾸준함에서 나옵니다.");
          moneyParts.push(
            "급하게 큰돈을 탐하면 손실로 돌아올 수 있으니 신중해야 합니다."
          );
        }
        moneyParts.push(
          "횡재나 행운으로 얻어지는 재물은 많지 않고 일이 잘 풀리고 성장하여 좋은 성과를 올리게 될 때 얻게 되는 재물이 많을 것입니다."
        );
        moneyParts.push(
          "본업으로 얻는 수익보다 본업 이외의 분야에서 들어오는 수익이 더 클 것이니 다소 균형이 맞지 않아서 선택의 기로에서 갈등이 있겠지만 재물이 쌓여가는 즐거움과 행복함이 크게 느껴질 것입니다."
        );
        moneyParts.push(
          "나를 위해 도움을 주는 의인이 있어 나의 손실을 막아주고 생활의 변화가 있으면서 절약하는 생활을 하게 될 것입니다."
        );
        moneyParts.push(
          "그래도 지출이 상당히 많은 성향이 있으므로 재물이 나가는 것을 잘 관리한다면 결국 들어오는 재물이 나가는 재물보다 많아지게 되어 재물을 축적할 수가 있을 것입니다."
        );
        const money = moneyParts.join(" ");

        // 직장/사업운 생성
        let workParts = [];
        if (relYearTop === "생" || relYearTop === "동") {
          workParts.push(
            "큰 일을 성사시켜 자신의 관록과 명성이 크게 높아지는 시기입니다."
          );
          workParts.push(
            "직장에서는 지위를 크게 얻거나 큰 포상을 받을 뿐만 아니라 소속된 곳에 공여하는 바가 크고 자신이 느끼는 행복감도 커질 것입니다."
          );
        } else {
          workParts.push("안정을 추구하는 시기입니다.");
          workParts.push(
            "무리한 확장보다는 기존의 것을 다듬는 것이 유리합니다."
          );
        }
        workParts.push(
          "자신의 능력이 점차 알려지게 되면서 다른 곳으로부터 좋은 제의를 받거나 나를 부를 것이니 나의 진가와 능력이 크게 돋보이는 시기입니다."
        );
        workParts.push(
          "바깥으로 활동하는 사람은 잠시의 여유도 없을 정도로 일이 끊이지 않을 것입니다."
        );
        workParts.push(
          "장사를 하면 대길의 운수가 크게 일어날 것이지만 굳이 새로운 장사를 시작할 필요는 없습니다."
        );
        workParts.push(
          "장사보다는 무슨 일을 하든지 운의 중심이 나에게 있으므로 내가 주도적으로 할 수 있고 자신의 머리와 손을 거쳐서 하는 일을 하시기 바랍니다."
        );
        workParts.push(
          "사업적으로는 기반이 탄탄해질 것이며, 거래처가 크게 늘어날 것입니다."
        );
        workParts.push(
          "확장의 준비를 해야 하지만 무리하지 말고 치밀하게 계획하고 천천히 여유를 갖고 진행하시기 바랍니다."
        );
        const work = workParts.join(" ");

        // 가정/건강운 생성
        let familyParts = [];
        familyParts.push(
          "가족 중에서 근심이 많은 사람이 있으니 마음으로 위로를 해야 할 일이 생기겠습니다."
        );
        familyParts.push("가족 간의 갈등이 예상되는 시기입니다.");
        familyParts.push(
          "하늘이 나에게 내린 좋은 운의 기운이 찾아오기 전의 사소한 갈등으로 발생할 것이니 상대의 입장을 먼저 이해해 주고 큰 다툼이 되지 않도록 주의하시기 바랍니다."
        );
        familyParts.push(
          "가족끼리 다투게 되면 천금을 얻는다 하여도 아무런 소용이 없습니다."
        );
        familyParts.push(
          "봄을 지나면 모두가 해결이 될 것이니 그때부터는 화목과 평안이 클 것입니다."
        );
        familyParts.push(
          "소원성취의 운이 크게 일어나니 믿으면 믿은 만큼 보답할 것입니다."
        );
        familyParts.push(
          "위아래가 이제부터 모두 제 역할을 할 것이니 서로가 공손해져 화목이 더해집니다."
        );
        familyParts.push(
          "웃음이 끊이지 않을 것이니 큰 경사가 생길 징조도 보이는군요."
        );
        familyParts.push("웃어른의 건강에 문제가 생깁니다.");
        familyParts.push(
          "병원에 오래 계시지 않도록 각별히 신경 쓰시고 증세가 오면 반드시 병원을 찾아 병을 키우는 일이 없도록 하시기 바랍니다."
        );
        const family = familyParts.join(" ");

        // 이성/대인관계 생성
        let relationParts = [];
        relationParts.push(
          "아주 좋은 대길의 인연과 매우 좋지 않은 인연이 동시에 찾아오는 시기입니다."
        );
        relationParts.push(
          "사람과의 인연에 대해서 생각을 많이 하게 될 것입니다."
        );
        relationParts.push(
          "그러나, 좋은 운으로 이끄는 하늘의 기운이 나를 더욱 강하게 보호하고 있으니 머지않아 사람의 인연이 복을 가져오기 시작할 것입니다."
        );
        relationParts.push(
          "일과 관련된 만남이나 이성적인 만남에서 사람을 구분하고 선택하는데 다소 어려움과 고민이 있겠지만 크게 신경을 쓰지 않아도 되겠습니다."
        );
        relationParts.push(
          "재물과 관련된 제의를 하거나 자신의 금전적인 이익을 목적으로 하면서 접근하는 만남은 큰 화를 당하게 될 수 있는 좋지 않은 인연으로 생각하시면 되며, 일과 상관없이 일상적인 만남 중에서 이루어지는 만남은 좋은 인연을 만날 수 있는 징조입니다."
        );
        relationParts.push(
          "일 이외의 일상적인 만남이나 이성적인 만남은 좋은 운을 만드는 시발점이기 때문에 만남을 통해서 도움을 주어야 할 사람은 도움을 베풀어 주어야 합니다."
        );
        relationParts.push(
          "내가 도움을 주는 사람은 좋은 인연으로 남을 것이고 나중에 반드시 보은을 입게 될 것입니다."
        );
        relationParts.push(
          "다만, 이 시기에 만나는 사람들 중에 자신에게 좋은 말만 하거나 달콤한 제의를 하면서 다가오는 사람은 반드시 경계하고 주의가 필요한 사람이 될 것입니다."
        );
        relationParts.push(
          "이성과의 애정이 타오를 수 있는 시기이니 이성을 새롭게 만나면 짧은 시간 안에 정을 느끼고 사랑의 감정이 싹틀 것입니다."
        );
        relationParts.push(
          "애정이 깊어지고 사랑이 두터워져서 서로가 정신적으로 위로를 해주고 의지하게 될 것입니다."
        );
        relationParts.push(
          "청춘 남녀는 올해에 좋은 인연을 만나게 될 수 있고 애정관계로 발전하지 않더라도 좋은 친구나 좋은 인간관계로 지속될 수가 있을 것입니다."
        );
        const relation = relationParts.join(" ");

        return { total, money, work, family, relation };
      }

      function makeReportKeywords(person) {
        const out = [];
        if (person.topElem) out.push(`강점 ${person.topElem}`);
        if (person.weakElem) out.push(`보완 ${person.weakElem}`);
        if (person.dayStem) out.push(`일간 ${person.dayStem}`);
        if (person.strength) out.push(`강약 ${person.strength}`);
        if (person.seasonTopElem) out.push(`월령 ${person.seasonTopElem}`);
        return out.length ? out.join(" · ") : "—";
      }

      function makeActionTips(person) {
        return {
          total: `핵심 행동: ${person.topElem} 기운을 중심으로 한 가지 목표를 먼저 세우고, 끝까지 흔들지 않는 것이 길합니다.`,
          money: `지출 관리: ${person.weakElem} 보완용 루틴을 하나 고정하면 새는 돈이 줄고 흐름이 안정됩니다.`,
          work: `업무 전략: ${person.topElem} 강점을 살릴 수 있는 역할을 먼저 맡아야 성과가 빠르게 드러납니다.`,
          family: `건강 루틴: 수면/식사 중 하나를 고정하면 체력과 마음이 함께 안정됩니다.`,
          relation: `관계 팁: 선을 분명히 하고 약속을 지키면 오해가 줄고 신뢰가 깊어집니다.`,
        };
      }

      const ELEM_CLASS = {
        목: "wood",
        화: "fire",
        토: "earth",
        금: "metal",
        수: "water",
      };
      function elemClass(elem) {
        return ELEM_CLASS[elem] ? `e-${ELEM_CLASS[elem]}` : "";
      }
      function tenGodChip(label, text, elem) {
        const cls = elemClass(elem);
        return `<span class="chip ${cls}"><b>${escapeHtml(
          label
        )}</b> ${escapeHtml(text)}</span>`;
      }

      function renderReportCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderReportBlock("A", a, state.aResult));
        if (b) blocks.push(renderReportBlock("B", b, state.bResult));
        reportContent.innerHTML = blocks.join("");

        // 월별 세운 카드의 공유 버튼 이벤트 리스너 추가
        setTimeout(() => {
          reportContent.querySelectorAll("[data-month]").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const monthIndex = parseInt(btn.getAttribute("data-month-index"));
              const person = a || b;
              if (person) {
                const monthData = makeMonthlyLuck(person)[monthIndex];
                await shareMonthlyCard(monthData);
              }
            });
          });
        }, 100);
      }

      function renderReportBlock(label, person, result) {
        if (!result) return "";
        const targetYear = 2026;
        const birthYear = Number(result.input.local.slice(0, 4));
        const age = toKoreanAge(targetYear, birthYear);
        const genderLabel = person.gender === "female" ? "여자" : "남자";
        const solar = result.input.local.slice(0, 10).replaceAll("-", ".");
        const lunar = person.lunarDate ? person.lunarDate : "—";
        const hourBranch = person.includeHour ? person.hourBranch : "—";
        const hourRange = person.includeHour
          ? getHourRangeText(person.hourBranch)
          : "—";
        const hourBranchDisplay =
          hourBranch !== "—" ? `${hourBranch}(${hourRange})` : "—";
        const p = result.pillars;
        const yearTen = tenGod(person.dayStem, person.yearStem);
        const monthTen = tenGod(person.dayStem, person.monthStem);
        const dayTen = "일간";
        const hourTen = person.hourStem
          ? tenGod(person.dayStem, person.hourStem)
          : "—";
        const yearChip = tenGodChip(
          "연",
          `${p.year.stem}(${STEM_ELEM[p.year.stem]}) ${yearTen || "—"} / ${
            p.year.branch
          }(${BRANCH_ELEM[p.year.branch]})`,
          STEM_ELEM[p.year.stem]
        );
        const monthChip = tenGodChip(
          "월",
          `${p.month.stem}(${STEM_ELEM[p.month.stem]}) ${monthTen || "—"} / ${
            p.month.branch
          }(${BRANCH_ELEM[p.month.branch]})`,
          STEM_ELEM[p.month.stem]
        );
        const dayChip = tenGodChip(
          "일",
          `${p.day.stem}(${STEM_ELEM[p.day.stem]}) ${dayTen} / ${
            p.day.branch
          }(${BRANCH_ELEM[p.day.branch]})`,
          STEM_ELEM[p.day.stem]
        );
        const hourChip = p.hour
          ? tenGodChip(
              "시",
              `${p.hour.stem}(${STEM_ELEM[p.hour.stem]}) ${hourTen || "—"} / ${
                p.hour.branch
              }(${BRANCH_ELEM[p.hour.branch]})`,
              STEM_ELEM[p.hour.stem]
            )
          : `<span class="chip"><b>시</b> —</span>`;
        const coreBranches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const coreHap = listInternalPairs(coreBranches, LIUHE);
        const coreChung = listInternalPairs(coreBranches, CHUNG);
        const coreHyeong = listInternalHyeong(coreBranches);
        const hapText = coreHap.length ? coreHap.join(", ") : "—";
        const chungText = coreChung.length ? coreChung.join(", ") : "—";
        const hyeongText = coreHyeong.length ? coreHyeong.join(", ") : "—";
        const hapInterpret = coreHap.length
          ? "합이 있어 협력과 회복의 기운이 따릅니다."
          : "합이 적어 도움과 완충이 약하니 스스로 지키는 것이 중요합니다.";
        const chungInterpret = coreChung.length
          ? "충이 있어 타이밍이 엇갈리기 쉬우니 확인을 거듭해야 합니다."
          : "충이 적어 급한 충돌은 드뭅니다. 다만 방심은 금물입니다.";
        const hyeongInterpret = coreHyeong.length
          ? "형이 있어 감정의 마찰이 생길 수 있으니 언행을 절제해야 합니다."
          : "형이 적어 큰 마찰은 적습니다. 작은 불씨를 먼저 끄면 길합니다.";
        const hapAction = coreHap.length
          ? "합이 있는 날은 협업/합의를 먼저 잡는 것이 유리합니다. 사례: 계약·소개·동업 제안."
          : "합이 약하니 독단을 경계하고 조력자를 구하는 것이 좋습니다. 사례: 중요한 결정은 보류.";
        const chungAction = coreChung.length
          ? "충이 있는 날은 일정·계약을 한 번 더 점검해야 합니다. 사례: 이동·이사·변경 건."
          : "충이 적어 급변은 덜하나, 확인을 생활화해야 합니다. 사례: 약속 시간 재확인.";
        const hyeongAction = coreHyeong.length
          ? "형이 있는 날은 말의 톤과 속도를 줄여 마찰을 피해야 합니다. 사례: 가족·동료 대화."
          : "형이 적어도 감정의 여지를 남기면 길합니다. 사례: 갈등은 한 박자 늦게.";
        const coreRelationLine = `합 ${
          coreHap.length ? coreHap.join(", ") : "—"
        } · 충 ${coreChung.length ? coreChung.join(", ") : "—"} · 형 ${
          coreHyeong.length ? coreHyeong.join(", ") : "—"
        }`;
        const coreInterpret =
          coreChung.length || coreHyeong.length
            ? "충/형 기운이 있어 타이밍과 감정 조율이 관건입니다."
            : coreHap.length
            ? "합 기운이 살아 있어 협력과 회복력이 좋습니다."
            : "특이한 합/충/형이 적어 흐름이 비교적 평온합니다.";
        const narrative = makeYearNarrative(person, targetYear);
        const totalFortune = `총운은 ${person.topElem}이 힘을 얻고 ${
          person.weakElem
        }을 보완하는 흐름입니다. 세운 ${
          ganzhiYear(targetYear).text
        }의 기운이 들어오니 기준을 바로 세우면 복이 따릅니다. 조급함을 줄이고 한 가지 목표를 끝까지 붙들면 실이 적고 득이 많습니다.`;
        const tips = makeActionTips(person);
        const keywords = makeReportKeywords(person);
        const profile = makeElementProfile(person.elements);
        const evidence = makeElementEvidence(
          person.elements,
          result.elements.breakdown,
          person.topElem,
          person.weakElem
        );
        const totalSum =
          Object.values(person.elements).reduce((a, b) => a + b, 0) || 1;
        const monthList = makeMonthlyLuck(person)
          .map((m) => {
            const basis = `근거: 월령 ${m.seasonElem} · 강 ${person.topElem} · 약 ${person.weakElem}`;
            return `<div class="rule-card">
              <div class="row" style="justify-content: space-between; align-items: center;">
                <div class="section-title">${m.month}월 · ${
              m.seasonElem
            } 흐름</div>
                <div style="margin-left: auto; display: flex; align-items: center; justify-content: flex-end; gap: 6px; flex-wrap: wrap;">${formatMonthTags(
                  m.tags
                )}</div>
              </div>
              <p class="lead">${escapeHtml(m.summary)}</p>
              ${
                m.monthDetails
                  ? `<div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; border-left: 3px solid var(--accent);">
                      <p class="mini" style="line-height: 1.8; margin: 0; color: rgba(15, 23, 42, 0.8);">${escapeHtml(
                        m.monthDetails
                      )}</p>
                    </div>`
                  : ""
              }
              ${
                m.extra
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p class="mini" style="margin: 0; line-height: 1.7; color: rgba(15, 23, 42, 0.75);">${escapeHtml(
                       m.extra
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.detail
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p class="mini" style="margin: 0; line-height: 1.7; color: rgba(15, 23, 42, 0.75);">${escapeHtml(
                       m.detail
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.tip
                  ? `<div style="margin-top: 12px; padding: 10px; background: rgba(34, 197, 94, 0.08); border-radius: 6px; border-left: 3px solid rgba(34, 197, 94, 0.5);">
                     <p class="mini" style="margin: 0; line-height: 1.7; font-weight: 600; color: rgba(15, 23, 42, 0.85);">
                       <span style="color: rgba(34, 197, 94, 0.9);">💡 팁:</span> ${escapeHtml(
                         m.tip
                       )}
                     </p>
                   </div>`
                  : ""
              }
              <p class="mini">${escapeHtml(basis)}</p>
              <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
                <button class="btn compact" data-month="${
                  m.month
                }" data-month-index="${
              m.month - 1
            }" style="font-size: 12px; padding: 6px 12px;">
                  📋 공유하기
                </button>
              </div>
              <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
                <button class="btn compact" data-month="${
                  m.month
                }" data-month-index="${
              m.month - 1
            }" style="font-size: 12px; padding: 6px 12px;">
                  📋 공유하기
                </button>
              </div>
            </div>`;
          })
          .join("");

        const daewoonRaw = String(person.daewoonStartAge ?? "").trim();
        let daewoonLine = "대운 시작 나이를 입력해줘.";
        let daewoonTable = "";
        if (daewoonRaw !== "") {
          const daewoonStart = Number(daewoonRaw);
          const startYear = birthYear + daewoonStart - 1;
          const blocks = [];
          const tableRows = [];
          for (let i = 0; i < 10; i++) {
            const ageStart = daewoonStart + i * 10;
            const ganji = ganzhiYear(startYear + i * 10);
            const ganjiText = ganji.text;
            blocks.push(`${ageStart}세~ ${ganjiText}`);
            tableRows.push(
              `<tr><th>${ageStart}세~</th><td>${ganjiText}</td><td>${
                ganji.stem
              }(${STEM_ELEM[ganji.stem]}) ${ganji.branch}(${
                BRANCH_ELEM[ganji.branch]
              })</td></tr>`
            );
          }
          daewoonLine = `대운(십년단위로 변화하는 운세) : 회원님은 ${daewoonStart}살을 기준으로 하여 운세의 큰 변화가 일어납니다.`;
          daewoonTable = `
            <table class="report-table" style="margin-top: 12px;">
              <thead>
                <tr>
                  <th>나이</th>
                  <th>간지</th>
                  <th>상세</th>
                </tr>
              </thead>
              <tbody>
                ${tableRows.join("")}
              </tbody>
            </table>
            <p class="mini" style="margin-top: 8px;">※ 운세 결과로 보여지는 날짜는 양력 기준입니다.</p>
          `;
        }

        return `
          <div class="rule-card">
            <div class="section-title">${targetYear} 신토정비결 · ${label}</div>
            <div class="mini">회원님(${genderLabel}, ${age}세)</div>
            <div class="mini">양력: ${solar} · 음력: ${escapeHtml(
          lunar
        )} · 태어난 시간: ${hourBranchDisplay}</div>
            <table class="report-table">
              <thead>
                <tr>
                  <th></th>
                  <th>년</th>
                  <th>월</th>
                  <th>일</th>
                  <th>시</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>천간</th>
                  <td>${STEM_YINYANG[p.year.stem] || ""} ${p.year.stem} ${
          STEM_ELEM[p.year.stem] || ""
        } · ${yearTen || "—"}</td>
                  <td>${STEM_YINYANG[p.month.stem] || ""} ${p.month.stem} ${
          STEM_ELEM[p.month.stem] || ""
        } · ${monthTen || "—"}</td>
                  <td>${STEM_YINYANG[p.day.stem] || ""} ${p.day.stem} ${
          STEM_ELEM[p.day.stem] || ""
        } · ${dayTen}</td>
                  <td>${
                    p.hour
                      ? `${STEM_YINYANG[p.hour.stem] || ""} ${p.hour.stem} ${
                          STEM_ELEM[p.hour.stem] || ""
                        } · ${hourTen || "—"}`
                      : "—"
                  }</td>
                </tr>
                <tr>
                  <th>지지</th>
                  <td>${p.year.branch} ${BRANCH_ELEM[p.year.branch]}</td>
                  <td>${p.month.branch} ${BRANCH_ELEM[p.month.branch]}</td>
                  <td>${p.day.branch} ${BRANCH_ELEM[p.day.branch]}</td>
                  <td>${
                    p.hour
                      ? `${p.hour.branch} ${BRANCH_ELEM[p.hour.branch]}`
                      : "—"
                  }</td>
                </tr>
              </tbody>
            </table>
            <div class="mini">일주/강약: ${person.dayStem || "—"} · ${
          person.strength
        }</div>
            <div class="mini">오행: ${formatElemLine(
              "",
              person.elements,
              totalSum
            )}</div>
            <div class="mini">프로파일: 강 ${profile.strong} · 중 ${
          profile.mid
        } · 약 ${profile.weak}</div>
            <div class="mini">${escapeHtml(evidence)}</div>
            <div class="mini">세운 천간 십성: ${
              ganzhiYear(targetYear).stem
            } · ${
          person.dayStem
            ? tenGod(person.dayStem, ganzhiYear(targetYear).stem)
            : "—"
        }</div>
            <div class="mini">핵심 키워드: ${escapeHtml(keywords)}</div>
            <div class="report-section">
              <h3>명리 핵심</h3>
              <table class="report-table">
                <thead>
                  <tr>
                    <th>구분</th>
                    <th>내용</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>일간</th>
                    <td>${escapeHtml(person.dayStem || "—")}</td>
                  </tr>
                  <tr>
                    <th>강약</th>
                    <td>${escapeHtml(person.strength || "—")}</td>
                  </tr>
                  <tr>
                    <th>십성</th>
                    <td>
                      <div class="chip-row">${yearChip}${monthChip}${dayChip}${hourChip}</div>
                    </td>
                  </tr>
                  <tr>
                    <th>충/합/형</th>
                    <td>합 ${escapeHtml(hapText)} · 충 ${escapeHtml(
          chungText
        )} · 형 ${escapeHtml(hyeongText)}</td>
                  </tr>
                </tbody>
              </table>
              <p class="mini">합 해석: ${escapeHtml(hapInterpret)}</p>
              <p class="mini">합 지침: ${escapeHtml(hapAction)}</p>
              <p class="mini">충 해석: ${escapeHtml(chungInterpret)}</p>
              <p class="mini">충 지침: ${escapeHtml(chungAction)}</p>
              <p class="mini">형 해석: ${escapeHtml(hyeongInterpret)}</p>
              <p class="mini">형 지침: ${escapeHtml(hyeongAction)}</p>
            </div>
            <div class="report-section">
              <h3>총운</h3>
              <p class="mini">${escapeHtml(totalFortune)}</p>
              <p class="mini">${escapeHtml(tips.total)}</p>
            </div>
            <div class="report-section">
              <h3>총론</h3>
              <p class="mini">${escapeHtml(narrative.total)}</p>
              <p class="mini">${escapeHtml(tips.total)}</p>
            </div>
            <div class="report-section">
              <h3>재물운</h3>
              <p class="mini">${escapeHtml(narrative.money)}</p>
              <p class="mini">${escapeHtml(tips.money)}</p>
            </div>
            <div class="report-section">
              <h3>직장 / 사업운</h3>
              <p class="mini">${escapeHtml(narrative.work)}</p>
              <p class="mini">${escapeHtml(tips.work)}</p>
            </div>
            <div class="report-section">
              <h3>가정 / 건강운</h3>
              <p class="mini">${escapeHtml(narrative.family)}</p>
              <p class="mini">${escapeHtml(tips.family)}</p>
            </div>
            <div class="report-section">
              <h3>이성 / 대인관계</h3>
              <p class="mini">${escapeHtml(narrative.relation)}</p>
              <p class="mini">${escapeHtml(tips.relation)}</p>
            </div>
            <div class="report-section">
              <h3>대운(간이)</h3>
              <p class="mini">${escapeHtml(daewoonLine)}</p>
              ${daewoonTable}
            </div>
            <div class="report-section">
              <h3>월별 세운</h3>
              ${monthList}
            </div>
          </div>
        `;
      }

      function getLocalNowYear(tzOffsetMinutes, dstMode) {
        const parts = toLocalDateParts(new Date(), tzOffsetMinutes, dstMode);
        return parts.y;
      }

      function pickYearMode(relTop, relWeak) {
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";
        return mode;
      }

      function yearModeText(mode) {
        const map = {
          push: "확장/추진에 유리",
          pushPlus: "성과+회복 동시",
          recover: "정리/회복에 유리",
          brake: "속도 조절 필요",
          steady: "기본 유지",
        };
        return map[mode] || "기본 유지";
      }

      function monthModeText(mode) {
        const map = {
          push: "추진",
          pushPlus: "추진+회복",
          recover: "회복",
          brake: "제동",
          steady: "유지",
        };
        return map[mode] || "유지";
      }

      function formatMonthTags(tags) {
        if (!tags || !Array.isArray(tags) || tags.length < 3) return "";
        const [luckTag, mode, seasonElem] = tags;
        const luckText =
          luckTag === "길" ? "길운" : luckTag === "흉" ? "흉운" : "중운";
        const modeText = monthModeText(mode);
        const elemText = `${seasonElem} 기운`;

        // 색상 클래스 결정
        const luckClass =
          luckTag === "길"
            ? "chip e-wood"
            : luckTag === "흉"
            ? "chip e-fire"
            : "chip";
        const elemClassKey =
          ELEM_CLASS && ELEM_CLASS[seasonElem] ? ELEM_CLASS[seasonElem] : "";
        const elemClass = elemClassKey ? `chip e-${elemClassKey}` : "chip";

        return `
          <span class="${luckClass}" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${luckText}</span>
          <span class="chip" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${modeText}</span>
          <span class="${elemClass}" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${elemText}</span>
        `;
      }

      function buildYearFlows(person, tzOffsetMinutes, dstMode) {
        const startYear = getLocalNowYear(tzOffsetMinutes, dstMode);
        const flows = [];
        for (let i = 0; i < 10; i++) {
          const year = startYear + i;
          const pillar = ganzhiYear(year);
          const yearElem = STEM_ELEM[pillar.stem];
          const relTop = relationElem(yearElem, person.topElem);
          const relWeak = relationElem(yearElem, person.weakElem);
          const mode = pickYearMode(relTop, relWeak);
          const yearTenGod = person.dayStem
            ? tenGod(person.dayStem, pillar.stem)
            : "";
          flows.push({
            year,
            pillar,
            yearElem,
            mode,
            yearTenGod,
          });
        }
        return flows;
      }

      function summarizeDecades(flows) {
        const buckets = {};
        flows.forEach((f) => {
          const start = f.year - (f.year % 10);
          if (!buckets[start]) buckets[start] = [];
          buckets[start].push(f);
        });
        return Object.entries(buckets).map(([start, list]) => {
          const counts = list.reduce((acc, cur) => {
            acc[cur.mode] = (acc[cur.mode] || 0) + 1;
            return acc;
          }, {});
          const topMode = Object.entries(counts).sort(
            (a, b) => b[1] - a[1]
          )[0][0];
          return {
            range: `${start}~${Number(start) + 9}`,
            mode: topMode,
          };
        });
      }

      function renderLuckFlowCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderLuckBlock("A", a));
        if (b) blocks.push(renderLuckBlock("B", b));
        luckFlow.innerHTML = blocks.join("");
      }

      function renderLuckBlock(label, person) {
        const tzOffsetMinutes = person.tzOffsetMinutes ?? 540;
        const dstMode = person.dstMode || "off";
        const flows = buildYearFlows(person, tzOffsetMinutes, dstMode);
        const decades = summarizeDecades(flows);
        const decadeSummary = decades
          .map((d) => `${d.range}: ${yearModeText(d.mode)}`)
          .join(" · ");
        const daewoonNarrative = `대운은 10년 단위로 흐르는 큰 물줄기입니다. ${
          decadeSummary || "—"
        }의 결이 이어지니, 이 시기에는 방향을 크게 잡고 흔들림을 줄여야 합니다. 큰 결정은 대운의 흐름과 맞춰야 길이 열립니다.`;
        const yearLines = flows
          .map(
            (f) =>
              `${f.year}년 ${f.pillar.text}(${f.yearElem}) · ${
                f.yearTenGod ? `십성 ${f.yearTenGod} · ` : ""
              }${yearModeText(f.mode)}`
          )
          .join("<br/>");
        const sewoonNarrative =
          "세운은 해마다 결이 달라지는 흐름입니다. 강한 해에는 확장과 실행을, 약한 해에는 정리와 회복을 택해야 실이 적습니다. 해마다 기운이 바뀌니, 같은 방법을 고집하지 말고 흐름에 맞춰 조율하는 것이 길합니다.";

        return `
          <div class="rule-card">
            <div class="section-title">${label} 대운/세운 상세</div>
            <div class="mini">대운(10년): ${escapeHtml(daewoonNarrative)}</div>
            <div class="mini">세운(10년): ${yearLines}</div>
            <div class="mini">${escapeHtml(sewoonNarrative)}</div>
          </div>
        `;
      }

      function setResultVisibility(mode) {
        resultElementsCard.classList.toggle("hidden", !state.A);
        resultDeepCard.classList.toggle("hidden", !state.A);
        resultLuckCard.classList.toggle("hidden", !state.A);
        resultTodayCard.classList.toggle("hidden", mode === "newyear");
        resultRadarCard.classList.toggle("hidden", mode !== "compat");
        resultABCard.classList.toggle("hidden", mode !== "compat");
        resultRulesCard.classList.toggle("hidden", mode !== "compat");
        resultMonthlyCard.classList.toggle("hidden", mode === "today");
        tuningCard.classList.toggle("hidden", mode !== "compat");
      }

      function renderCompat() {
        const a = buildPerson(state.A);
        const b = buildPerson(state.B);
        const toneKey = toneSelect.value;
        const firedRules = evaluateRules(a, b);
        const sectionScores = calcSectionScores(firedRules);
        const totalScore = calcTotalFromSections(sectionScores);
        const coupleElements = combineElements(a.elements, b.elements);
        const coupleBreakdown = combineBreakdown(
          state.aResult?.elements?.breakdown,
          state.bResult?.elements?.breakdown
        );
        const coupleStats = getTopWeak(coupleElements);

        resultTitle.textContent = "궁합 요약";
        const includeHourMode =
          state.A?.includeHour === state.B?.includeHour
            ? Boolean(state.A?.includeHour)
            : "partial";
        renderElementsAnalysis(coupleElements, coupleBreakdown, {
          hiddenMode:
            state.aResult?.input?.hiddenMode === "on" ||
            state.bResult?.input?.hiddenMode === "on"
              ? "on"
              : "off",
          includeHour: includeHourMode,
        });
        renderDeepAnalysisCard(a, b);
        renderLuckFlowCard(a, b);
        renderSummary(totalScore, firedRules, toneKey, coupleElements);
        renderTodayCoupleBox(a, b);
        renderRadar(sectionScores);
        renderRules(firedRules, toneKey, {
          topElem: coupleStats.top,
          weakElem: coupleStats.weak,
          A_topElem: a.topElem,
          B_topElem: b.topElem,
          A_weakElem: a.weakElem,
          B_weakElem: b.weakElem,
          A_branch: a.dayBranch,
          B_branch: b.dayBranch,
          A_season: a.seasonTopElem,
          B_season: b.seasonTopElem,
        });
        renderMonthly({ elements: coupleElements });
        renderPillars(aPillarsEl, state.aResult);
        renderPillars(bPillarsEl, state.bResult);

        return { totalScore, firedRules, coupleElements };
      }

      function renderNewYear() {
        const a = buildPerson(state.A);
        const { top, weak } = getTopWeak(a.elements);
        resultTitle.textContent = "신년운세 상세";
        renderElementsAnalysis(a.elements, state.aResult?.elements?.breakdown, {
          hiddenMode: state.aResult?.input?.hiddenMode,
          includeHour: state.A?.includeHour,
          boundaryText: state.A?.boundaryText,
          birthText: state.aResult?.input?.local
            ? `${state.aResult.input.local} (${state.A?.hourBranch || "—"})`
            : "",
          anchorKey: state.aResult?.elements?.anchor?.key,
          anchorApplied: state.aResult?.elements?.anchor?.applied,
          dayElem: a.dayElem,
        });
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "—";
        summarySub.textContent = "2026 흐름 · 상세 해석";
        summaryMain.textContent = `2026년은 ${top} 기운이 힘을 얻고, ${weak}을(를) 보완하면 복이 따르는 해입니다. 일간 ${
          a.dayStem || "—"
        }의 강약은 ${
          a.strength
        }이니, 무리한 확장보다 기준을 세우고 한 가지 목표를 끝까지 밀어야 실이 적습니다. 세운의 결을 읽고 속도를 조절하면 기회가 쌓이고 결과가 단단해집니다.`;
        summaryPills.innerHTML = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          "2026 월별 흐름",
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = "—";
        todayCoupleMeta.textContent = "";
        renderMonthly(a);
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";

        return { totalScore: null, coupleElements: a.elements };
      }

      function renderTodayOnly() {
        const a = buildPerson(state.A);
        resultTitle.textContent = "오늘운세 요약";
        renderElementsAnalysis(a.elements, state.aResult?.elements?.breakdown, {
          hiddenMode: state.aResult?.input?.hiddenMode,
          includeHour: state.A?.includeHour,
          boundaryText: state.A?.boundaryText,
          birthText: state.aResult?.input?.local
            ? `${state.aResult.input.local} (${state.A?.hourBranch || "—"})`
            : "",
          anchorKey: state.aResult?.elements?.anchor?.key,
          anchorApplied: state.aResult?.elements?.anchor?.applied,
          dayElem: a.dayElem,
        });
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "—";
        summarySub.textContent = "오늘 일진 기반";
        summaryMain.textContent = todayLuckLine(a);
        summaryPills.innerHTML = [
          `핵심 오행: ${a.topElem}`,
          `약한 오행: ${a.weakElem}`,
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = todayLuckLine(a);
        todayCoupleMeta.textContent = `오늘 오행: ${
          getTodayElementFlow().stemElem
        }/${getTodayElementFlow().branchElem}`;
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";
      }

      function renderAll() {
        if (!state.A) return;
        setResultVisibility(state.mode);
        if (state.mode === "compat") return renderCompat();
        if (state.mode === "newyear") return renderNewYear();
        return renderTodayOnly();
      }

      /* ======================================================
  10. 공유 카드
====================================================== */
      function roundRect(ctx, x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let i = 0; i < words.length; i++) {
          const test = line + words[i] + " ";
          if (ctx.measureText(test).width > maxWidth && i > 0) {
            ctx.fillText(line, x, y);
            line = words[i] + " ";
            y += lineHeight;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, y);
      }

      async function generateShareCard(payload) {
        const c = document.getElementById("shareCanvas");
        const ctx = c.getContext("2d");

        const g = ctx.createLinearGradient(0, 0, 0, c.height);
        g.addColorStop(0, "#0b1621");
        g.addColorStop(0.5, "#101f2e");
        g.addColorStop(1, "#14273b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, c.width, c.height);

        const pad = 70;
        const cardX = pad;
        const cardY = pad;
        const cardW = c.width - pad * 2;
        const cardH = c.height - pad * 2;
        roundRect(
          ctx,
          cardX,
          cardY,
          cardW,
          cardH,
          40,
          "rgba(255,255,255,0.92)"
        );

        ctx.fillStyle = "#0f172a";
        ctx.font = "800 52px IBM Plex Sans KR";
        ctx.fillText(payload.title, cardX + 50, cardY + 120);

        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.toneLabel, cardX + 50, cardY + 170);

        ctx.font = "800 110px IBM Plex Sans KR";
        ctx.fillStyle = "#0f172a";
        ctx.fillText(String(payload.scoreText), cardX + 50, cardY + 300);
        ctx.font = "700 30px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.7)";
        ctx.fillText(payload.scoreLabel, cardX + 50, cardY + 350);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.85)";
        ctx.fillText(`핵심 오행: ${payload.topElem}`, cardX + 50, cardY + 430);

        ctx.font = "700 32px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        wrapText(
          ctx,
          `요약: ${payload.summary}`,
          cardX + 50,
          cardY + 510,
          cardW - 100,
          44
        );

        ctx.font = "700 28px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.78)";
        wrapText(
          ctx,
          payload.todayLine,
          cardX + 50,
          cardY + 700,
          cardW - 100,
          40
        );

        ctx.font = "700 26px IBM Plex Sans KR";
        ctx.fillStyle = "rgba(15,23,42,0.6)";
        ctx.fillText("funnyfunny.cloud", cardX + 50, cardY + cardH - 70);

        return new Promise((resolve) => c.toBlob(resolve, "image/png", 1.0));
      }

      function getSharePayload(snapshot) {
        if (state.mode === "compat") {
          return {
            title: "궁합 리포트",
            toneLabel: TONE[toneSelect.value]?.title || "커플 모드",
            scoreText: snapshot.totalScore,
            scoreLabel: "궁합 점수",
            summary: summaryMain.textContent,
            todayLine: todayCoupleLine.textContent,
            topElem: getTopWeak(snapshot.coupleElements).top,
          };
        }
        if (state.mode === "newyear") {
          const topElem = getTopWeak(state.A.elements).top;
          return {
            title: "신년운세 리포트",
            toneLabel: "2026 흐름",
            scoreText: "—",
            scoreLabel: "운세 요약",
            summary: summaryMain.textContent,
            todayLine: "월별 흐름으로 계획 세우기 좋다.",
            topElem,
          };
        }
        const topElem = getTopWeak(state.A.elements).top;
        return {
          title: "오늘운세",
          toneLabel: "일진 기반",
          scoreText: "—",
          scoreLabel: "오늘 흐름",
          summary: summaryMain.textContent,
          todayLine: todayCoupleLine.textContent,
          topElem,
        };
      }

      async function shareCard() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }
        const snapshot = renderAll() || {
          totalScore: "—",
          coupleElements: state.A.elements,
        };
        const blob = await generateShareCard(getSharePayload(snapshot));

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `운세카드_${new Date().toISOString().slice(0, 10)}.png`;
        a.click();

        try {
          await navigator.clipboard.write([
            new ClipboardItem({ "image/png": blob }),
          ]);
          shareStatus.textContent = "카드를 생성하고 클립보드에 복사했어.";
        } catch {
          shareStatus.textContent = "카드를 생성했어. 다운로드를 확인해줘.";
        }
      }

      /* ======================================================
  11. PDF 저장 (html2canvas + jsPDF)
====================================================== */
      async function savePdfPretty() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }
        if (!window.html2canvas || !window.jspdf) {
          alert("PDF 라이브러리가 준비되지 않았어.");
          return;
        }
        const area = document.getElementById("pdfArea");
        const canvas = await html2canvas(area, {
          scale: 2,
          backgroundColor: null,
          useCORS: true,
          logging: false,
        });
        const imgData = canvas.toDataURL("image/png", 1.0);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;

        if (imgH <= pageH) {
          pdf.addImage(imgData, "PNG", 0, 0, imgW, imgH);
        } else {
          let y = 0;
          let remaining = imgH;
          while (remaining > 0) {
            pdf.addImage(imgData, "PNG", 0, -y, imgW, imgH);
            remaining -= pageH;
            y += pageH;
            if (remaining > 0) pdf.addPage();
          }
        }

        const fileName = `운세리포트_${new Date()
          .toISOString()
          .slice(0, 10)}.pdf`;
        pdf.save(fileName);
      }

      /* ======================================================
  12. 입력/계산 파이프라인
====================================================== */
      function loadInputs() {
        try {
          return JSON.parse(localStorage.getItem(INPUT_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveInputs(data) {
        localStorage.setItem(INPUT_KEY, JSON.stringify(data));
      }

      function setInputs(data) {
        if (!data) return;
        aDate.value = data.aDate || "";
        aHourBranch.value = data.aHourBranch || "자";
        aTimeUnknown.checked = Boolean(data.aTimeUnknown);
        aGender.value = data.aGender || "male";
        aDaewoonStart.value = data.aDaewoonStart || "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = data.aTzOffset ?? "9";
        aDstMode.value = data.aDstMode || "off";
        bDate.value = data.bDate || "";
        bHourBranch.value = data.bHourBranch || "자";
        bTimeUnknown.checked = Boolean(data.bTimeUnknown);
        bGender.value = data.bGender || "female";
        bDaewoonStart.value = data.bDaewoonStart || "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = data.bTzOffset ?? "9";
        bDstMode.value = data.bDstMode || "off";
        toneSelect.value = data.tone || "couple";
      }

      function getInputData() {
        return {
          aDate: aDate.value,
          aHourBranch: aHourBranch.value,
          aTimeUnknown: aTimeUnknown.checked,
          aGender: aGender.value,
          aLunar: "",
          aDaewoonStart: aDaewoonStart.value,
          aHiddenMode: "on",
          aTzOffset: aTzOffset.value,
          aDstMode: aDstMode.value,
          bDate: bDate.value,
          bHourBranch: bHourBranch.value,
          bTimeUnknown: bTimeUnknown.checked,
          bGender: bGender.value,
          bLunar: "",
          bDaewoonStart: bDaewoonStart.value,
          bHiddenMode: "on",
          bTzOffset: bTzOffset.value,
          bDstMode: bDstMode.value,
          tone: toneSelect.value,
          mode: state.mode,
        };
      }

      function configureInputForMode(mode) {
        const gridContainer = panelA.parentElement;
        if (mode === "compat") {
          inputTitle.textContent = "궁합 입력";
          inputDesc.textContent = "A/B 출생 정보 입력 → 궁합 계산";
          panelB.classList.remove("hidden");
          toneRow.classList.remove("hidden");
          gridContainer.style.display = "grid";
          gridContainer.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
          gridContainer.style.justifyItems = "stretch";
          panelA.style.maxWidth = "none";
        } else if (mode === "newyear") {
          inputTitle.textContent = "신년운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 2026 흐름";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
          gridContainer.style.display = "flex";
          gridContainer.style.justifyContent = "center";
          panelA.style.maxWidth = "500px";
        } else {
          inputTitle.textContent = "오늘운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 오늘 한 줄";
          panelB.classList.add("hidden");
          toneRow.classList.add("hidden");
          gridContainer.style.display = "flex";
          gridContainer.style.justifyContent = "center";
          panelA.style.maxWidth = "500px";
        }
      }

      function showStep(name) {
        stepMenu.classList.toggle("active", name === "menu");
        stepInput.classList.toggle("active", name === "input");
        stepResult.classList.toggle("active", name === "result");
      }

      async function computePair() {
        try {
          const data = getInputData();
          if (!data.aDate || !data.aHourBranch) {
            alert("A 날짜와 12간지를 선택해줘.");
            return;
          }
          if (state.mode === "compat" && (!data.bDate || !data.bHourBranch)) {
            alert("B 날짜와 12간지를 선택해줘.");
            return;
          }
          saveInputs(data);

          loadingOverlay.classList.add("active");
          loadingOverlay.setAttribute("aria-hidden", "false");
          await new Promise((r) => setTimeout(r, 700));

          const aOffsetMin = parseTzOffsetMinutes(data.aTzOffset, 540);
          const aIncludeHour = !data.aTimeUnknown;
          const aTimeStr = aIncludeHour
            ? hourBranchToTime(data.aHourBranch)
            : "12:00";
          if (!data.aDate) {
            throw new Error("A 날짜가 입력되지 않았습니다.");
          }
          const aBirth = parseLocalDateTime(
            data.aDate,
            aTimeStr,
            aOffsetMin,
            data.aDstMode
          );
          if (!aBirth || isNaN(aBirth.getTime())) {
            throw new Error(
              "A 날짜/시간 파싱 실패: " + data.aDate + " " + aTimeStr
            );
          }
          const aHourBranch = aIncludeHour ? data.aHourBranch : null;
          const aResult = computeSajuFiveElements(aBirth, {
            ziMode: "2300",
            hiddenMode: "on", // 항상 on으로 고정
            tzOffsetMinutes: aOffsetMin,
            dstMode: data.aDstMode,
            includeHour: aIncludeHour,
            hourBranchOverride: aHourBranch,
          });
          if (!aResult || !aResult.elements || !aResult.pillars) {
            throw new Error("A 사주 계산 실패");
          }
          state.aResult = aResult;
          state.A = {
            name: "A",
            elements: aResult.elements.raw,
            dayBranch: aResult.pillars.day.branch,
            monthBranch: aResult.pillars.month.branch,
            yearBranch: aResult.pillars.year.branch,
            yearStem: aResult.pillars.year.stem,
            monthStem: aResult.pillars.month.stem,
            dayStem: aResult.pillars.day.stem,
            hourStem: aResult.pillars.hour ? aResult.pillars.hour.stem : "",
            tzOffsetMinutes: aOffsetMin,
            dstMode: data.aDstMode,
            includeHour: aIncludeHour,
            hourBranch: aHourBranch,
            boundaryText: makeBoundaryText(),
            altResult: null,
            gender: data.aGender,
            lunarDate: data.aLunar,
            daewoonStartAge: data.aDaewoonStart,
          };

          if (state.mode === "compat") {
            const bOffsetMin = parseTzOffsetMinutes(data.bTzOffset, 540);
            const bIncludeHour = !data.bTimeUnknown;
            const bTimeStr = bIncludeHour
              ? hourBranchToTime(data.bHourBranch)
              : "12:00";
            if (!data.bDate) {
              throw new Error("B 날짜가 입력되지 않았습니다.");
            }
            const bBirth = parseLocalDateTime(
              data.bDate,
              bTimeStr,
              bOffsetMin,
              data.bDstMode
            );
            if (!bBirth || isNaN(bBirth.getTime())) {
              throw new Error(
                "B 날짜/시간 파싱 실패: " + data.bDate + " " + bTimeStr
              );
            }
            const bHourBranch = bIncludeHour ? data.bHourBranch : null;
            const bResult = computeSajuFiveElements(bBirth, {
              ziMode: "2300",
              hiddenMode: "on", // 항상 on으로 고정
              tzOffsetMinutes: bOffsetMin,
              dstMode: data.bDstMode,
              includeHour: bIncludeHour,
              hourBranchOverride: bHourBranch,
            });
            if (!bResult || !bResult.elements || !bResult.pillars) {
              throw new Error("B 사주 계산 실패");
            }
            state.bResult = bResult;
            state.B = {
              name: "B",
              elements: bResult.elements.raw,
              dayBranch: bResult.pillars.day.branch,
              monthBranch: bResult.pillars.month.branch,
              yearBranch: bResult.pillars.year.branch,
              yearStem: bResult.pillars.year.stem,
              monthStem: bResult.pillars.month.stem,
              dayStem: bResult.pillars.day.stem,
              hourStem: bResult.pillars.hour ? bResult.pillars.hour.stem : "",
              tzOffsetMinutes: bOffsetMin,
              dstMode: data.bDstMode,
              includeHour: bIncludeHour,
              hourBranch: bHourBranch,
              boundaryText: makeBoundaryText(),
              altResult: null,
              gender: data.bGender,
              lunarDate: data.bLunar,
              daewoonStartAge: data.bDaewoonStart,
            };
          } else {
            state.bResult = null;
            state.B = null;
          }

          showStep("result");
          renderAll();

          await new Promise((r) => setTimeout(r, 400));
        } catch (error) {
          console.error("계산 중 오류 발생:", error);
          alert(
            "계산 중 오류가 발생했습니다. 입력값을 확인해주세요.\n오류: " +
              error.message
          );
        } finally {
          loadingOverlay.classList.remove("active");
          loadingOverlay.setAttribute("aria-hidden", "true");
        }
      }

      /* ======================================================
  INIT
====================================================== */
      function init() {
        const cfg = loadTuneCfg();
        tuneStrength.value = String(cfg.strength ?? 1);
        tuneLabel.textContent = Number(tuneStrength.value).toFixed(1);
        updateTuneStatus();
        const saved = loadInputs();
        setInputs(saved);
        if (saved.mode) {
          state.mode = saved.mode;
          configureInputForMode(state.mode);
          showStep("input");
        }
      }

      document.querySelectorAll(".menu-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.mode = btn.dataset.mode;
          configureInputForMode(state.mode);
          showStep("input");
        });
      });

      backToMenu.addEventListener("click", () => showStep("menu"));
      clearSaved.addEventListener("click", () => {
        localStorage.removeItem(INPUT_KEY);
        aDate.value = "";
        aHourBranch.value = "자";
        aTimeUnknown.checked = false;
        aGender.value = "male";
        aDaewoonStart.value = "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = "9";
        aDstMode.value = "off";
        bDate.value = "";
        bHourBranch.value = "자";
        bTimeUnknown.checked = false;
        bGender.value = "female";
        bDaewoonStart.value = "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = "9";
        bDstMode.value = "off";
        toneSelect.value = "couple";
        alert("저장된 입력을 초기화했어.");
      });
      backToInput.addEventListener("click", () => showStep("input"));
      restartFlow.addEventListener("click", () => showStep("menu"));

      document.addEventListener("click", (e) => {
        const btn = e.target.closest(".like-btn");
        if (!btn) return;
        const ruleId = btn.dataset.rule;
        feedback(ruleId);
        btn.textContent = "공감됨 ✔";
        btn.disabled = true;
      });

      tuneStrength.addEventListener("input", () => {
        const v = Number(tuneStrength.value);
        tuneLabel.textContent = v.toFixed(1);
        saveTuneCfg({ strength: v });
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      tuneReset.addEventListener("click", () => {
        localStorage.removeItem(TUNE_KEY);
        updateTuneStatus();
        if (state.mode === "compat") renderAll();
      });

      toneSelect.addEventListener("change", () => {
        saveInputs(getInputData());
        if (state.mode === "compat") renderAll();
      });

      todayLuckBtn.addEventListener("click", () => {
        if (state.mode === "compat" && state.A && state.B) {
          renderTodayCoupleBox(buildPerson(state.A), buildPerson(state.B));
        } else if (state.A) {
          todayCoupleLine.textContent = todayLuckLine(buildPerson(state.A));
          todayCoupleMeta.textContent = `오늘 오행: ${
            getTodayElementFlow().stemElem
          }/${getTodayElementFlow().branchElem}`;
        }
      });

      shareBtn.addEventListener("click", shareCard);
      pdfBtn.addEventListener("click", savePdfPretty);
      calcBtn.addEventListener("click", computePair);

      init();
    </script>
  </body>
</html>
