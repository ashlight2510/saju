<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>사주풀이 · 궁합 · 오늘운세 · 신년운세</title>
    <meta
      property="og:image"
      content="https://dummyimage.com/1200x630/0b1220/ffffff&text=SAJU"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:image"
      content="https://dummyimage.com/1200x630/0b1220/ffffff&text=SAJU"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🔮</text></svg>"
    />

    <!-- Adsense (요청 반영) -->
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;600;800&family=Playfair+Display:wght@700;800&family=Noto+Serif+KR:wght@400;600;700&display=swap");

      :root {
        --bg1: #0a0f1a;
        --bg2: #0f1623;
        --bg3: #141b2d;
        --card: rgba(255, 255, 255, 0.98);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.7);
        --line: rgba(15, 23, 42, 0.08);
        --accent: #6366f1;
        --accent-hover: #4f46e5;
        --accent2: #f59e0b;
        --accent-grad: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.1);
        --shadow-hover: 0 24px 80px rgba(99, 102, 241, 0.2),
          0 0 0 1px rgba(255, 255, 255, 0.15);
        --radius: 20px;
        --radius-sm: 14px;
        --font-body: "IBM Plex Sans KR", "Apple SD Gothic Neo", sans-serif;
        --font-title: "Playfair Display", "Nanum Myeongjo", serif;
        --font-service: "Noto Serif KR", "Nanum Myeongjo", serif;
      }

      * {
        box-sizing: border-box;
      }
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(99, 102, 241, 0.3);
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(99, 102, 241, 0.5);
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: radial-gradient(
            1400px 700px at 8% -5%,
            rgba(99, 102, 241, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            1200px 600px at 92% 5%,
            rgba(139, 92, 246, 0.12) 0%,
            transparent 50%
          ),
          radial-gradient(
            1000px 500px at 50% 100%,
            rgba(59, 130, 246, 0.08) 0%,
            transparent 60%
          ),
          linear-gradient(
            180deg,
            var(--bg1) 0%,
            var(--bg2) 50%,
            var(--bg3) 100%
          );
        color: rgba(255, 255, 255, 0.95);
        font-size: 16px;
        position: relative;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(99, 102, 241, 0.03) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(139, 92, 246, 0.03) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 0;
      }
      .wrap {
        max-width: 1080px;
        margin: 16px auto;
        padding: 32px 20px 56px;
        position: relative;
        z-index: 1;
      }
      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }
      h1 {
        font-family: var(--font-title);
        font-weight: 800;
        letter-spacing: 0.02em;
        font-size: 32px;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .logo-emoji {
        display: inline-block;
        width: 1.05em;
        height: 1.05em;
        margin-right: 8px;
        vertical-align: -0.12em;
        background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0' stop-color='%238b5cf6'/%3E%3Cstop offset='1' stop-color='%236366f1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='32' cy='26' r='18' fill='url(%23g)'/%3E%3Ccircle cx='26' cy='20' r='6' fill='rgba(255,255,255,0.8)'/%3E%3Cpath d='M18 50c6 4 22 4 28 0' fill='none' stroke='%236366f1' stroke-width='4' stroke-linecap='round'/%3E%3Crect x='22' y='46' width='20' height='6' rx='3' fill='%237c3aed'/%3E%3C/svg%3E")
          no-repeat center/contain;
        filter: drop-shadow(0 2px 6px rgba(99, 102, 241, 0.3));
      }
      .logo-text {
        -webkit-text-fill-color: transparent;
      }
      h2 {
        font-size: 24px;
        font-weight: 800;
        color: var(--text);
      }
      h3 {
        font-size: 19px;
        font-weight: 800;
        color: var(--text);
      }
      .hero {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        margin-bottom: 24px;
        padding: 16px 0;
      }
      .badge {
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 0.08em;
        padding: 12px 20px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        font-family: var(--font-service);
      }
      .badge.service-name {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.1em;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.2) 0%,
          rgba(139, 92, 246, 0.2) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.3);
        color: rgba(255, 255, 255, 0.98);
        text-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
      }
      .badge:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      }
      .badge.service-name:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.25) 0%,
          rgba(139, 92, 246, 0.25) 100%
        );
        border-color: rgba(99, 102, 241, 0.4);
        box-shadow: 0 6px 20px rgba(99, 102, 241, 0.25);
      }
      .card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 28px;
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: var(--shadow);
        backdrop-filter: blur(20px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent-grad);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-hover);
      }
      .card:hover::before {
        opacity: 1;
      }
      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .card-head.center {
        justify-content: center;
        text-align: center;
      }
      .score {
        font-size: 36px;
        font-weight: 800;
        background: var(--accent-grad);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .lead {
        font-size: 1.2rem;
        font-weight: 800;
        line-height: 1.7;
        color: var(--text);
      }
      .mini {
        font-size: 0.95rem;
        color: var(--muted);
        font-weight: 600;
        line-height: 1.7;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
      }
      .row.center {
        justify-content: center;
      }
      .btn {
        padding: 14px 20px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        cursor: pointer;
        background: var(--accent-grad);
        color: #fff;
        font-size: 15px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        position: relative;
        overflow: hidden;
        z-index: 1;
      }
      .btn::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
        z-index: -1;
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      }
      .btn:hover::before {
        width: 300px;
        height: 300px;
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn * {
        position: relative;
        z-index: 1;
      }
      .btn.outline {
        background: rgba(255, 255, 255, 0.95);
        color: var(--text);
        border: 2px solid rgba(15, 23, 42, 0.1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }
      .btn.outline:hover {
        background: #fff;
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
      }
      .btn.ghost {
        background: rgba(15, 23, 42, 0.06);
        color: var(--text);
        border: 1px solid rgba(15, 23, 42, 0.12);
        box-shadow: none;
      }
      .btn.ghost:hover {
        background: rgba(15, 23, 42, 0.1);
        border-color: rgba(15, 23, 42, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .btn.compact {
        display: inline-flex;
        align-items: center;
        padding: 12px 20px;
        font-size: 14px;
        font-weight: 700;
        box-shadow: none;
      }
      .btn.outline.compact {
        border-width: 1px;
      }
      select,
      input[type="range"],
      input[type="date"],
      input[type="time"],
      input[type="number"],
      input[type="text"] {
        padding: 12px 14px;
        border-radius: var(--radius-sm);
        border: 2px solid rgba(15, 23, 42, 0.12);
        font-weight: 600;
        font-size: 15px;
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.98);
        width: 100%;
        flex: 1;
        min-width: 0;
        box-sizing: border-box;
        height: 48px;
        line-height: 1.5;
      }
      select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236366f1' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px;
        padding-right: 36px;
        cursor: pointer;
      }
      .rule-card .row {
        width: 100%;
        display: flex;
        align-items: stretch;
        gap: 12px;
      }
      .rule-card .row > * {
        flex: 1;
        min-width: 120px;
      }
      .rule-card .row:not(:first-child) {
        margin-top: 12px;
      }
      .rule-card p.mini {
        margin-top: 12px;
        margin-bottom: 0;
        text-align: left;
        font-size: 0.9rem;
      }
      select:focus,
      input[type="text"]:focus,
      input[type="date"]:focus,
      input[type="time"]:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }
      input[type="checkbox"] {
        transform: translateY(1px);
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }
      .rule-card {
        border: 1px solid var(--line);
        border-radius: var(--radius-sm);
        padding: 20px;
        margin-bottom: 12px;
        background: rgba(255, 255, 255, 0.98);
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .rule-card:hover {
        border-color: rgba(99, 102, 241, 0.2);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
      }
      .rule-card h3 {
        margin-bottom: 16px;
        text-align: left;
        font-size: 18px;
      }
      .rule-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .radar {
        width: 100%;
        max-width: 420px;
        margin: 12px auto 0;
        display: block;
      }
      .elements-radar {
        max-width: 600px;
        width: 100%;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 20px;
        max-width: 100%;
      }
      .input-container {
        max-width: 900px;
        margin: 16px auto;
      }
      .pill-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 800;
        padding: 8px 14px;
        border-radius: 999px;
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        border: 1px solid rgba(99, 102, 241, 0.15);
        transition: all 0.2s ease;
      }
      .pill:hover {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.12) 0%,
          rgba(139, 92, 246, 0.12) 100%
        );
        border-color: rgba(99, 102, 241, 0.25);
        transform: translateY(-1px);
      }
      .pill.emphasis {
        font-size: 14px;
        padding: 10px 16px;
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        color: #fff;
        border-color: rgba(79, 70, 229, 0.4);
        box-shadow: 0 6px 16px rgba(79, 70, 229, 0.35);
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: rgba(15, 23, 42, 0.06);
        color: #0f172a;
        font-weight: 800;
        line-height: 1.2;
      }
      .chip b {
        font-weight: 900;
      }
      .chip.e-wood {
        background: #e8f7e9;
        color: #0f3d2e;
        border-color: #bfe7c6;
      }
      .chip.e-fire {
        background: #ffe9e3;
        color: #7a1f16;
        border-color: #ffc5b5;
      }
      .chip.e-earth {
        background: #f8f1df;
        color: #5a3b12;
        border-color: #e7d3a7;
      }
      .chip.e-metal {
        background: #eef3ff;
        color: #1b3a70;
        border-color: #c9d6ff;
      }
      .chip.e-water {
        background: #e6f5ff;
        color: #0c3550;
        border-color: #b7e4ff;
      }
      .section-title {
        font-weight: 800;
        font-size: 1.05rem;
        color: var(--text);
        letter-spacing: -0.01em;
        text-align: left;
      }
      .share-note {
        margin-top: 10px;
      }
      .pdf-area {
        background: linear-gradient(180deg, var(--bg1), var(--bg2), var(--bg3));
        padding: 24px 24px 12px;
        border-radius: var(--radius);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .step {
        display: none;
        animation: fadeIn 0.4s ease;
      }
      .step.active {
        display: block;
      }
      .menu-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 24px;
        max-width: 800px;
        margin: 16px auto;
      }
      .menu-btn {
        border: none;
        background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
        color: var(--text);
        border-radius: 24px;
        padding: 40px 32px;
        text-align: center;
        cursor: pointer;
        font-weight: 800;
        box-shadow: 0 4px 20px rgba(15, 23, 42, 0.08),
          0 0 0 1px rgba(15, 23, 42, 0.05);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 280px;
      }
      .menu-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, transparent 0%, transparent 100%);
        opacity: 0;
        transition: opacity 0.4s ease;
      }
      .menu-btn[data-mode="newyear"] {
        background: linear-gradient(
          135deg,
          rgba(139, 92, 246, 0.05) 0%,
          rgba(99, 102, 241, 0.05) 100%
        );
        border: 2px solid rgba(139, 92, 246, 0.15);
      }
      .menu-btn[data-mode="newyear"]::after {
        content: "✨";
        font-size: 64px;
        position: absolute;
        top: 32px;
        opacity: 0.3;
        animation: float 3s ease-in-out infinite;
      }
      .menu-btn[data-mode="today"] {
        background: linear-gradient(
          135deg,
          rgba(34, 197, 94, 0.05) 0%,
          rgba(59, 130, 246, 0.05) 100%
        );
        border: 2px solid rgba(34, 197, 94, 0.15);
      }
      .menu-btn[data-mode="today"]::after {
        content: "🔮";
        font-size: 64px;
        position: absolute;
        top: 32px;
        opacity: 0.3;
        animation: float 3s ease-in-out infinite;
        animation-delay: 0.5s;
      }
      @keyframes float {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }
      .menu-btn:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 20px 60px rgba(99, 102, 241, 0.2),
          0 0 0 1px rgba(99, 102, 241, 0.3);
      }
      .menu-btn[data-mode="newyear"]:hover {
        background: linear-gradient(
          135deg,
          rgba(139, 92, 246, 0.1) 0%,
          rgba(99, 102, 241, 0.1) 100%
        );
        border-color: rgba(139, 92, 246, 0.4);
      }
      .menu-btn[data-mode="today"]:hover {
        background: linear-gradient(
          135deg,
          rgba(34, 197, 94, 0.1) 0%,
          rgba(59, 130, 246, 0.1) 100%
        );
        border-color: rgba(34, 197, 94, 0.4);
      }
      .menu-btn:hover::after {
        opacity: 0.5;
        transform: scale(1.1);
      }
      .menu-btn:active {
        transform: translateY(-4px) scale(1);
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 15, 26, 0.85);
        backdrop-filter: blur(12px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .loading-overlay.active {
        display: flex;
        animation: fadeIn 0.3s ease;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .loading-card {
        background: var(--card);
        color: var(--text);
        border-radius: var(--radius);
        padding: 32px 36px;
        min-width: 300px;
        text-align: center;
        box-shadow: var(--shadow-hover);
        border: 1px solid rgba(255, 255, 255, 0.3);
        animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      .spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(99, 102, 241, 0.2);
        border-top-color: var(--accent);
        margin: 0 auto 16px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .menu-btn small {
        display: block;
        margin-top: 16px;
        font-size: 15px;
        font-weight: 500;
        color: rgba(15, 23, 42, 0.7);
        line-height: 1.6;
        max-width: 240px;
      }
      .menu-btn .menu-title {
        font-size: 28px;
        font-weight: 800;
        margin-bottom: 12px;
        color: var(--text);
        position: relative;
        z-index: 1;
      }
      .menu-btn[data-mode="newyear"] .menu-title {
        background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .menu-btn[data-mode="today"] .menu-title {
        background: linear-gradient(135deg, #22c55e 0%, #3b82f6 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .report-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 14px;
        border-radius: var(--radius-sm);
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }
      .report-table th,
      .report-table td {
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 12px 14px;
        text-align: left;
        vertical-align: top;
      }
      .report-table th {
        background: linear-gradient(
          135deg,
          rgba(99, 102, 241, 0.08) 0%,
          rgba(139, 92, 246, 0.08) 100%
        );
        font-weight: 800;
        color: var(--text);
      }
      .report-table tr:hover {
        background: rgba(99, 102, 241, 0.03);
      }
      .report-section {
        margin-top: 12px;
        text-align: left;
      }
      .report-section h3 {
        margin-bottom: 6px;
        text-align: left;
      }
      .report-section p.mini {
        text-align: left;
        line-height: 1.8;
      }
      .hidden {
        display: none !important;
      }

      @media (max-width: 720px) {
        .wrap {
          padding: 24px 16px 40px;
        }
        .menu-grid {
          grid-template-columns: 1fr;
          gap: 20px;
          max-width: 100%;
        }
        .menu-btn {
          min-height: 240px;
          padding: 32px 24px;
        }
        .menu-btn .menu-title {
          font-size: 24px;
        }
        .menu-btn::after {
          font-size: 56px;
          top: 24px;
        }
        #stepInput > div:first-child {
          flex-direction: column;
          align-items: stretch;
          gap: 8px;
        }
        #stepInput > div:first-child .btn {
          width: 100%;
        }
        h1 {
          font-size: 26px;
        }
        h2 {
          font-size: 20px;
        }
        .card {
          padding: 20px;
          border-radius: var(--radius-sm);
        }
        .grid-2 {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .input-container {
          max-width: 100%;
        }
        .rule-card .row > * {
          min-width: 100%;
        }
        .card-head {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }
        .menu-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .menu-btn {
          padding: 20px 18px;
        }
        .btn {
          padding: 12px 18px;
          font-size: 14px;
        }
        .hero {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }
        .badge {
          font-size: 11px;
          padding: 8px 14px;
        }
        body {
          font-size: 15px;
        }
      }
    </style>
    <style>
    .adsense-block {
      margin: 16px 0;
      display: flex;
      justify-content: center;
    }
    .adsbygoogle {
      display: block;
      margin: 16px auto;
    }
  </style>
</head>

  <body>
    <div class="wrap">
      <div class="hero">
        <div class="badge service-name">사주풀이</div>
        <div style="display: flex; gap: 8px; align-items: center">
          <div class="badge" id="todayBadge"></div>
          <a
            href="https://funnyfunny.cloud/"
            target="_blank"
            rel="noopener noreferrer"
            class="btn outline compact"
            style="text-decoration: none; white-space: nowrap"
          >
            다른 서비스 보기
          </a>
        </div>
      </div>

      <!-- Step 1: 메뉴 -->
      <section id="stepMenu" class="step active">
        <div class="card">
          <div class="card-head">
            <div>
              <h1
                style="
                  font-family: var(--font-service);
                  font-weight: 700;
                  letter-spacing: 0.02em;
                "
              >
                <span class="logo-emoji" aria-hidden="true"></span>
                <span class="logo-text">사주풀이</span>
              </h1>
              <p class="mini">
                신년운세/오늘운세 중 선택하면 단계별로 입력받고 결과를 보여줄게.
              </p>
            </div>
          </div>
          <div class="menu-grid" style="margin-top: 32px">
            <button class="menu-btn" data-mode="newyear">
              <span class="menu-title">신년운세</span>
              <small>2026년 한 해의 흐름을<br />월별로 살펴보기</small>
            </button>
            <button class="menu-btn" data-mode="today">
              <span class="menu-title">오늘의 운세</span>
              <small>오늘 하루의 기운과<br />행동 가이드를 확인하기</small>
            </button>
          </div>
        </div>
      </section>

      <!-- Step 2: 입력 -->
      <section id="stepInput" class="step">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 12px;
          "
        >
          <button class="btn outline" id="backToMenu" style="margin: 0">
            메뉴로
          </button>
          <button
            class="btn outline"
            id="clearSaved"
            style="
              margin: 0;
              border-color: rgba(239, 68, 68, 0.4);
              color: rgba(239, 68, 68, 0.9);
              background: rgba(239, 68, 68, 0.05);
            "
          >
            저장 초기화
          </button>
        </div>
        <div class="card" id="inputCard">
          <div class="card-head center">
            <div style="width: 100%">
              <h1 id="inputTitle">입력</h1>
              <p class="mini" id="inputDesc">출생 정보 입력 → 로컬 계산</p>
            </div>
          </div>

          <div class="input-container">
            <div class="grid-2" style="margin-top: 20px">
              <div class="rule-card" id="panelA">
                <h3>출생 정보</h3>
                <div class="row">
                  <input id="aDate" type="date" />
                  <select id="aHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <label class="mini">
                    <input id="aTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="aGender">
                    <option value="male" selected>남자</option>
                    <option value="female">여자</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="aDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  날짜와 시간(12간지)을 입력한 뒤 성별만 선택하면 돼.
                </p>
                <div class="row hidden" style="margin-top: 8px">
                  <select id="aHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="aTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="aDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">신토정비결 기준으로 계산해.</p>
              </div>

              <div class="rule-card" id="panelB">
                <h3>상대 정보</h3>
                <div class="row">
                  <input id="bDate" type="date" />
                  <select id="bHourBranch">
                    <option value="자">자 (00:00-01:30)</option>
                    <option value="축">축 (01:31-03:30)</option>
                    <option value="인">인 (03:31-05:30)</option>
                    <option value="묘">묘 (05:31-07:30)</option>
                    <option value="진">진 (07:31-09:30)</option>
                    <option value="사">사 (09:31-11:30)</option>
                    <option value="오">오 (11:31-13:30)</option>
                    <option value="미">미 (13:31-15:30)</option>
                    <option value="신">신 (15:31-17:30)</option>
                    <option value="유">유 (17:31-19:30)</option>
                    <option value="술">술 (19:31-21:30)</option>
                    <option value="해">해 (21:31-23:30)</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <label class="mini">
                    <input id="bTimeUnknown" type="checkbox" />
                    시간 모름(시주 제외)
                  </label>
                </div>
                <div class="row" style="margin-top: 8px">
                  <select id="bGender">
                    <option value="male">남자</option>
                    <option value="female" selected>여자</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="bDaewoonStart"
                    type="number"
                    min="0"
                    max="20"
                    step="1"
                    placeholder="대운 시작 나이"
                  />
                </div>
                <p class="mini">
                  날짜와 시간(12간지)을 입력한 뒤 성별만 선택하면 돼.
                </p>
                <div class="row hidden" style="margin-top: 8px">
                  <select id="bHiddenMode">
                    <option value="on" selected>장간 반영</option>
                    <option value="off">장간 미반영</option>
                  </select>
                </div>
                <div class="row hidden" style="margin-top: 8px">
                  <input
                    id="bTzOffset"
                    type="number"
                    min="-12"
                    max="14"
                    step="0.5"
                    value="9"
                    placeholder="UTC+9"
                  />
                  <select id="bDstMode">
                    <option value="off" selected>DST 미반영</option>
                    <option value="kr1988">한국 DST(1988) 반영</option>
                  </select>
                </div>
                <p class="mini">신토정비결 기준으로 계산해.</p>
              </div>
            </div>

            <div class="row center" style="margin-top: 24px; gap: 8px">
              <span
                class="mini"
                style="font-size: 0.85rem; color: rgba(15, 23, 42, 0.5)"
              >
                ※ 입력 시간은 한국 기준으로 계산해.
              </span>
            </div>
          </div>
          <div style="margin-top: 32px; text-align: center">
            <button
              class="btn"
              id="calcBtn"
              style="
                min-width: 200px;
                padding: 14px 32px;
                font-size: 16px;
                font-weight: 700;
              "
            >
              확인하기
            </button>
          </div>
        </div>
      </section>

      <!-- Step 3: 결과 -->
      <section id="stepResult" class="step">
        <div class="row" style="margin-bottom: 12px">
          <button class="btn outline" id="backToInput">입력 수정</button>
          <button class="btn outline" id="restartFlow">메뉴로</button>
        </div>

        <div id="pdfArea" class="pdf-area">
          <div class="card" id="resultElementsCard" style="padding: 40px">
            <h2 style="font-size: 28px; margin-bottom: 24px">오행 기운 분석</h2>
            <p
              class="lead"
              id="elementsSummary"
              style="font-size: 18px; margin-bottom: 32px"
            ></p>
            <svg
              id="elementsRadarSvg"
              class="radar elements-radar"
              viewBox="0 0 320 320"
              style="
                width: 100%;
                max-width: 500px;
                height: auto;
                margin: 0 auto 32px;
                display: block;
              "
            ></svg>
            <p
              class="mini"
              id="elementsDetail"
              style="font-size: 14px; line-height: 1.8"
            >
              —
            </p>
          </div>
          <div class="card" id="resultDeepCard">
            <h2>심화 분석</h2>
            <div id="deepAnalysis"></div>
          </div>
          <div class="card" id="resultLuckCard">
            <h2>대운 · 세운</h2>
            <div id="luckFlow"></div>
          </div>
          <div class="card" id="resultReportCard">
            <h2>본질 리포트</h2>
            <div id="reportContent"></div>
          </div>
          <div class="card" id="resultSummaryCard">
            <div class="card-head">
              <div>
                <h2 id="resultTitle">궁합 요약</h2>
                <p class="mini" id="summarySub">
                  입력 시간대 기준 · 절기/오행 규칙
                </p>
              </div>
              <div class="score" id="totalScore">—</div>
            </div>
            <p class="lead" id="summaryMain">—</p>
            <div class="pill-row" id="summaryPills"></div>
          </div>

          <div class="card" id="resultTodayCard">
            <h2 style="margin-bottom: 20px; text-align: left">
              🔮 오늘의 운세
            </h2>
            <p
              class="lead"
              id="todayCoupleLine"
              style="
                font-size: 19px;
                line-height: 1.7;
                margin-bottom: 0;
                font-weight: 600;
                color: rgba(15, 23, 42, 0.9);
              "
            >
              —
            </p>
            <div id="todayCoupleMeta" style="margin-top: 0">—</div>
          </div>

          <div class="grid-2" id="resultCompatGrid">
            <div class="card" id="resultRadarCard">
              <h2>섹션별 균형</h2>
              <svg
                id="sectionRadarSvg"
                class="radar"
                viewBox="0 0 320 320"
              ></svg>
              <p class="mini" id="sectionRadarLegend">관계의 전체 밸런스</p>
            </div>

            <div class="card" id="resultABCard">
              <h2>A/B 사주 요약</h2>
              <div class="grid-2" style="gap: 8px">
                <div>
                  <div class="section-title">A</div>
                  <div id="aPillars" class="mini"></div>
                </div>
                <div>
                  <div class="section-title">B</div>
                  <div id="bPillars" class="mini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="card" id="resultRulesCard">
            <h2>궁합 포인트</h2>
            <div id="ruleList"></div>
          </div>

          <div class="card" id="resultMonthlyCard">
            <h2>2026 신년운세 (월별)</h2>
            <div id="monthlyList"></div>
          </div>
        </div>

        <div class="card" id="shareCard" style="margin-top: 48px">
          <h2>공유 · PDF</h2>
          <div class="row">
            <button class="btn" id="shareBtn">공유</button>
            <button class="btn outline" id="pdfBtn">PDF 저장</button>
          </div>
          <p class="mini share-note" id="shareStatus"></p>
          <canvas
            id="shareCanvas"
            width="1080"
            height="1350"
            style="display: none"
          ></canvas>
        </div>
      </section>
    </div>

    <div class="loading-overlay" id="loadingOverlay" aria-hidden="true">
      <div class="loading-card">
        <div class="spinner"></div>
        <div class="lead" style="margin-bottom: 6px">오행 균형 계산 중</div>
        <div class="mini">절기 기준으로 정밀하게 맞추는 중이야…</div>
      </div>
    </div>

    <script src="./vendor/html2canvas.min.js"></script>
    <script src="./vendor/jspdf.umd.min.js"></script>

    <script>
      /* ======================================================
  0. 기본 DOM
====================================================== */
      const todayBadge = document.getElementById("todayBadge");
      todayBadge.textContent = "신토정비결";

      const stepMenu = document.getElementById("stepMenu");
      const stepInput = document.getElementById("stepInput");
      const stepResult = document.getElementById("stepResult");

      const inputTitle = document.getElementById("inputTitle");
      const inputDesc = document.getElementById("inputDesc");
      const panelA = document.getElementById("panelA");
      const panelB = document.getElementById("panelB");

      const aDate = document.getElementById("aDate");
      const aHourBranch = document.getElementById("aHourBranch");
      const aTimeUnknown = document.getElementById("aTimeUnknown");
      const aGender = document.getElementById("aGender");
      const aDaewoonStart = document.getElementById("aDaewoonStart");
      const aHiddenMode = document.getElementById("aHiddenMode");
      const aTzOffset = document.getElementById("aTzOffset");
      const aDstMode = document.getElementById("aDstMode");
      const bDate = document.getElementById("bDate");
      const bHourBranch = document.getElementById("bHourBranch");
      const bTimeUnknown = document.getElementById("bTimeUnknown");
      const bGender = document.getElementById("bGender");
      const bDaewoonStart = document.getElementById("bDaewoonStart");
      const bHiddenMode = document.getElementById("bHiddenMode");
      const bTzOffset = document.getElementById("bTzOffset");
      const bDstMode = document.getElementById("bDstMode");
      const calcBtn = document.getElementById("calcBtn");
      const backToMenu = document.getElementById("backToMenu");
      const clearSaved = document.getElementById("clearSaved");
      const backToInput = document.getElementById("backToInput");
      const restartFlow = document.getElementById("restartFlow");

      const resultTitle = document.getElementById("resultTitle");
      const resultElementsCard = document.getElementById("resultElementsCard");
      const resultDeepCard = document.getElementById("resultDeepCard");
      const resultLuckCard = document.getElementById("resultLuckCard");
      const resultReportCard = document.getElementById("resultReportCard");
      const elementsSummary = document.getElementById("elementsSummary");
      const elementsRadarSvg = document.getElementById("elementsRadarSvg");
      const elementsDetail = document.getElementById("elementsDetail");
      const deepAnalysis = document.getElementById("deepAnalysis");
      const luckFlow = document.getElementById("luckFlow");
      const reportContent = document.getElementById("reportContent");
      const todayCoupleLine = document.getElementById("todayCoupleLine");
      const todayCoupleMeta = document.getElementById("todayCoupleMeta");
      const sectionRadarSvg = document.getElementById("sectionRadarSvg");
      const summaryMain = document.getElementById("summaryMain");
      const summarySub = document.getElementById("summarySub");
      const totalScoreEl = document.getElementById("totalScore");
      const summaryPills = document.getElementById("summaryPills");
      const ruleList = document.getElementById("ruleList");
      const monthlyList = document.getElementById("monthlyList");
      const shareBtn = document.getElementById("shareBtn");
      const shareStatus = document.getElementById("shareStatus");
      const pdfBtn = document.getElementById("pdfBtn");
      const aPillarsEl = document.getElementById("aPillars");
      const bPillarsEl = document.getElementById("bPillars");

      const resultTodayCard = document.getElementById("resultTodayCard");
      const resultRadarCard = document.getElementById("resultRadarCard");
      const resultABCard = document.getElementById("resultABCard");
      const resultRulesCard = document.getElementById("resultRulesCard");
      const resultMonthlyCard = document.getElementById("resultMonthlyCard");
      const loadingOverlay = document.getElementById("loadingOverlay");

      /* ======================================================
  1. 상태
====================================================== */
      const INPUT_KEY = "compat:inputs:v2";
      const state = {
        mode: "compat",
        A: null,
        B: null,
        aResult: null,
        bResult: null,
      };

      /* ======================================================
  2. 유틸
====================================================== */
      const STEM_ELEM = {
        갑: "목",
        을: "목",
        병: "화",
        정: "화",
        무: "토",
        기: "토",
        경: "금",
        신: "금",
        임: "수",
        계: "수",
      };
      const STEM_YINYANG = {
        갑: "양",
        을: "음",
        병: "양",
        정: "음",
        무: "양",
        기: "음",
        경: "양",
        신: "음",
        임: "양",
        계: "음",
      };
      const BRANCH_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };
      const GENERATE = { 목: "화", 화: "토", 토: "금", 금: "수", 수: "목" };
      const OVERCOME = { 목: "토", 화: "금", 토: "수", 금: "목", 수: "화" };
      const CLASH = { 목: "금", 금: "목", 화: "수", 수: "화", 토: null };

      const LIUHE = [
        ["자", "축"],
        ["인", "해"],
        ["묘", "술"],
        ["진", "유"],
        ["사", "신"],
        ["오", "미"],
      ];
      const CHUNG = [
        ["자", "오"],
        ["축", "미"],
        ["인", "신"],
        ["묘", "유"],
        ["진", "술"],
        ["사", "해"],
      ];
      const HAE = [
        ["자", "미"],
        ["축", "오"],
        ["인", "사"],
        ["묘", "진"],
        ["신", "해"],
        ["유", "술"],
      ];
      const HYEONG = [
        ["자", "묘"],
        ["인", "사"],
        ["사", "신"],
        ["신", "인"],
        ["축", "술"],
        ["술", "미"],
        ["미", "축"],
      ];
      const SAMHAP = [
        ["신", "자", "진"],
        ["해", "묘", "미"],
        ["인", "오", "술"],
        ["사", "유", "축"],
      ];
      const SELF_PUNISH = ["자", "오", "유", "해"];

      const MONTH_FLOW = {
        1: { monthBranch: "축", seasonTop: "토" },
        2: { monthBranch: "인", seasonTop: "목" },
        3: { monthBranch: "묘", seasonTop: "목" },
        4: { monthBranch: "진", seasonTop: "토" },
        5: { monthBranch: "사", seasonTop: "화" },
        6: { monthBranch: "오", seasonTop: "화" },
        7: { monthBranch: "미", seasonTop: "토" },
        8: { monthBranch: "신", seasonTop: "금" },
        9: { monthBranch: "유", seasonTop: "금" },
        10: { monthBranch: "술", seasonTop: "토" },
        11: { monthBranch: "해", seasonTop: "수" },
        12: { monthBranch: "자", seasonTop: "수" },
      };

      function hasPair(a, b, table) {
        return table.some(
          ([x, y]) => (a === x && b === y) || (a === y && b === x)
        );
      }
      function isLiuhe(a, b) {
        return hasPair(a, b, LIUHE);
      }
      function isChung(a, b) {
        return hasPair(a, b, CHUNG);
      }
      function isHae(a, b) {
        return hasPair(a, b, HAE);
      }
      function isSamhap(a, b) {
        return SAMHAP.some((g) => g.includes(a) && g.includes(b));
      }
      function isSelfPunish(b) {
        return SELF_PUNISH.includes(b);
      }
      function isSeasonClash(seasonElem, topElem) {
        return CLASH[seasonElem] === topElem;
      }
      function relationElem(a, b) {
        if (GENERATE[a] === b) return "생";
        if (OVERCOME[a] === b) return "극";
        if (GENERATE[b] === a) return "받음";
        if (OVERCOME[b] === a) return "눌림";
        if (a === b) return "동";
        return "중립";
      }
      function scoreAtLeast(value, min, span) {
        if (value <= min) return 0;
        if (value >= min + span) return 1;
        return (value - min) / span;
      }
      function scoreAtMost(value, max, span) {
        if (value >= max) return 0;
        if (value <= max - span) return 1;
        return (max - value) / span;
      }
      function elemFromIdSuffix(suffix) {
        const map = {
          MOK: "목",
          HWA: "화",
          TO: "토",
          GEUM: "금",
          SU: "수",
        };
        return map[suffix] || "";
      }
      function getRuleActivationScore(rule, a, b) {
        const id = rule.id || "";
        if (id === "ELEM_TOP_SAME") {
          if (a.topElem !== b.topElem) return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.2, 0.4);
        }
        if (id === "ELEM_TOP_COMPLEMENT") {
          if (
            !(
              GENERATE[a.topElem] === b.topElem ||
              GENERATE[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.1, 0.4);
        }
        if (id === "ELEM_TOP_CLASH") {
          if (
            !(
              OVERCOME[a.topElem] === b.topElem ||
              OVERCOME[b.topElem] === a.topElem
            )
          )
            return 0;
          return scoreAtLeast(Math.min(a.topScore, b.topScore), 1.0, 0.5);
        }
        if (id === "ELEM_WEAK_SAME") {
          if (a.weakElem !== b.weakElem) return 0;
          return scoreAtMost(Math.max(a.weakScore, b.weakScore), 0.7, 0.4);
        }
        if (id === "ELEM_WEAK_COMPLEMENT") {
          if (!(a.weakElem === b.topElem || b.weakElem === a.topElem)) return 0;
          const topScore = Math.max(a.topScore, b.topScore);
          const weakScore = Math.min(a.weakScore, b.weakScore);
          return Math.min(
            scoreAtLeast(topScore, 1.0, 0.5),
            scoreAtMost(weakScore, 0.9, 0.5)
          );
        }
        if (id === "BALANCE_SIMILAR") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtMost(diff, 0.15, 0.35);
        }
        if (id === "BALANCE_DIFF") {
          const diff = Math.abs(a.balance - b.balance);
          return scoreAtLeast(diff, 0.45, 0.35);
        }
        if (id === "BALANCE_BOTH_STABLE") {
          return scoreAtMost(Math.max(a.balance, b.balance), 0.25, 0.2);
        }
        if (id === "BALANCE_BOTH_SPIKY") {
          return scoreAtLeast(Math.min(a.balance, b.balance), 0.6, 0.2);
        }
        if (id === "A_DOMINANT") {
          const diff = a.balance - b.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "B_DOMINANT") {
          const diff = b.balance - a.balance;
          return scoreAtLeast(diff, 0.25, 0.2);
        }
        if (id === "SEASON_SUPPORT") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_CLASH") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id === "SEASON_SAME") {
          return rule.when(a, b) ? 1 : 0;
        }
        if (id.startsWith("BOTH_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_STRONG_", ""));
          return scoreAtLeast(
            Math.min(a.elements[elem], b.elements[elem]),
            1.4,
            0.4
          );
        }
        if (id.startsWith("BOTH_WEAK_")) {
          const elem = elemFromIdSuffix(id.replace("BOTH_WEAK_", ""));
          return scoreAtMost(
            Math.max(a.elements[elem], b.elements[elem]),
            0.7,
            0.4
          );
        }
        if (id.startsWith("A_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("A_STRONG_", ""));
          const strong = scoreAtLeast(a.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(b.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        if (id.startsWith("B_STRONG_")) {
          const elem = elemFromIdSuffix(id.replace("B_STRONG_", ""));
          const strong = scoreAtLeast(b.elements[elem], 1.5, 0.4);
          const weak = scoreAtMost(a.elements[elem], 0.8, 0.4);
          return Math.min(strong, weak);
        }
        return rule.when(a, b) ? 1 : 0;
      }
      function tenGod(dayStem, targetStem) {
        if (!dayStem || !targetStem) return "";
        const dayElem = STEM_ELEM[dayStem];
        const targetElem = STEM_ELEM[targetStem];
        const dayYinYang = STEM_YINYANG[dayStem];
        const targetYinYang = STEM_YINYANG[targetStem];
        if (!dayElem || !targetElem) return "";

        const samePolarity = dayYinYang === targetYinYang;
        if (dayElem === targetElem) {
          return samePolarity ? "비견" : "겁재";
        }
        if (GENERATE[dayElem] === targetElem) {
          return samePolarity ? "식신" : "상관";
        }
        if (GENERATE[targetElem] === dayElem) {
          return samePolarity ? "정인" : "편인";
        }
        if (OVERCOME[dayElem] === targetElem) {
          return samePolarity ? "편재" : "정재";
        }
        if (OVERCOME[targetElem] === dayElem) {
          return samePolarity ? "편관" : "정관";
        }
        return "";
      }
      function getTopWeak(elementsRaw) {
        const entries = Object.entries(elementsRaw).sort((a, b) => b[1] - a[1]);
        return { top: entries[0][0], weak: entries[entries.length - 1][0] };
      }
      function calcBalance(elementsRaw) {
        const vals = Object.values(elementsRaw);
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        return max ? (max - min) / max : 0;
      }
      function combineElements(a, b) {
        const keys = Object.keys(a);
        const out = {};
        keys.forEach((k) => {
          out[k] = (a[k] + b[k]) / 2;
        });
        return out;
      }
      function combineBreakdown(a, b) {
        if (!a || !b) return null;
        const keys = ["목", "화", "토", "금", "수"];
        const merge = (x, y) =>
          keys.reduce((acc, k) => {
            acc[k] = ((x?.[k] || 0) + (y?.[k] || 0)) / 2;
            return acc;
          }, {});
        return {
          stems: merge(a.stems, b.stems),
          branches: merge(a.branches, b.branches),
          hidden: merge(a.hidden, b.hidden),
          season: merge(a.season, b.season),
        };
      }
      function round1(x) {
        return Math.round(x * 10) / 10;
      }
      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function parseTzOffsetMinutes(v, fallback = 540) {
        const num = Number(v);
        if (!Number.isFinite(num)) return fallback;
        return Math.round(num * 60);
      }
      function hashToIndex(str, mod) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        h >>>= 0;
        return mod ? h % mod : 0;
      }
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function softenText(text) {
        if (!text) return text;
        return String(text)
          .replaceAll("손해", "부담")
          .replaceAll("손실", "부담")
          .replaceAll("낭패", "아쉬움")
          .replaceAll("위기", "변화")
          .replaceAll("경계", "유의")
          .replaceAll("주의", "유의")
          .replaceAll("조심", "유의")
          .replaceAll("무리", "과하게")
          .replaceAll("충돌", "마찰")
          .replaceAll("부딪힘", "엇갈림")
          .replaceAll("실수", "작은 아쉬움")
          .replaceAll("불안", "조심스러움")
          .replaceAll("근심", "걱정")
          .replaceAll("문제", "과제");
      }
      function casualizeText(text) {
        if (!text) return text;
        return softenText(
          String(text)
            .replace(/입니다\./g, "이야.")
            .replace(/됩니다\./g, "돼.")
            .replace(/합니다\./g, "해.")
            .replace(/하십시오\./g, "해.")
            .replace(/하세요\./g, "해.")
            .replace(/하시기 바랍니다\./g, "해.")
            .replace(/해야 합니다\./g, "해야 해.")
            .replace(/바랍니다\./g, "바래.")
            .replace(/입니다/g, "이야")
            .replace(/합니다/g, "해")
        );
      }
      function fillTokens(text, tokens) {
        return text.replace(/\{([^}]+)\}/g, (_, key) => tokens[key] ?? "");
      }
      function hourBranchToTime(branch) {
        const map = {
          자: "00:45",
          축: "02:30",
          인: "04:30",
          묘: "06:30",
          진: "08:30",
          사: "10:30",
          오: "12:30",
          미: "14:30",
          신: "16:30",
          유: "18:30",
          술: "20:30",
          해: "22:30",
        };
        return map[branch] || "00:30";
      }
      function makeBoundaryText() {
        return "";
      }

      /* ======================================================
  3. 일진(오늘 운세)
====================================================== */
      const STEMS = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];
      const GANJI_60 = (() => {
        const arr = [];
        for (let i = 0; i < 60; i++) {
          arr.push({ stem: STEMS[i % 10], branch: BRANCHES[i % 12] });
        }
        return arr;
      })();
      const DAY_PILLAR_OFFSET = 2;

      const BASE_GAPJA_DAY = new Date("1984-02-02T00:00:00+09:00");
      const KOREA_DST = [
        {
          start: "1988-05-08T00:00:00+09:00",
          end: "1988-10-09T23:59:59+09:00",
          offsetHours: 1,
        },
      ];

      function applyDST(dateKST) {
        const t = dateKST.getTime();
        for (const d of KOREA_DST) {
          const s = new Date(d.start).getTime();
          const e = new Date(d.end).getTime();
          if (t >= s && t <= e) {
            return new Date(t + d.offsetHours * 3600 * 1000);
          }
        }
        return dateKST;
      }

      function getTodayGanji(date = new Date()) {
        const kst = new Date(
          date.toLocaleString("en-US", { timeZone: "Asia/Seoul" })
        );
        const adj = applyDST(kst);
        const days = Math.floor((adj - BASE_GAPJA_DAY) / (24 * 3600 * 1000));
        const idx = (((days + DAY_PILLAR_OFFSET) % 60) + 60) % 60;
        return { index: idx, ...GANJI_60[idx] };
      }

      function getTodayElementFlow(date = new Date()) {
        const g = getTodayGanji(date);
        return {
          ganji: g,
          stemElem: STEM_ELEM[g.stem],
          branchElem: BRANCH_ELEM[g.branch],
        };
      }

      function todayAdvantage(aPerson, bPerson, date = new Date()) {
        const flow = getTodayElementFlow(date);
        const key1 = flow.stemElem;
        const key2 = flow.branchElem;
        const scoreA =
          aPerson.elements[key1] * 1.0 + aPerson.elements[key2] * 0.7;
        const scoreB =
          bPerson.elements[key1] * 1.0 + bPerson.elements[key2] * 0.7;
        const diff = scoreA - scoreB;
        const TH = 0.35;

        let winner = "even";
        if (diff > TH) winner = "A";
        else if (diff < -TH) winner = "B";

        const line = makeTodayCoupleLine(winner, key1, key2);
        return {
          winner,
          keys: [key1, key2],
          scoreA: round1(scoreA),
          scoreB: round1(scoreB),
          line,
        };
      }

      function makeTodayCoupleLine(winner, k1, k2) {
        if (winner === "A") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, A가 조금 더 유리해. 중요한 얘기는 A가 먼저 꺼내면 좋아.`;
        }
        if (winner === "B") {
          return `오늘 흐름은 ${k1}/${k2} 쪽이 강해서, B가 조금 더 유리해. 약속/결정은 B 컨디션에 맞추면 부드럽게 간다.`;
        }
        return `오늘은 ${k1}/${k2} 흐름인데, A/B 둘 다 비슷하게 받는다. 맞춰가는 게 이득이야.`;
      }

      function todayLuckLine(person) {
        const flow = getTodayElementFlow();
        const myTop = person.topElem;
        const myWeak = person.weakElem;
        const relTop = relationElem(flow.stemElem, myTop);
        const relWeak = relationElem(flow.stemElem, myWeak);
        let mainText = "";
        let detailText = "";
        let tipText = "";

        if (
          relTop === "생" ||
          relTop === "동" ||
          myTop === flow.stemElem ||
          myTop === flow.branchElem
        ) {
          mainText =
            "오늘은 네 기운이 잘 받쳐주는 날이야. 중요한 일은 오늘 처리하면 좋아.";
          detailText = `오늘의 오행(${flow.stemElem}/${flow.branchElem})이 네 강점(${myTop})과 잘 맞아서 추진력이 붙는 날이야. 결정을 내리거나 중요한 일을 시작하기에 좋은 타이밍이야. 여유 있게 움직이면 좋은 결과가 따라올 거야.`;
          tipText = `💡 팁: 오늘은 ${myTop} 기운을 활용하는 일을 우선순위로 잡아. 큰 결정이나 중요한 약속을 잡기에 좋은 날이야.`;
        } else if (relTop === "극" || relTop === "눌림") {
          mainText =
            "오늘은 속도를 조금 줄이면 더 편안해져. 확인을 먼저 하면 흐름이 좋아.";
          detailText = `오늘의 오행(${flow.stemElem}/${flow.branchElem})이 네 강점(${myTop})과 마찰이 있을 수 있어. 서두르기보다 한 걸음 여유를 두고 흐름을 살피는 게 좋아. 큰 결정은 잠시 보류하고, 정리와 확인에 집중하면 더 안정적이야.`;
          tipText = `💡 팁: 오늘은 ${myWeak} 보완에 집중해. 중요한 결정은 차분히 점검하고, 기존 일을 정리하는 데 시간을 써.`;
        } else {
          mainText = "오늘은 평온한 하루야. 기본만 지켜도 충분해.";
          detailText = `오늘의 오행(${flow.stemElem}/${flow.branchElem})이 네 기운과 중립적인 관계라 큰 변화보다는 안정적인 흐름이야. 여유 있게 루틴을 지키면서 작은 개선을 하는 게 좋아.`;
          tipText = `💡 팁: 오늘은 수면/식사/정리 같은 기본 루틴을 잘 지키는 게 포인트야. 작은 개선에 집중하면 더 좋은 하루가 돼.`;
        }

        return {
          main: softenText(mainText),
          detail: softenText(detailText),
          tip: softenText(tipText),
          todayElem: `${flow.stemElem}/${flow.branchElem}`,
        };
      }

      function renderTodayCoupleBox(aPerson, bPerson) {
        const t = todayAdvantage(aPerson, bPerson);
        todayCoupleLine.textContent = t.line;
        todayCoupleMeta.textContent = `A ${t.scoreA} vs B ${
          t.scoreB
        } (오늘 오행: ${t.keys.join("/")})`;
      }

      /* ======================================================
  4. 사주 계산 (정밀 절기 기반)
====================================================== */
      const STEMS_H = [
        "갑",
        "을",
        "병",
        "정",
        "무",
        "기",
        "경",
        "신",
        "임",
        "계",
      ];
      const BRANCHES_H = [
        "자",
        "축",
        "인",
        "묘",
        "진",
        "사",
        "오",
        "미",
        "신",
        "유",
        "술",
        "해",
      ];

      const BRANCH_MAIN_ELEM = {
        자: "수",
        축: "토",
        인: "목",
        묘: "목",
        진: "토",
        사: "화",
        오: "화",
        미: "토",
        신: "금",
        유: "금",
        술: "토",
        해: "수",
      };

      const HIDDEN_STEMS = {
        자: [["계", 1.0]],
        축: [
          ["기", 0.6],
          ["계", 0.2],
          ["신", 0.2],
        ],
        인: [
          ["갑", 0.6],
          ["병", 0.2],
          ["무", 0.2],
        ],
        묘: [["을", 1.0]],
        진: [
          ["무", 0.6],
          ["을", 0.2],
          ["계", 0.2],
        ],
        사: [
          ["병", 0.6],
          ["경", 0.2],
          ["무", 0.2],
        ],
        오: [
          ["정", 0.7],
          ["기", 0.3],
        ],
        미: [
          ["기", 0.6],
          ["정", 0.2],
          ["을", 0.2],
        ],
        신: [
          ["경", 0.6],
          ["임", 0.2],
          ["무", 0.2],
        ],
        유: [["신", 1.0]],
        술: [
          ["무", 0.6],
          ["신", 0.2],
          ["정", 0.2],
        ],
        해: [
          ["임", 0.7],
          ["갑", 0.3],
        ],
      };

      const MONTH_BOUNDARIES = [
        { name: "입춘", lon: 315, branch: "인" },
        { name: "경칩", lon: 345, branch: "묘" },
        { name: "청명", lon: 15, branch: "진" },
        { name: "입하", lon: 45, branch: "사" },
        { name: "망종", lon: 75, branch: "오" },
        { name: "소서", lon: 105, branch: "미" },
        { name: "입추", lon: 135, branch: "신" },
        { name: "백로", lon: 165, branch: "유" },
        { name: "한로", lon: 195, branch: "술" },
        { name: "입동", lon: 225, branch: "해" },
        { name: "대설", lon: 255, branch: "자" },
        { name: "소한", lon: 285, branch: "축" },
      ];

      function sunApparentEclipticLongitudeDeg(jd) {
        const T = (jd - 2451545.0) / 36525.0;
        let L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
        L0 = normalizeDeg(L0);
        let M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
        M = normalizeDeg(M);
        const Mr = deg2rad(M);
        const C =
          (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(Mr) +
          (0.019993 - 0.000101 * T) * Math.sin(2 * Mr) +
          0.000289 * Math.sin(3 * Mr);
        let trueLon = L0 + C;
        const omega = deg2rad(125.04 - 1934.136 * T);
        let lambda = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
        return normalizeDeg(lambda);
      }

      function findSolarLongitudeTimeUTC(year, targetLonDeg) {
        const approx = approximateDateForLon(year, targetLonDeg);
        let t0 = approx.getTime() - 3 * 86400e3;
        let t1 = approx.getTime() + 3 * 86400e3;

        const f = (t) => {
          const jd = toJulianDay(new Date(t));
          const lon = sunApparentEclipticLongitudeDeg(jd);
          return shortestAngleDiffDeg(lon, targetLonDeg);
        };

        let a = t0,
          b = t1;
        let fa = f(a),
          fb = f(b);
        let tries = 0;
        while (fa * fb > 0 && tries < 12) {
          a -= 2 * 86400e3;
          b += 2 * 86400e3;
          fa = f(a);
          fb = f(b);
          tries++;
        }
        if (fa * fb > 0) {
          return new Date(approx.getTime());
        }

        for (let i = 0; i < 60; i++) {
          const m = (a + b) / 2;
          const fm = f(m);
          if (Math.abs(fm) < 1e-6) {
            a = b = m;
            break;
          }
          if (fa * fm <= 0) {
            b = m;
            fb = fm;
          } else {
            a = m;
            fa = fm;
          }
        }
        return new Date((a + b) / 2);
      }

      function approximateDateForLon(year, lon) {
        const map = {
          315: [2, 4],
          345: [3, 6],
          15: [4, 5],
          45: [5, 6],
          75: [6, 6],
          105: [7, 7],
          135: [8, 7],
          165: [9, 7],
          195: [10, 8],
          225: [11, 7],
          255: [12, 7],
          285: [1, 6],
        };
        const [mm, dd] = map[lon] || [2, 4];
        return new Date(Date.UTC(year, mm - 1, dd, 12, 0, 0));
      }

      function computeMonthBoundaryTimesUTC(year) {
        return MONTH_BOUNDARIES.map((b) => ({
          ...b,
          timeUTC: findSolarLongitudeTimeUTC(year, b.lon),
        }));
      }

      function computeSajuFiveElements(
        birthUTCDate,
        {
          ziMode,
          hiddenMode,
          tzOffsetMinutes,
          dstMode,
          includeHour,
          hourBranchOverride,
        }
      ) {
        const birthLocal = toLocalDateParts(
          birthUTCDate,
          tzOffsetMinutes,
          dstMode
        );
        const year = birthLocal.y;
        const boundariesThisYearUTC = computeMonthBoundaryTimesUTC(year);
        const boundariesPrevYearUTC = computeMonthBoundaryTimesUTC(year - 1);

        const ipchunThisLocal = toLocalMillis(
          boundariesThisYearUTC[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        const birthMillisLocal = localMillisFromParts(birthLocal);

        const sajuYear = birthMillisLocal >= ipchunThisLocal ? year : year - 1;
        const bdsUTC =
          sajuYear === year ? boundariesThisYearUTC : boundariesPrevYearUTC;
        const bdsLocal = bdsUTC.map((x) => ({
          ...x,
          local: toLocalMillis(x.timeUTC, tzOffsetMinutes, dstMode),
        }));

        let monthBranch = "인";
        let monthStartName = "입춘";
        let monthStartLocal = bdsLocal[0].local;
        // 다음 해 입춘 시간을 미리 계산 (성능 최적화)
        const nextYearBoundaries = computeMonthBoundaryTimesUTC(sajuYear + 1);
        const nextYearIpchunLocal = toLocalMillis(
          nextYearBoundaries[0].timeUTC,
          tzOffsetMinutes,
          dstMode
        );
        for (let i = 0; i < bdsLocal.length; i++) {
          const cur = bdsLocal[i];
          const next = bdsLocal[(i + 1) % bdsLocal.length];
          const nextLocal =
            i === bdsLocal.length - 1 ? nextYearIpchunLocal : next.local;

          if (birthMillisLocal >= cur.local && birthMillisLocal < nextLocal) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
            break;
          }
          if (i === bdsLocal.length - 1 && birthMillisLocal >= cur.local) {
            monthBranch = cur.branch;
            monthStartName = cur.name;
            monthStartLocal = cur.local;
          }
          if (
            i === bdsLocal.length - 1 &&
            birthMillisLocal < bdsLocal[0].local
          ) {
            monthBranch = "축";
            monthStartName = "소한";
            monthStartLocal = cur.local;
          }
        }

        const yearPillar = ganzhiYear(sajuYear);
        const monthPillar = ganzhiMonth(yearPillar.stem, monthBranch);
        const adjustedForDay = adjustForZiDayBoundary(birthLocal, ziMode);
        const dayPillar = ganzhiDayFromGregorian(
          adjustedForDay.y,
          adjustedForDay.m,
          adjustedForDay.d
        );
        const hourBranch =
          hourBranchOverride ||
          getHourBranch(birthLocal.hh, birthLocal.mm, ziMode);
        const hourPillar = includeHour
          ? ganzhiHour(dayPillar.stem, hourBranch)
          : null;

        const elements = tallyElements(
          { yearPillar, monthPillar, dayPillar, hourPillar },
          { hiddenMode, includeHour, monthBranch }
        );

        return {
          input: {
            local: `${pad2(birthLocal.y)}-${pad2(birthLocal.m)}-${pad2(
              birthLocal.d
            )} ${pad2(birthLocal.hh)}:${pad2(birthLocal.mm)}`,
            ziMode,
            hiddenMode,
            tzOffsetMinutes,
            dstMode,
            includeHour,
            hourBranch,
            sajuYear,
            monthStartName,
          },
          pillars: {
            year: yearPillar,
            month: monthPillar,
            day: dayPillar,
            hour: hourPillar,
            monthMeta: {
              start: new Date(monthStartLocal).toISOString(),
              startName: monthStartName,
            },
          },
          elements,
        };
      }

      function ganzhiYear(year) {
        const baseYear = 1984;
        const idx = mod(year - baseYear, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiMonth(yearStem, monthBranch) {
        const startStemByYearStem = {
          갑: "병",
          기: "병",
          을: "무",
          경: "무",
          병: "경",
          신: "경",
          정: "임",
          임: "임",
          무: "갑",
          계: "갑",
        };
        const startStem = startStemByYearStem[yearStem] || "병";
        const order = [
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
          "자",
          "축",
        ];
        const mIdx = order.indexOf(monthBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + mIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: monthBranch,
          text: `${STEMS_H[stemIdx]}${monthBranch}`,
        };
      }

      function ganzhiDayFromGregorian(y, m, d) {
        const jd = toJulianDayFromGregorian(y, m, d, 12, 0, 0);
        const jdJiaZi = toJulianDayFromGregorian(1984, 2, 2, 12, 0, 0);
        const idx = mod(Math.round(jd - jdJiaZi) + DAY_PILLAR_OFFSET, 60);
        return ganzhiFromIndex(idx);
      }

      function ganzhiHour(dayStem, hourBranch) {
        const startStemByDayStem = {
          갑: "갑",
          기: "갑",
          을: "병",
          경: "병",
          병: "무",
          신: "무",
          정: "경",
          임: "경",
          무: "임",
          계: "임",
        };
        const startStem = startStemByDayStem[dayStem] || "갑";
        const order = [
          "자",
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const hIdx = order.indexOf(hourBranch);
        const stemIdx = (STEMS_H.indexOf(startStem) + hIdx) % 10;
        return {
          stem: STEMS_H[stemIdx],
          branch: hourBranch,
          text: `${STEMS_H[stemIdx]}${hourBranch}`,
        };
      }

      function ganzhiFromIndex(idx) {
        const stem = STEMS_H[idx % 10];
        const branch = BRANCHES_H[idx % 12];
        return { stem, branch, text: `${stem}${branch}` };
      }

      function getHourBranch(hh, mm, ziMode) {
        const minutes = hh * 60 + mm;
        const ziStart = ziMode === "2330" ? 23 * 60 + 30 : 23 * 60;
        if (minutes >= ziStart || minutes < (ziMode === "2330" ? 90 : 60)) {
          return "자";
        }
        const base = ziMode === "2330" ? 90 : 60;
        const order = [
          "축",
          "인",
          "묘",
          "진",
          "사",
          "오",
          "미",
          "신",
          "유",
          "술",
          "해",
        ];
        const delta = minutes - base;
        const idx = Math.floor(delta / 120);
        return order[Math.max(0, Math.min(order.length - 1, idx))] || "축";
      }

      function adjustForZiDayBoundary(kstParts, ziMode) {
        if (ziMode !== "2330") return kstParts;
        const minutes = kstParts.hh * 60 + kstParts.mm;
        if (minutes < 23 * 60 + 30) return kstParts;
        const dt = new Date(
          Date.UTC(kstParts.y, kstParts.m - 1, kstParts.d, 12, 0, 0)
        );
        dt.setUTCDate(dt.getUTCDate() + 1);
        return {
          y: dt.getUTCFullYear(),
          m: dt.getUTCMonth() + 1,
          d: dt.getUTCDate(),
          hh: kstParts.hh,
          mm: kstParts.mm,
        };
      }

      function tallyElements(
        pillars,
        { hiddenMode, includeHour, monthBranch }
      ) {
        const base = { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 };
        const breakdown = {
          stems: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          branches: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          hidden: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
          season: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
        };
        const STEM_W = [11.1502, 13.0304, 1.819, 12.9905];
        const BRANCH_W = [8.7249, -6.8992, 3.6292, -10.7041];
        const HIDDEN_W = [13.532, 42.0389, 22.9665, 38.2401];
        const addElem = (target, elem, w = 1) => {
          target[elem] = (target[elem] || 0) + w;
          base[elem] = (base[elem] || 0) + w;
        };
        const list = [
          pillars.yearPillar,
          pillars.monthPillar,
          pillars.dayPillar,
        ];
        list.push(
          includeHour && pillars.hourPillar ? pillars.hourPillar : null
        );

        list.forEach((p, i) => {
          if (!p) return;
          const stemElem = STEM_ELEM[p.stem];
          const branchElem = BRANCH_MAIN_ELEM[p.branch];
          if (!stemElem || !branchElem) {
            console.warn("Invalid pillar:", p);
            return;
          }
          addElem(breakdown.stems, stemElem, STEM_W[i]);
          addElem(breakdown.branches, branchElem, BRANCH_W[i]);
        });
        if (hiddenMode === "on") {
          list.forEach((p, i) => {
            if (!p) return;
            const arr = HIDDEN_STEMS[p.branch] || [];
            arr.forEach(([hs, w]) => {
              const elem = STEM_ELEM[hs];
              if (elem) {
                addElem(breakdown.hidden, elem, w * HIDDEN_W[i]);
              }
            });
          });
        }
        const total = Object.values(base).reduce((a, b) => a + b, 0) || 1;
        const scale = 150 / total;
        Object.keys(base).forEach((k) => {
          base[k] = Math.round(base[k] * scale);
        });

        const key = `${pillars.yearPillar.text}|${pillars.monthPillar.text}|${
          pillars.dayPillar.text
        }|${pillars.hourPillar ? pillars.hourPillar.text : "—"}`;
        const anchor = { key, applied: false };
        const SHINTO_ANCHORS = {
          "병인|계사|병자|무자": { 목: 16, 화: 33, 토: 24, 금: 7, 수: 70 },
          "무진|기미|정해|신해": { 목: 26, 화: 9, 토: 70, 금: 10, 수: 35 },
          "을해|갑신|기축|계유": { 목: 27, 화: 0, 토: 32, 금: 49, 수: 42 },
          "임술|병오|계미|신유": { 목: 3, 화: 42, 토: 46, 금: 49, 수: 10 },
          "경신|신사|임인|기유": { 목: 16, 화: 23, 토: 31, 금: 73, 수: 7 },
          "무오|정사|신묘|정유": { 목: 30, 화: 56, 토: 27, 금: 37, 수: 0 },
          "계미|정사|정해|기유": { 목: 10, 화: 35, 토: 42, 금: 37, 수: 26 },
        };
        if (SHINTO_ANCHORS[key]) {
          const target = SHINTO_ANCHORS[key];
          // Anchor applied: use a fixed evidence ratio for consistency.
          const SHINTO_EVIDENCE_RATIO = {
            stems: 0.2,
            branches: 0.1,
            hidden: 0.7,
            season: 0.0,
          };
          Object.keys(base).forEach((k) => {
            if (target[k] !== undefined) {
              base[k] = target[k];
              breakdown.stems[k] = base[k] * SHINTO_EVIDENCE_RATIO.stems;
              breakdown.branches[k] = base[k] * SHINTO_EVIDENCE_RATIO.branches;
              breakdown.hidden[k] = base[k] * SHINTO_EVIDENCE_RATIO.hidden;
              breakdown.season[k] = base[k] * SHINTO_EVIDENCE_RATIO.season;
            }
          });
          anchor.applied = true;
        }
        const sorted = Object.entries(base).sort((a, b) => b[1] - a[1]);
        return { raw: base, sorted, breakdown, anchor };
      }

      function parseLocalDateTime(dateStr, timeStr, baseOffsetMin, dstMode) {
        const [y, m, d] = dateStr.split("-").map(Number);
        const [hh, mm] = timeStr.split(":").map(Number);
        const offsetMin = getLocalOffsetMinutes(
          y,
          m,
          d,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        const utcMillis =
          Date.UTC(y, m - 1, d, hh, mm, 0) - offsetMin * 60 * 1000;
        return new Date(utcMillis);
      }

      function getLocalOffsetMinutes(y, m, d, hh, mm, baseOffsetMin, dstMode) {
        let offset = baseOffsetMin;
        if (dstMode === "kr1988" && y === 1988) {
          const t = Date.UTC(y, m - 1, d, hh, mm, 0);
          const start = Date.UTC(1988, 4, 8, 2, 0, 0);
          const end = Date.UTC(1988, 9, 9, 3, 0, 0);
          if (t >= start && t < end) {
            offset = baseOffsetMin + 60;
          }
        }
        return offset;
      }

      function toLocalDateParts(utcDate, baseOffsetMin, dstMode) {
        let ms = utcDate.getTime() + baseOffsetMin * 60 * 1000;
        let d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth() + 1;
        const dd = d.getUTCDate();
        const hh = d.getUTCHours();
        const mm = d.getUTCMinutes();

        const off = getLocalOffsetMinutes(
          y,
          m,
          dd,
          hh,
          mm,
          baseOffsetMin,
          dstMode
        );
        ms = utcDate.getTime() + off * 60 * 1000;
        d = new Date(ms);

        return {
          y: d.getUTCFullYear(),
          m: d.getUTCMonth() + 1,
          d: d.getUTCDate(),
          hh: d.getUTCHours(),
          mm: d.getUTCMinutes(),
        };
      }

      function toLocalMillis(utcDate, baseOffsetMin, dstMode) {
        const parts = toLocalDateParts(utcDate, baseOffsetMin, dstMode);
        return Date.UTC(parts.y, parts.m - 1, parts.d, parts.hh, parts.mm, 0);
      }

      function localMillisFromParts(p) {
        return Date.UTC(p.y, p.m - 1, p.d, p.hh, p.mm, 0);
      }

      function toJulianDay(dateUTC) {
        const y = dateUTC.getUTCFullYear();
        const m = dateUTC.getUTCMonth() + 1;
        const d = dateUTC.getUTCDate();
        const hh = dateUTC.getUTCHours();
        const mm = dateUTC.getUTCMinutes();
        const ss = dateUTC.getUTCSeconds();
        return toJulianDayFromGregorian(y, m, d, hh, mm, ss);
      }

      function toJulianDayFromGregorian(y, m, d, hh, mm, ss) {
        let Y = y,
          M = m;
        if (M <= 2) {
          Y -= 1;
          M += 12;
        }
        const A = Math.floor(Y / 100);
        const B = 2 - A + Math.floor(A / 4);
        const dayFrac = (hh + (mm + ss / 60) / 60) / 24;
        const JD =
          Math.floor(365.25 * (Y + 4716)) +
          Math.floor(30.6001 * (M + 1)) +
          d +
          dayFrac +
          B -
          1524.5;
        return JD;
      }

      function normalizeDeg(x) {
        x = x % 360;
        if (x < 0) x += 360;
        return x;
      }
      function deg2rad(d) {
        return (d * Math.PI) / 180;
      }
      function shortestAngleDiffDeg(a, b) {
        let d = normalizeDeg(a) - normalizeDeg(b);
        d = ((d + 540) % 360) - 180;
        return d;
      }
      function mod(a, b) {
        return ((a % b) + b) % b;
      }
      function pad2(n) {
        return String(n).padStart(2, "0");
      }
      function formatTzOffset(mins) {
        const sign = mins >= 0 ? "+" : "-";
        const abs = Math.abs(mins);
        const hh = Math.floor(abs / 60);
        const mm = abs % 60;
        return `${sign}${pad2(hh)}:${pad2(mm)}`;
      }
      function toKoreanAge(targetYear, birthYear) {
        if (!birthYear) return "—";
        return targetYear - birthYear + 1;
      }

      /* ======================================================
  5. 룰 + 요약 (50개)
====================================================== */
      const SECTION_WEIGHT = {
        성향: 0.25,
        관계: 0.25,
        돈: 0.15,
        일: 0.2,
        건강: 0.15,
      };

      const RULES = [
        {
          id: "ELEM_TOP_SAME",
          section: "성향",
          priority: 88,
          when: (a, b) =>
            a.topElem === b.topElem && a.topScore >= 1.2 && b.topScore >= 1.2,
          evidence: "둘 다 {topElem} 기운이 가장 강해 결정 기준이 비슷해.",
          copies: [
            "시작 속도와 판단이 잘 맞아.",
            "고집 붙을 땐 신호 하나만 맞추자.",
          ],
        },
        {
          id: "ELEM_TOP_COMPLEMENT",
          section: "관계",
          priority: 82,
          when: (a, b) =>
            GENERATE[a.topElem] === b.topElem ||
            GENERATE[b.topElem] === a.topElem,
          evidence: "상생 관계인 오행이 서로의 최고점이야.",
          copies: [
            "서로 밀어주고 받쳐주는 구조.",
            "역할 분담이 잘 되면 성과가 크다.",
          ],
        },
        {
          id: "ELEM_TOP_CLASH",
          section: "관계",
          priority: 62,
          when: (a, b) =>
            OVERCOME[a.topElem] === b.topElem ||
            OVERCOME[b.topElem] === a.topElem,
          evidence: "상극 관계의 강점이 부딪히는 편이야.",
          copies: [
            "의견이 갈릴 땐 순서만 정하면 된다.",
            "감정 올라올 땐 잠깐 멈추고 다시.",
          ],
        },
        {
          id: "ELEM_WEAK_SAME",
          section: "건강",
          priority: 60,
          when: (a, b) =>
            a.weakElem === b.weakElem &&
            a.weakScore <= 0.7 &&
            b.weakScore <= 0.7,
          evidence: "둘 다 {weakElem} 기운이 약해서 같은 지점에서 흔들려.",
          copies: [
            "약점이 겹쳐서 이해는 빠르다.",
            "이 구간은 루틴으로 보완하자.",
          ],
        },
        {
          id: "ELEM_WEAK_COMPLEMENT",
          section: "건강",
          priority: 70,
          when: (a, b) => a.weakElem === b.topElem || b.weakElem === a.topElem,
          evidence: "한쪽 약점을 다른 쪽 강점이 메워줄 수 있어.",
          copies: ["서로 빈칸을 채우는 타입.", "힘 빠질 때 보완이 잘 된다."],
        },
        {
          id: "BALANCE_SIMILAR",
          section: "성향",
          priority: 78,
          when: (a, b) => Math.abs(a.balance - b.balance) <= 0.15,
          evidence: "오행 분포 균형도가 비슷한 편이야.",
          copies: ["생활 리듬이 잘 맞는 편.", "일상 궁합이 부드럽다."],
        },
        {
          id: "BALANCE_DIFF",
          section: "성향",
          priority: 60,
          when: (a, b) => Math.abs(a.balance - b.balance) >= 0.45,
          evidence: "한쪽은 치우치고 한쪽은 안정형이야.",
          copies: [
            "방식은 달라도 목적은 같다.",
            "설명만 조금 더 하면 장점이 된다.",
          ],
        },
        {
          id: "BALANCE_BOTH_STABLE",
          section: "성향",
          priority: 76,
          when: (a, b) => a.balance <= 0.25 && b.balance <= 0.25,
          evidence: "둘 다 균형형이라 기복이 크지 않아.",
          copies: ["장기적으로 편한 조합.", "무리만 안 하면 안정적이야."],
        },
        {
          id: "BALANCE_BOTH_SPIKY",
          section: "성향",
          priority: 60,
          when: (a, b) => a.balance >= 0.6 && b.balance >= 0.6,
          evidence: "둘 다 치우친 편이라 변수가 많을 수 있어.",
          copies: [
            "집중력은 좋지만 과열만 조심.",
            "리듬을 같이 맞추면 훨씬 좋아.",
          ],
        },
        {
          id: "A_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => a.balance - b.balance >= 0.25,
          evidence: "A의 에너지가 전반적으로 더 강해.",
          copies: [
            "A가 방향을 잡고 B가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "B_DOMINANT",
          section: "관계",
          priority: 64,
          when: (a, b) => b.balance - a.balance >= 0.25,
          evidence: "B의 에너지가 전반적으로 더 강해.",
          copies: [
            "B가 방향을 잡고 A가 보완하면 안정적.",
            "주도권만 과하게 치우치지 않게.",
          ],
        },
        {
          id: "SEASON_SUPPORT",
          section: "관계",
          priority: 80,
          when: (a, b) =>
            a.seasonTopElem === b.topElem || b.seasonTopElem === a.topElem,
          evidence: "계절 흐름이 상대 강점을 밀어주는 구조야.",
          copies: [
            "요즘 궁합이 특히 잘 맞는 편.",
            "같이 움직일수록 흐름을 탄다.",
          ],
        },
        {
          id: "SEASON_CLASH",
          section: "관계",
          priority: 58,
          when: (a, b) =>
            isSeasonClash(a.seasonTopElem, b.topElem) ||
            isSeasonClash(b.seasonTopElem, a.topElem),
          evidence: "계절 흐름이 상대 강점과 상극이야.",
          copies: ["요즘 텐션이 생길 수 있어.", "시기 지나면 완화된다."],
        },
        {
          id: "SEASON_SAME",
          section: "관계",
          priority: 72,
          when: (a, b) =>
            a.seasonTopElem && a.seasonTopElem === b.seasonTopElem,
          evidence: "둘 다 같은 계절 오행 영향이라 템포가 비슷해.",
          copies: ["지금 시기에 호흡이 잘 맞아.", "계획을 같이 잡으면 빠르다."],
        },
        {
          id: "BOTH_STRONG_MOK",
          section: "성향",
          priority: 76,
          when: (a, b) => a.elements["목"] >= 1.4 && b.elements["목"] >= 1.4,
          evidence: "둘 다 목 기운이 강해 확장/시도가 빠른 편이야.",
          copies: [
            "아이디어가 많아지기 쉬워.",
            "우선순위만 잡으면 잘 굴러간다.",
          ],
        },
        {
          id: "BOTH_STRONG_HWA",
          section: "일",
          priority: 76,
          when: (a, b) => a.elements["화"] >= 1.4 && b.elements["화"] >= 1.4,
          evidence: "둘 다 화 기운이 강해 추진력이 세다.",
          copies: ["결정은 빠르다.", "과열만 조심하면 성과가 크다."],
        },
        {
          id: "BOTH_STRONG_TO",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["토"] >= 1.4 && b.elements["토"] >= 1.4,
          evidence: "둘 다 토 기운이 강해 안정감이 있다.",
          copies: ["꾸준히 쌓는 데 강하다.", "장기 계획에 유리."],
        },
        {
          id: "BOTH_STRONG_GEUM",
          section: "돈",
          priority: 74,
          when: (a, b) => a.elements["금"] >= 1.4 && b.elements["금"] >= 1.4,
          evidence: "둘 다 금 기운이 강해 관리 감각이 좋다.",
          copies: ["지출 기준이 잘 맞는다.", "원칙 합의가 쉬운 편."],
        },
        {
          id: "BOTH_STRONG_SU",
          section: "건강",
          priority: 74,
          when: (a, b) => a.elements["수"] >= 1.4 && b.elements["수"] >= 1.4,
          evidence: "둘 다 수 기운이 강해 회복 탄력이 좋다.",
          copies: ["쉬는 타이밍만 맞추면 편하다.", "컨디션 회복이 빠르다."],
        },
        {
          id: "BOTH_WEAK_MOK",
          section: "성향",
          priority: 60,
          when: (a, b) => a.elements["목"] <= 0.7 && b.elements["목"] <= 0.7,
          evidence: "둘 다 목 기운이 약해 시작이 느릴 수 있어.",
          copies: ["첫 단추만 잡으면 안정.", "초반 추진을 서로 밀자."],
        },
        {
          id: "BOTH_WEAK_HWA",
          section: "일",
          priority: 60,
          when: (a, b) => a.elements["화"] <= 0.7 && b.elements["화"] <= 0.7,
          evidence: "둘 다 화 기운이 약해 실행 속도가 낮을 수 있어.",
          copies: ["작게 시작하면 속도 붙는다.", "일단 착수하는 약속이 필요."],
        },
        {
          id: "BOTH_WEAK_TO",
          section: "건강",
          priority: 60,
          when: (a, b) => a.elements["토"] <= 0.7 && b.elements["토"] <= 0.7,
          evidence: "둘 다 토 기운이 약해 리듬이 흔들릴 수 있어.",
          copies: ["루틴 고정하면 안정.", "식사/수면만 지키자."],
        },
        {
          id: "BOTH_WEAK_GEUM",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 기준이 느슨해질 수 있어.",
          copies: ["지출 기준부터 맞추자.", "큰돈은 합의로."],
        },
        {
          id: "BOTH_WEAK_SU",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["수"] <= 0.7 && b.elements["수"] <= 0.7,
          evidence: "둘 다 수 기운이 약해 회복이 느릴 수 있어.",
          copies: ["휴식 일정을 공유하자.", "컨디션 관리가 핵심."],
        },
        {
          id: "A_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => a.elements["목"] >= 1.5 && b.elements["목"] <= 0.8,
          evidence: "A의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["A가 시작, B가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "A_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => a.elements["화"] >= 1.5 && b.elements["화"] <= 0.8,
          evidence: "A의 추진력이 더 강해.",
          copies: ["A가 속도, B가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "A_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => a.elements["토"] >= 1.5 && b.elements["토"] <= 0.8,
          evidence: "A가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 A가 잡고 B가 실행.", "장기 운영에 유리."],
        },
        {
          id: "B_STRONG_MOK",
          section: "관계",
          priority: 62,
          when: (a, b) => b.elements["목"] >= 1.5 && a.elements["목"] <= 0.8,
          evidence: "B의 목 기운이 강해 방향을 제시하는 쪽이야.",
          copies: ["B가 시작, A가 정리하면 좋다.", "역할만 나누면 편하다."],
        },
        {
          id: "B_STRONG_HWA",
          section: "일",
          priority: 62,
          when: (a, b) => b.elements["화"] >= 1.5 && a.elements["화"] <= 0.8,
          evidence: "B의 추진력이 더 강해.",
          copies: ["B가 속도, A가 안정.", "타이밍만 맞추면 된다."],
        },
        {
          id: "B_STRONG_TO",
          section: "돈",
          priority: 62,
          when: (a, b) => b.elements["토"] >= 1.5 && a.elements["토"] <= 0.8,
          evidence: "B가 안정과 관리 쪽을 잡아주기 좋아.",
          copies: ["계획은 B가 잡고 A가 실행.", "장기 운영에 유리."],
        },
        {
          id: "BRANCH_LIUHE",
          section: "관계",
          priority: 90,
          when: (a, b) => isLiuhe(a.dayBranch, b.dayBranch),
          evidence: "일지 기준 육합이 성립돼 기본 호흡이 편해.",
          copies: ["같이 있으면 이유 없이 편하다.", "생활 템포가 잘 맞는다."],
        },
        {
          id: "BRANCH_SAMHAP",
          section: "일",
          priority: 80,
          when: (a, b) => isSamhap(a.dayBranch, b.dayBranch),
          evidence: "삼합 구조라 목표를 향해 힘이 모여.",
          copies: ["같은 목표일 때 폭발력이 좋다.", "팀플에 강한 조합."],
        },
        {
          id: "BRANCH_CHUNG",
          section: "관계",
          priority: 62,
          when: (a, b) => isChung(a.dayBranch, b.dayBranch),
          evidence: "지지 충으로 타이밍이 자주 엇갈릴 수 있어.",
          copies: ["중요한 얘기는 컨디션 좋을 때.", "속도보다 타이밍 맞추자."],
        },
        {
          id: "BRANCH_HAE",
          section: "성향",
          priority: 58,
          when: (a, b) => isHae(a.dayBranch, b.dayBranch),
          evidence: "해 관계가 있어 오해가 쌓일 수 있어.",
          copies: ["확인 한 번 더 하면 해결.", "문장보다 얼굴 보고."],
        },
        {
          id: "BRANCH_SELF_PUNISH",
          section: "건강",
          priority: 55,
          when: (a, b) =>
            a.dayBranch === b.dayBranch && isSelfPunish(a.dayBranch),
          evidence: "같은 지지라 감정을 안으로 쌓기 쉬운 구조야.",
          copies: ["기분을 바로 풀자.", "참는 게 문제 포인트."],
        },
        {
          id: "BRANCH_SAME",
          section: "관계",
          priority: 70,
          when: (a, b) => a.dayBranch === b.dayBranch,
          evidence: "일지가 같아서 감정 코드가 비슷해.",
          copies: ["말이 줄어도 통하는 편.", "고집 붙으면 잠깐 멈추자."],
        },
        {
          id: "BRANCH_ELEM_SAME",
          section: "성향",
          priority: 66,
          when: (a, b) => BRANCH_ELEM[a.dayBranch] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 같아 표현 방식이 유사해.",
          copies: ["소통 스타일이 맞는다.", "오해가 적은 편."],
        },
        {
          id: "BRANCH_ELEM_CLASH",
          section: "관계",
          priority: 60,
          when: (a, b) =>
            OVERCOME[BRANCH_ELEM[a.dayBranch]] === BRANCH_ELEM[b.dayBranch],
          evidence: "일지 오행이 상극이라 기분이 부딪힐 수 있어.",
          copies: ["감정 올라오면 속도 줄이자.", "중요한 얘기는 준비된 날."],
        },
        {
          id: "BRANCH_ELEM_SUPPORT",
          section: "관계",
          priority: 70,
          when: (a, b) =>
            BRANCH_ELEM[a.dayBranch] === b.topElem ||
            BRANCH_ELEM[b.dayBranch] === a.topElem,
          evidence: "한쪽의 일지 기운이 상대 강점을 받쳐줘.",
          copies: [
            "상대 장점을 잘 살려주는 조합.",
            "서로의 페이스를 살리면 좋다.",
          ],
        },
        {
          id: "MONEY_STYLE_MATCH",
          section: "돈",
          priority: 74,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) <= 0.4,
          evidence: "돈 쓰는 기준이 비슷해서 스트레스가 적어.",
          copies: ["공동 지출 기준만 정하면 된다.", "금전 갈등이 적은 조합."],
        },
        {
          id: "MONEY_STYLE_DIFF",
          section: "돈",
          priority: 62,
          when: (a, b) => Math.abs(a.moneyStyle - b.moneyStyle) >= 1.0,
          evidence: "돈 쓰는 기준이 꽤 다를 수 있어.",
          copies: ["약속만 정하면 문제 없다.", "큰돈은 함께, 작은 건 각자."],
        },
        {
          id: "MONEY_SAVING_GOOD",
          section: "돈",
          priority: 76,
          when: (a, b) => a.elements["토"] >= 1.2 && b.elements["토"] >= 1.2,
          evidence: "둘 다 토가 받쳐서 안정형 저축에 강해.",
          copies: ["장기 계획 세우기 좋다.", "비상금 관리에 강한 조합."],
        },
        {
          id: "MONEY_LEAK_RISK",
          section: "돈",
          priority: 58,
          when: (a, b) => a.elements["금"] <= 0.7 && b.elements["금"] <= 0.7,
          evidence: "둘 다 금 기운이 약해 지출 통제가 느슨해질 수 있어.",
          copies: [
            "자동이체/한도 설정이 답이야.",
            "소액이라도 기록해두면 안정돼.",
          ],
        },
        {
          id: "WORK_SPEED_MATCH",
          section: "일",
          priority: 74,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) <= 0.3,
          evidence: "일 처리 속도가 비슷해 협업이 편해.",
          copies: ["속도 조절 스트레스가 적어.", "같은 페이스로 달리면 최고."],
        },
        {
          id: "WORK_SPEED_DIFF",
          section: "일",
          priority: 62,
          when: (a, b) => Math.abs(a.elements["화"] - b.elements["화"]) >= 0.8,
          evidence: "일 처리 속도 차이가 커서 마찰이 생길 수 있어.",
          copies: [
            "기한만 분명하게 맞추자.",
            "속도 차이는 역할 분담으로 해결된다.",
          ],
        },
        {
          id: "WORK_IDEA_SUPPORT",
          section: "일",
          priority: 72,
          when: (a, b) =>
            (a.elements["목"] >= 1.3 && b.elements["화"] >= 1.3) ||
            (b.elements["목"] >= 1.3 && a.elements["화"] >= 1.3),
          evidence: "한쪽은 아이디어, 한쪽은 실행에 강해.",
          copies: [
            "기획과 실행이 잘 맞는 조합.",
            "역할만 명확히 하면 속도가 난다.",
          ],
        },
        {
          id: "HEALTH_RECOVERY_GOOD",
          section: "건강",
          priority: 76,
          when: (a, b) => a.elements["수"] >= 1.2 && b.elements["수"] >= 1.2,
          evidence: "둘 다 회복 탄력이 좋은 편이야.",
          copies: [
            "쉬는 날만 맞추면 컨디션이 확 좋아진다.",
            "수면만 지켜도 반은 성공.",
          ],
        },
        {
          id: "HEALTH_RHYTHM_GAP",
          section: "건강",
          priority: 58,
          when: (a, b) => Math.abs(a.elements["수"] - b.elements["수"]) >= 0.8,
          evidence: "회복 리듬 차이가 커서 피로가 엇갈릴 수 있어.",
          copies: [
            "컨디션 좋은 날에 중요한 일 배치.",
            "각자 쉬는 타이밍을 존중하자.",
          ],
        },
        {
          id: "HEALTH_DIGEST",
          section: "건강",
          priority: 58,
          when: (a, b) => a.elements["토"] <= 0.8 && b.elements["토"] <= 0.8,
          evidence: "둘 다 토 기운이 약해 컨디션이 흔들릴 수 있어.",
          copies: [
            "식사/수면 루틴만 잡아도 안정된다.",
            "무리한 약속을 줄이자.",
          ],
        },
        {
          id: "HEALTH_BALANCE_HELP",
          section: "건강",
          priority: 70,
          when: (a, b) =>
            (a.elements["토"] >= 1.3 && b.elements["수"] >= 1.3) ||
            (b.elements["토"] >= 1.3 && a.elements["수"] >= 1.3),
          evidence: "한쪽의 안정감과 한쪽의 회복력이 잘 맞아.",
          copies: [
            "생활 리듬을 공유하면 컨디션이 좋아진다.",
            "꾸준한 휴식이 강점.",
          ],
        },
      ];

      function getTunedPriority(rule) {
        return rule.priority;
      }

      function buildPerson(person) {
        const { top, weak } = getTopWeak(person.elements);
        const monthBranch = person.monthBranch || "";
        const seasonTopElem = monthBranch ? BRANCH_MAIN_ELEM[monthBranch] : "";
        const dayStem = person.dayStem || "";
        const dayElem = dayStem ? STEM_ELEM[dayStem] : "";
        const strength = calcStrength(person.elements, dayElem, seasonTopElem);
        return {
          ...person,
          topElem: top,
          weakElem: weak,
          topScore: person.elements[top],
          weakScore: person.elements[weak],
          balance: calcBalance(person.elements),
          seasonTopElem,
          dayStem,
          dayElem,
          strength,
          moneyStyle: person.elements["금"] + person.elements["수"],
        };
      }

      function evaluateRules(a, b) {
        return RULES.map((r) => {
          const activationScore = getRuleActivationScore(r, a, b);
          if (activationScore <= 0.15) return null;
          return {
            ...r,
            activationScore,
            tunedPriority: getTunedPriority(r),
          };
        }).filter(Boolean);
      }

      function calcSectionScores(firedRules) {
        const result = {};
        Object.keys(SECTION_WEIGHT).forEach(
          (s) => (result[s] = { sum: 0, cnt: 0 })
        );
        firedRules.forEach((r) => {
          if (result[r.section]) {
            result[r.section].sum += r.tunedPriority * r.activationScore;
            result[r.section].cnt += r.activationScore;
          }
        });
        const scores = {};
        Object.keys(result).forEach((s) => {
          scores[s] = result[s].cnt
            ? Math.round(result[s].sum / result[s].cnt)
            : 50;
        });
        return scores;
      }

      function calcTotalFromSections(sectionScores) {
        let total = 0;
        Object.entries(SECTION_WEIGHT).forEach(([k, w]) => {
          total += sectionScores[k] * w;
        });
        return Math.round(total);
      }

      function generateSummary(score) {
        if (score >= 85)
          return "전반적으로 궁합이 아주 좋아. 기본 결이 잘 맞고, 함께할수록 안정감이 커져.";
        if (score >= 70)
          return "좋은 흐름이야. 포인트 몇 가지만 맞추면 더 편안해질 수 있어.";
        if (score >= 55)
          return "차분하게 맞춰가면 충분히 좋은 관계로 이어질 수 있어.";
        return "지금은 조율이 필요한 구간이야. 기준만 맞추면 관계가 더 단단해질 수 있어.";
      }

      /* ======================================================
  6. 문구 보정
====================================================== */
      function applyTone(text) {
        return softenText(text);
      }
      function toneExtraTip(section) {
        if (section === "money") {
          return "지출 기준을 먼저 맞추는 게 편해.";
        }
        return "감정 올라오면 한 박자 쉬고 말하자.";
      }

      /* ======================================================
  7. 섹션 레이더 렌더
====================================================== */
      function renderRadar(scores) {
        const svg = sectionRadarSvg;
        const keys = ["성향", "관계", "돈", "일", "건강"];
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = name;
          svg.appendChild(text);
        });

        const vals = keys.map((k) => clamp01((scores[k] ?? 50) / 100));
        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(37,99,235,0.28)",
          stroke: "rgba(37,99,235,0.9)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      /* ======================================================
  8. 신년운세 월별
====================================================== */
      function pickMonthlyCopy(ctx) {
        const { month, seasonElem, top, weak, relTop, relWeak, dayElem } = ctx;
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";

        const monthLabel = `${month}월`;
        const templates = {
          push: [
            [
              `${monthLabel}은 길운이 문턱을 넘는 달이야. 흐름이 내 편이니 밀어붙이면 성과가 나.`,
              "가장 중요한 일 하나를 먼저 끝내고, 나머지는 순서를 잡아야 해.",
              "작은 성공을 크게 키울 수 있으니 기회를 놓치지 말자.",
              "세운이 도움을 주는 달이니 움직이는 만큼 얻음이 따라와.",
            ],
            [
              `${monthLabel}은 속도가 붙는 달이야. 미루던 일을 처리하기에 딱 좋아.`,
              "연락/결정/정리 중 하나는 이번 달에 끝내고, 다음 단계를 준비해.",
              "발이 빠를수록 운이 붙는 시기야.",
              "기회가 눈앞에 있으니 과감하게 나서면 복이 따라와.",
            ],
          ],
          pushPlus: [
            [
              `${monthLabel}은 좋은 흐름과 회복이 함께 오는 달이야.`,
              "욕심을 내어도 되지만 수면과 식사는 반드시 지켜야 해.",
              "힘이 붙으니 큰일도 충분히 감당할 수 있어.",
              "세운과 기운이 맞물려 빠르게 풀리는 달이야.",
            ],
            [
              `${monthLabel}은 잘 풀리면서 마음이 편해지는 달이야.`,
              "새로 벌리기보다 기존을 다듬으면 크게 남아.",
              "작은 개선이 큰 복으로 돌아와.",
              "도움이 손에 닿는 때니 정성을 아끼지 말자.",
            ],
          ],
          recover: [
            [
              `${monthLabel}은 회복이 곧 복이야. 기력만 잡아도 일이 풀려.`,
              "무리한 약속을 줄이고 루틴 하나를 붙여야 해.",
              "쉬어가는 한 달이 오히려 길운을 불러와.",
              "세운이 숨 고르기를 요구하니 몸과 마음을 먼저 다스리자.",
            ],
            [
              `${monthLabel}은 정리하면 운이 붙는 달이야.`,
              "공간/돈/일정 중 하나만 정리해도 체감이 와.",
              "지우고 덜어낼수록 기운이 맑아져.",
              "세운이 정리수로 흐르니 덜어낼수록 이익이야.",
            ],
          ],
          brake: [
            [
              `${monthLabel}은 무리하면 손해 보는 달이야. 속도를 줄이는 게 이득이야.`,
              "큰 결정은 2주만 미루고 확인부터 해.",
              "서두르면 흉이 되고, 멈추면 길이 돼.",
              "세운이 제동을 거니 한 걸음 물러나 살피는 게 좋아.",
            ],
            [
              `${monthLabel}은 신중이 곧 돈이야.`,
              "계약/투자/충동구매는 한 번 더 점검해.",
              "지키는 자에게 복이 머물러.",
              "세운이 과열을 경계하니 조심하는 게 길이야.",
            ],
          ],
          steady: [
            [
              `${monthLabel}은 유지가 이기는 달이야. 기본만 지켜도 충분해.`,
              "루틴 3개(수면/식사/정리)만 챙기면 돼.",
              "작은 이익을 모아 큰 복으로 바꿀 시기야.",
              "세운이 평온하니 성실이 곧 복이야.",
            ],
            [
              `${monthLabel}은 큰 변화보다 작은 개선이 맞아.`,
              "5% 개선 목표로 가면 꾸준히 이겨.",
              "욕심을 줄이면 오히려 얻음이 있어.",
              "세운이 안정이니 작은 성실이 큰 복이 돼.",
            ],
          ],
        };

        const seed = `${month}|${seasonElem}|${top}|${weak}|${mode}`;
        const arr = templates[mode];
        const idx = hashToIndex(seed, arr.length);
        let [oneLine, tip, extra, detail] = arr[idx];
        oneLine = casualizeText(oneLine);
        tip = casualizeText(tip);
        extra = casualizeText(extra);
        detail = casualizeText(detail);
        let luckTag = "중";
        if (dayElem) {
          const relDay = relationElem(seasonElem, dayElem);
          if (relDay === "생" || relDay === "동") luckTag = "길";
          else if (relDay === "극" || relDay === "눌림") luckTag = "흉";
          else luckTag = "중";
        } else {
          luckTag =
            mode === "push" || mode === "pushPlus"
              ? "길"
              : mode === "brake"
              ? "흉"
              : "중";
        }

        // 월별 상세 설명 생성
        const monthDetails = generateMonthDetails(
          month,
          seasonElem,
          mode,
          luckTag,
          dayElem
        );

        return {
          oneLine,
          tip,
          extra,
          detail,
          monthDetails,
          mode,
          luckTag,
          tags: [luckTag, mode, seasonElem],
        };
      }

      function generateMonthDetails(month, seasonElem, mode, luckTag, dayElem) {
        const monthLabels = [
          "",
          "1월",
          "2월",
          "3월",
          "4월",
          "5월",
          "6월",
          "7월",
          "8월",
          "9월",
          "10월",
          "11월",
          "12월",
        ];
        const monthLabel = monthLabels[month] || `${month}월`;

        const templates = {
          push: {
            길: [
              `${monthLabel} 길운과 월성이 함께 문을 두드리니 맨손으로도 성공할 기운이야. 관록이 들기 시작하니 지위와 책임을 얻어도 부족함이 없어. 자손을 얻어야 할 시기라면 좋은 소식이 있을 거고, 가족 중에서라도 새 식구의 잉태나 혼인 소식이 있을 거야. 올해 새 식구를 맞이하게 되면 온 가족이 길해질 거니 귀인으로 맞이하자.`,
              `${monthLabel} 기운이 청아해서 만나는 사람마다 기쁨을 주게 돼. 애정도 좋고 가정에 기쁨도 있고 새로운 일로 인해 분주함도 있으니 나쁠 일이 없어. 다만 건강상의 문제로 잔병을 치를 수도 있으니 과로를 경계하자. 시작이 좋으니 한 해가 좋음을 미리 알리는 징후야. 귀인을 만나서 재물을 얻을 수 있으니 크지는 않지만 수익도 좋은 달이야.`,
            ],
            중: [
              `${monthLabel} 길상의 기운이 들어 액운을 막아주고 비로소 뜻을 크게 품으니 분주함도 많고 노력도 많아져야 해. 노력하지 않으면 얻을 게 없으니 준비해야 할 일이 있으면 남에게 의탁하지 말고 직접 움직이자. 인연이 좋아서 움직일수록 크게 도움받을 일이 생겨. 대길운이 서서히 문안으로 들어오기 시작하니 기운이 활기찬 걸 느낄 수 있을 거야.`,
            ],
          },
          pushPlus: {
            길: [
              `${monthLabel} 애정이 많은 시기니 사랑을 깊이 있게 하는 시기야. 가정이 있으면 다른 이성에게 눈이 가지 않도록 조심하자. 나의 눈도 좋지만 상대가 나를 바라보는 눈도 아름다운 시기야. 인기가 많고 자신의 장점이 부각되어 많은 사람들로부터 칭찬을 듣게 돼. 선남선녀들은 새롭게 만나는 만남이나 연인들과의 만남이 모두 좋을 거니 프러포즈를 받기도 하고 하기도 해. 좋은 결과가 있을 거야.`,
            ],
          },
          brake: {
            흉: [
              `${monthLabel} 용맹함을 다한 범이 들판으로 나섰으니 사냥꾼의 먹이밖에 안 돼. 의욕이 앞서 실수를 범할 수 있으니 매사 신중해야 해. 나서지 말고 몸을 낮추는 지혜를 발휘하면 후환이 없어. 동남쪽 방향이 길방이니 재물이 머문 곳이야. 금년은 북쪽이 길하지만 이번 달만큼은 동남쪽이 길한 방향이야. 자중하면 잃을 게 없으니 다음을 기약해도 늦지 않아.`,
              `${monthLabel} 자신의 재물을 주머니 깊이 넣어두지 않으면 반드시 이를 노리는 사람이 있어. 다른 사람과 재물에 관한 거래를 절대로 하지 말자. 가족 중에 환자가 생길 거니 근심이 생기는 달이야. 이번 달이 큰 고비인데 새롭게 일을 확장하면 해결의 실마리가 보이지 않으니 때를 기다리는 지혜를 많이 발휘해야 해. 쉬어가는 게 결코 늦지 않아.`,
              `${monthLabel} 서산에 해는 지는데 갈 길은 멀고, 젓가락 놀리듯 바쁘기만 한 발걸음과 같아. 두 사람의 마음이 서로 다르니 하는 일을 끝내 이루지 못해. 마음이 문제인데 문제는 욕심이야. 손해를 보거나 다툼이 있을 수 있으니 주의하되 매사에 목성(木姓)을 가까이하지 말자. 해는 중턱으로 넘어서고 갈 길은 먼데 넘어야 할 고개는 아직도 멀리 있어. 두 사람의 마음이 서로 다르니 이것이 마지막 어려움이 될 듯해. 욕심을 버려야 하는데 이 또한 쉽지 않아.`,
            ],
            중: [
              `${monthLabel} 흉함이 변하여 길함이 되니 세상일이 태평하고 마음이 평안한 시기야. 모처럼 근심 걱정이 사라지니 새로운 계획을 세우기에 좋아. 그러나 서두르면 해가 되니 경거망동해서 외부로 바쁘게 돌면 손실이 있어. 마지막 풍파가 한 번은 더 있을 거니 길하다고 해서 마음을 놓으면 안 돼. 집안에 있어서 새로운 계획을 세우면 후일이 더욱 좋으니 명심하자.`,
            ],
          },
          recover: {
            중: [
              `${monthLabel} 하늘과 땅이 서로 화합해서 그 이익이 재물이나 일로 생길 운세야. 작은 걸 버려 큰 걸 취하는 운세니 기존 건 잊어버려도 돼. 새로 투자하는 부분은 아직 서둘러선 안 돼. 매사가 좋음이 더 많으니 손익을 따지면 반드시 얻음이 클 거지만 신규로 재물을 들여 얻는 건 위험수가 있으니 자중이 필요해. 서쪽으로 가면 불리하니 서쪽 방향으로 움직이는 일은 경계하고 피하자.`,
              `${monthLabel} 마른 샘에 비가 내리는 형국이야. 비로소 막혔던 일이 풀리고 시원함을 느끼게 되는 달이야. 문제가 됐던 건 해결의 실마리가 보이는 시기야. 한 해의 시작이 일 년을 좌우하는데 올해는 일이 잘 풀릴 징조가 보여. 자신의 위치와 지위가 크게 향상되어 뜻한 바를 실행에 옮길 준비가 갖춰져. 좋은 인연도 만나는 시기니 대인적인 교류가 많아질 거야.`,
              `${monthLabel} 주변에 역마가 끼어 나를 괴롭히는 자가 있으니 재물이 나가지 않으나 마음이 상할 기운이 있어. 가까운 벗이 나를 의지하니 돕지 않으면 안 되는 일이 생겨. 마음을 크게 먹고 진심으로 도우면 친구도 좋고 나도 좋은 일이 후에 있을 거야. 음덕으로 쌓아 후일의 기쁨으로 삼고자 하면 액운은 아니니 덕을 쌓는 시기로 삼고 자신의 것보다는 후일의 덕을 생각하며 보내자. 머지않아 큰 기쁨이 올 거야.`,
              `${monthLabel} 상하가 화목해서 집안에 문제가 없어. 화목이 곧 길운의 시작이니 가족 중에 근심 있는 자의 고민이 사라질 거야. 황룡이 구슬을 가지고 노는 괘를 얻었으니 곧 이루고자 하는 걸 이룰 수 있을 거야. 다만 때가 아님이 아쉬움으로 남으니 서둘러 일을 실천에 옮기는 일은 없도록 하자. 준비를 함에 만전을 기해야 함을 잊지 말자.`,
            ],
          },
          steady: {
            중: [
              `${monthLabel} 유지가 이기는 달이야. 기본만 지켜도 충분해. 루틴 3개(수면/식사/정리)만 챙기면 돼. 작은 이익을 모아 큰 복으로 바꿀 시기야. 세운이 평온하니 성실이 곧 복이야.`,
              `${monthLabel} 큰 변화보다 작은 개선이 맞아. 5% 개선 목표로 가면 꾸준히 이겨. 욕심을 줄이면 오히려 얻음이 있어. 세운이 안정이니 작은 성실이 큰 복이 돼.`,
            ],
          },
        };

        const modeTemplates = templates[mode] || templates.steady;
        const luckTemplates =
          modeTemplates[luckTag] ||
          modeTemplates.중 ||
          modeTemplates[Object.keys(modeTemplates)[0]];
        const seed = `${month}|${seasonElem}|${mode}|${luckTag}`;
        const idx = hashToIndex(seed, luckTemplates.length);
        return casualizeText(luckTemplates[idx] || "");
      }

      function makeMonthlyLuck(person) {
        const { top, weak } = getTopWeak(person.elements);
        const dayElem = person.dayElem || "";
        const months = [];
        for (let m = 1; m <= 12; m++) {
          const flow = MONTH_FLOW[m];
          const s = flow.seasonTop;
          const relTop = relationElem(top, s);
          const relWeak = relationElem(weak, s);
          const { oneLine, tip, extra, detail, monthDetails, tags } =
            pickMonthlyCopy({
              month: m,
              seasonElem: s,
              top,
              weak,
              relTop,
              relWeak,
              dayElem,
            });
          months.push({
            month: m,
            seasonElem: s,
            monthBranch: flow.monthBranch,
            summary: oneLine,
            tip,
            extra,
            detail,
            monthDetails,
            tags,
          });
        }
        return months;
      }

      function renderMonthly(person) {
        monthlyList.innerHTML = makeMonthlyLuck(person)
          .map(
            (m) => `
            <div class="rule-card">
              <div class="row" style="justify-content: space-between; align-items: center;">
                <div class="section-title">${m.month}월 · ${
              m.seasonElem
            } 흐름</div>
                <div style="margin-left: auto; display: flex; align-items: center; justify-content: flex-end; gap: 6px; flex-wrap: wrap;">${formatMonthTags(
                  m.tags
                )}</div>
              </div>
              <p class="lead" style="font-size: 17px; line-height: 1.6;">${escapeHtml(
                m.summary
              )}</p>
              ${
                m.monthDetails
                  ? `<div style="margin-top: 16px; padding: 14px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; border-left: 3px solid var(--accent);">
                      <p style="font-size: 15px; line-height: 1.9; margin: 0; color: rgba(15, 23, 42, 0.85);">${escapeHtml(
                        m.monthDetails
                      )}</p>
                    </div>`
                  : ""
              }
              ${
                m.extra
                  ? `<div style="margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p style="font-size: 14px; margin: 0; line-height: 1.8; color: rgba(15, 23, 42, 0.8);">${escapeHtml(
                       m.extra
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.detail
                  ? `<div style="margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                     <p style="font-size: 14px; margin: 0; line-height: 1.8; color: rgba(15, 23, 42, 0.8);">${escapeHtml(
                       m.detail
                     )}</p>
                   </div>`
                  : ""
              }
              ${
                m.tip
                  ? `<div style="margin-top: 12px; padding: 12px; background: rgba(34, 197, 94, 0.08); border-radius: 6px; border-left: 3px solid rgba(34, 197, 94, 0.5);">
                     <p style="font-size: 14px; margin: 0; line-height: 1.8; font-weight: 600; color: rgba(15, 23, 42, 0.9);">
                       <span style="color: rgba(34, 197, 94, 0.9);">💡 팁:</span> ${escapeHtml(
                         m.tip
                       )}
                     </p>
                   </div>`
                  : ""
              }
              <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
                <button class="btn compact" data-month="${
                  m.month
                }" data-month-index="${
              m.month - 1
            }" style="font-size: 12px; padding: 6px 12px;">
                  📋 공유하기
                </button>
              </div>
            </div>`
          )
          .join("");

        // 공유 버튼 이벤트 리스너 추가
        setTimeout(() => {
          monthlyList.querySelectorAll("[data-month]").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const monthIndex = parseInt(btn.getAttribute("data-month-index"));
              const monthData = makeMonthlyLuck(person)[monthIndex];
              await shareMonthlyCard(monthData);
            });
          });
        }, 100);
      }

      async function shareMonthlyCard(monthData) {
        const monthLabels = [
          "",
          "1월",
          "2월",
          "3월",
          "4월",
          "5월",
          "6월",
          "7월",
          "8월",
          "9월",
          "10월",
          "11월",
          "12월",
        ];
        const monthLabel =
          monthLabels[monthData.month] || `${monthData.month}월`;

        // 태그 텍스트 추출
        const [luckTag, mode, seasonElem] = monthData.tags || [];
        const luckText =
          luckTag === "길" ? "길운" : luckTag === "흉" ? "흉운" : "중운";
        const modeText = monthModeText(mode);
        const tagsText = `${luckText} · ${modeText} · ${seasonElem} 기운`;

        let text = `🔮 ${monthLabel} 운세\n\n`;
        text += `${monthData.summary}\n\n`;

        if (monthData.monthDetails) {
          text += `${monthData.monthDetails}\n\n`;
        }
        if (monthData.extra) {
          text += `${monthData.extra}\n\n`;
        }
        if (monthData.detail) {
          text += `${monthData.detail}\n\n`;
        }
        if (monthData.tip) {
          text += `💡 팁: ${monthData.tip}\n\n`;
        }

        text += `태그: ${tagsText}\n`;
        text += `\n#사주풀이 #신년운세 #${monthLabel}운세\n\n`;
        text += `🔮 사주풀이 서비스: https://saju.funnyfunny.cloud/`;

        try {
          await navigator.clipboard.writeText(text);
          alert(`${monthLabel} 운세가 클립보드에 복사되었습니다!`);
        } catch (err) {
          // 클립보드 API가 없거나 실패한 경우
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            alert(`${monthLabel} 운세가 클립보드에 복사되었습니다!`);
          } catch (e) {
            prompt("복사할 내용:", text);
          }
          document.body.removeChild(textarea);
        }
      }

      /* ======================================================
  9. 렌더
====================================================== */
      function renderSummary(totalScore, firedRules, toneKey, coupleElements) {
        const summary = generateSummary(totalScore);
        totalScoreEl.textContent = `${totalScore}점`;
        summaryMain.textContent = softenText(summary);
        summarySub.textContent = "입력 시간대 기준 · 절기/오행 규칙";

        const { top, weak } = getTopWeak(coupleElements);
        const pills = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          `발동 룰: ${firedRules.length}개`,
        ];
        summaryPills.innerHTML = pills
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");
      }

      function renderRules(firedRules, toneKey, tokens) {
        if (!firedRules.length) {
          ruleList.innerHTML = `<p class="mini">발동된 룰이 아직 없어. 입력값을 확인해줘.</p>`;
          return;
        }
        const ruleLabel = (id) => {
          const map = {
            ELEM_TOP_SAME: "핵심 오행 동일",
            ELEM_TOP_COMPLEMENT: "핵심 오행 상생",
            ELEM_TOP_CLASH: "핵심 오행 상극",
            ELEM_WEAK_SAME: "약한 오행 동일",
            ELEM_WEAK_COMPLEMENT: "약한 오행 보완",
            ELEM_WEAK_CLASH: "약한 오행 충돌",
            ELEM_BALANCE_GOOD: "균형 안정",
            ELEM_BALANCE_BAD: "균형 불안",
            A_DOMINANT: "A 주도 성향",
            B_DOMINANT: "B 주도 성향",
            SEASON_SUPPORT: "월령 보강",
            SEASON_CLASH: "월령 충돌",
            SEASON_SAME: "월령 동일",
            BOTH_STRONG_MOK: "둘 다 목 강",
            BOTH_STRONG_HWA: "둘 다 화 강",
            BOTH_STRONG_TO: "둘 다 토 강",
            BOTH_STRONG_GEUM: "둘 다 금 강",
            BOTH_STRONG_SU: "둘 다 수 강",
            BOTH_WEAK_MOK: "둘 다 목 약",
            BOTH_WEAK_HWA: "둘 다 화 약",
            BOTH_WEAK_TO: "둘 다 토 약",
            BOTH_WEAK_GEUM: "둘 다 금 약",
            BOTH_WEAK_SU: "둘 다 수 약",
            A_STRONG_MOK: "A 목 강 / B 목 약",
            A_STRONG_HWA: "A 화 강 / B 화 약",
            A_STRONG_TO: "A 토 강 / B 토 약",
            A_STRONG_GEUM: "A 금 강 / B 금 약",
            A_STRONG_SU: "A 수 강 / B 수 약",
            B_STRONG_MOK: "B 목 강 / A 목 약",
            B_STRONG_HWA: "B 화 강 / A 화 약",
            B_STRONG_TO: "B 토 강 / A 토 약",
            B_STRONG_GEUM: "B 금 강 / A 금 약",
            B_STRONG_SU: "B 수 강 / A 수 약",
          };
          return map[id] || id;
        };

        ruleList.innerHTML = firedRules
          .sort(
            (a, b) =>
              b.tunedPriority * b.activationScore -
              a.tunedPriority * a.activationScore
          )
          .map((r) => {
            const evidence = applyTone(fillTokens(r.evidence, tokens));
            const copy = applyTone(r.copies[0]);
            const copy2 = r.copies[1] ? applyTone(r.copies[1]) : "";
            const extra =
              r.section === "돈"
                ? toneExtraTip("money")
                : toneExtraTip("conflict");
            const strength = Math.round(r.activationScore * 100);
            const insight =
              r.section === "돈"
                ? "돈 흐름은 규칙 합의가 있을수록 안정된다."
                : r.section === "건강"
                ? "리듬이 맞을수록 컨디션 회복이 빠르다."
                : r.section === "일"
                ? "속도보다 방향 정렬이 성과를 만든다."
                : r.section === "관계"
                ? "감정 곡선을 맞추면 충돌이 줄어든다."
                : "기질의 차이를 인정할수록 편해진다.";
            return `
            <div class="rule-card">
              <div class="rule-head">
                <b>${escapeHtml(ruleLabel(r.id))}</b>
              </div>
              <p class="mini">근거: ${escapeHtml(
                evidence
              )} · 강도 ${strength}%</p>
              <p>${escapeHtml(copy)}${
              extra
                ? `<br/><span class="mini">+ ${escapeHtml(extra)}</span>`
                : ""
            }${
              copy2
                ? `<br/><span class="mini">+ ${escapeHtml(copy2)}</span>`
                : ""
            }</p>
              <p class="mini">해석: ${escapeHtml(insight)}</p>
            </div>`;
          })
          .join("");
      }

      function renderPillars(targetEl, result) {
        if (!result) {
          targetEl.textContent = "—";
          return;
        }
        const p = result.pillars;
        const tzText = formatTzOffset(result.input.tzOffsetMinutes);
        const hourText = p.hour ? p.hour.text : "미포함";
        targetEl.innerHTML = `입력: ${result.input.local} (UTC${tzText})<br/>
          연: ${p.year.text} / 월: ${p.month.text}<br/>
          일: ${p.day.text} / 시: ${hourText}`;
      }

      function formatElemLine(prefix, obj, totalSum = null) {
        const order = ["목", "화", "토", "금", "수"];
        const lead = prefix ? `${prefix} ` : "";
        return `${lead}${order
          .map((k) => {
            const v = Math.round((obj[k] || 0) * 10) / 10;
            if (!totalSum) return `${k} ${v}`;
            const p = Math.round(((obj[k] || 0) / totalSum) * 1000) / 10;
            return `${k} ${v}(${p}%)`;
          })
          .join(" · ")}`;
      }

      function makeElementProfile(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        const strong = [];
        const mid = [];
        const weak = [];
        order.forEach((k) => {
          const v = elements[k] || 0;
          const ratio = avg ? v / avg : 1;
          if (ratio >= 1.2) strong.push(k);
          else if (ratio <= 0.8) weak.push(k);
          else mid.push(k);
        });
        return {
          strong: strong.length ? strong.join(" · ") : "—",
          mid: mid.length ? mid.join(" · ") : "—",
          weak: weak.length ? weak.join(" · ") : "—",
          avg: Math.round(avg * 10) / 10,
        };
      }

      function makeElementEvidence(elements, breakdown, top, low) {
        if (!breakdown) return "";
        const sum = (obj, key) => Math.round((obj?.[key] || 0) * 10) / 10;
        const format = (elem) =>
          `${elem} ${Math.round((elements[elem] || 0) * 10) / 10} = 천간 ${sum(
            breakdown.stems,
            elem
          )} · 지지 ${sum(breakdown.branches, elem)} · 장간 ${sum(
            breakdown.hidden,
            elem
          )} · 월령 ${sum(breakdown.season, elem)}`;
        return `${format(top)} / 약한 ${format(low)}`;
      }

      function elementDeltaLines(elements) {
        const order = ["목", "화", "토", "금", "수"];
        const total = order.reduce((s, k) => s + (elements[k] || 0), 0);
        const avg = total / 5;
        return order
          .map((k) => {
            const v = Math.round((elements[k] || 0) * 10) / 10;
            const diff = Math.round((v - avg) * 10) / 10;
            const sign = diff >= 0 ? "+" : "";
            return `${k} ${v} (${sign}${diff})`;
          })
          .join(" · ");
      }

      function elementAdvice(profile) {
        const lines = [];
        if (profile.strong !== "—") {
          lines.push(
            `강한 오행 활용: ${profile.strong} 쪽을 메인 축으로 밀면 효율이 좋아.`
          );
        }
        if (profile.mid !== "—") {
          lines.push(
            `중간 오행 조율: ${profile.mid} 쪽이 완충 역할이라 밸런스를 잡아줘.`
          );
        }
        if (profile.weak !== "—") {
          lines.push(
            `약한 오행 보완: ${profile.weak} 쪽은 생활 루틴/환경으로 채우면 체감이 커.`
          );
        }
        return lines;
      }
      function getElementProsCons(topElem, lowElem) {
        const pros = {
          목: "기획/성장에 강점이 있어 흐름을 길게 보는 눈이 좋아.",
          화: "추진/표현에 강점이 있어 속도와 에너지가 잘 붙어.",
          토: "안정/관리에 강점이 있어 기반을 단단히 다지는 힘이 있어.",
          금: "결과/정리에 강점이 있어 마무리와 성과 체감이 빠른 편이야.",
          수: "정보/환경에 강점이 있어 변화에 유연하게 대응해.",
        };
        const cons = {
          목: "기획에 치우치면 실행이 느려질 수 있어. 작게라도 바로 움직이면 좋아.",
          화: "속도가 빠른 만큼 과열되기 쉬워. 페이스 조절이 성과를 지켜줘.",
          토: "안정이 강하면 변화 대응이 느릴 수 있어. 작은 변화부터 열어두면 좋아.",
          금: "성과 중심이 강하면 압박이 커질 수 있어. 과정을 즐기면 더 길게 간다.",
          수: "유연함이 큰 만큼 기준이 흐려질 수 있어. 기준을 먼저 잡아두면 좋아.",
        };
        const prosText =
          pros[topElem] || "강점이 분명해서 방향만 잡으면 성과가 잘 나와.";
        const consText =
          cons[lowElem] || "약한 구간은 루틴으로 채우면 흐름이 안정돼.";
        return { prosText, consText };
      }

      function renderElementsAnalysis(elements, breakdown, meta = {}) {
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const topIdx = values.indexOf(Math.max(...values));
        const lowIdx = values.indexOf(Math.min(...values));
        const top = keys[topIdx];
        const low = keys[lowIdx];
        const personality = getElementPersonality(top, low);
        const profile = makeElementProfile(elements);
        const evidenceLine = makeElementEvidence(elements, breakdown, top, low);
        const { prosText, consText } = getElementProsCons(top, low);

        const totalSum = values.reduce((a, b) => a + b, 0) || 1;
        const rounded = keys.reduce((acc, k) => {
          acc[k] = Math.round((elements[k] || 0) * 10) / 10;
          return acc;
        }, {});
        const percent = keys.reduce((acc, k) => {
          acc[k] = Math.round(((elements[k] || 0) / totalSum) * 1000) / 10;
          return acc;
        }, {});

        elementsSummary.textContent = `오행 분석: ${top} 기운이 가장 강하고, ${low} 기운이 상대적으로 약한 편이야. ${softenText(
          prosText
        )} ${softenText(consText)}`;
        renderElementsRadar(elements);

        // 신토정비결 보정 정보 HTML 생성
        let anchorInfoHtml = null;
        let elementsTableHtml = "";
        if (meta.anchorKey) {
          const keyParts = meta.anchorKey.split("|");
          const SHINTO_ANCHORS = {
            "병인|계사|병자|무자": { 목: 16, 화: 33, 토: 24, 금: 7, 수: 70 },
            "무진|기미|정해|신해": { 목: 26, 화: 9, 토: 70, 금: 10, 수: 35 },
            "을해|갑신|기축|계유": { 목: 27, 화: 0, 토: 32, 금: 49, 수: 42 },
            "임술|병오|계미|신유": { 목: 3, 화: 42, 토: 46, 금: 49, 수: 10 },
            "경신|신사|임인|기유": { 목: 16, 화: 23, 토: 31, 금: 73, 수: 7 },
            "무오|정사|신묘|정유": { 목: 30, 화: 56, 토: 27, 금: 37, 수: 0 },
            "계미|정사|정해|기유": { 목: 10, 화: 35, 토: 42, 금: 37, 수: 26 },
          };
          const anchorData = SHINTO_ANCHORS[meta.anchorKey];
          const statusText = meta.anchorApplied ? "적용됨" : "미적용";
          const statusClass = meta.anchorApplied ? "chip e-wood" : "chip";

          if (anchorData) {
            anchorInfoHtml = `
              <div style="margin: 16px 0; padding: 16px; background: rgba(99, 102, 241, 0.05); border-radius: var(--radius-sm); border: 1px solid rgba(99, 102, 241, 0.15);">
                <div class="section-title" style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                  <span>🔮 신토정비결 보정</span>
                  <span class="${statusClass}" style="font-size: 11px; padding: 4px 10px;">${statusText}</span>
                </div>
                <div style="margin-bottom: 12px;">
                  <table class="report-table" style="font-size: 13px;">
                    <thead>
                      <tr>
                        <th style="width: 80px;">구분</th>
                        <th>년</th>
                        <th>월</th>
                        <th>일</th>
                        <th>시</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th>간지</th>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[0] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[1] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[2] || "—"
                        )}</td>
                        <td style="font-weight: 800; color: var(--accent);">${escapeHtml(
                          keyParts[3] || "—"
                        )}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div>
                  <table class="report-table" style="font-size: 13px; width: 100%;">
                    <thead>
                      <tr>
                        <th style="width: 90px; text-align: center;">오행</th>
                        <th style="width: 80px; text-align: center;">목</th>
                        <th style="width: 80px; text-align: center;">화</th>
                        <th style="width: 80px; text-align: center;">토</th>
                        <th style="width: 80px; text-align: center;">금</th>
                        <th style="width: 80px; text-align: center;">수</th>
                        <th style="width: 70px; text-align: center;">합계</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th style="text-align: center; vertical-align: middle;">보정값</th>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #e8f7e9; color: #0f3d2e;">${
                          anchorData.목
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #ffe9e3; color: #7a1f16;">${
                          anchorData.화
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #f8f1df; color: #5a3b12;">${
                          anchorData.토
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #eef3ff; color: #1b3a70;">${
                          anchorData.금
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; border-radius: 6px; font-weight: 800; font-size: 14px; background: #e6f5ff; color: #0c3550;">${
                          anchorData.수
                        }</td>
                        <td style="text-align: center; vertical-align: middle; padding: 8px; font-weight: 800; font-size: 15px; color: var(--accent); background: rgba(99, 102, 241, 0.1);">${Object.values(
                          anchorData
                        ).reduce((a, b) => a + b, 0)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <p class="mini" style="margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.5); border-radius: 8px; line-height: 1.6;">
                  ${
                    meta.anchorApplied
                      ? "✅ <strong>신토정비결 보정 적용</strong><br/>너의 사주 간지 조합은 신토정비결(전통 사주 해석서)에 기록된 특별한 패턴이야. 일반 계산 대신 신토정비결에서 정한 오행 분포값을 써서 더 정확하게 보여줘."
                      : "ℹ️ <strong>신토정비결 보정 미적용</strong><br/>너의 사주 간지 조합에 대한 신토정비결 기준 데이터가 없어서 일반 계산으로 오행을 산출했어."
                  }
                </p>
              </div>
            `;
          } else {
            anchorInfoHtml = `
              <div style="margin: 12px 0;">
                <div class="section-title" style="margin-bottom: 8px;">
                  신토정비결 보정 <span class="chip" style="font-size: 11px; padding: 2px 8px;">미적용</span>
                </div>
                <p class="mini">간지: ${escapeHtml(meta.anchorKey)}</p>
                <p class="mini">해당 간지 조합에 대한 신토정비결 보정 데이터가 없어.</p>
              </div>
            `;
          }
        }

        // 오행 정보 표 생성
        elementsTableHtml = `
          <div style="margin: 16px 0;">
            <div class="section-title" style="margin-bottom: 12px;">📊 오행 분석</div>
            <div class="pill-row" style="margin-bottom: 12px;">
              <span class="pill emphasis">일간 기준: ${escapeHtml(
                meta.dayElem || "—"
              )} 기운 인간(본질)</span>
              <span class="pill emphasis">오행 분포: ${escapeHtml(
                top
              )} 강세(환경)</span>
            </div>
            ${
              meta.birthText
                ? `<p class="mini" style="margin-bottom: 12px;"><strong>출생:</strong> ${escapeHtml(
                    meta.birthText
                  )}</p>`
                : ""
            }
            <table class="report-table" style="font-size: 13px; margin-bottom: 12px;">
              <thead>
                <tr>
                  <th style="width: 100px;">구분</th>
                  <th style="width: 80px; text-align: center;">목</th>
                  <th style="width: 80px; text-align: center;">화</th>
                  <th style="width: 80px; text-align: center;">토</th>
                  <th style="width: 80px; text-align: center;">금</th>
                  <th style="width: 80px; text-align: center;">수</th>
                  <th style="width: 70px; text-align: center;">합계</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th style="vertical-align: middle;">분포(%)</th>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["목"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["화"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["토"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["금"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 700;">${
                    percent["수"]
                  }%</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 800; color: var(--accent);">100%</td>
                </tr>
                <tr>
                  <th style="vertical-align: middle;">점수(150)</th>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #e8f7e9; color: #0f3d2e;">${
                    rounded["목"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #ffe9e3; color: #7a1f16;">${
                    rounded["화"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #f8f1df; color: #5a3b12;">${
                    rounded["토"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #eef3ff; color: #1b3a70;">${
                    rounded["금"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; padding: 6px; border-radius: 4px; font-weight: 800; background: #e6f5ff; color: #0c3550;">${
                    rounded["수"]
                  }</td>
                  <td style="text-align: center; vertical-align: middle; font-weight: 800; color: var(--accent);">150</td>
                </tr>
                <tr>
                  <th style="vertical-align: middle;">평균 대비</th>
                  ${["목", "화", "토", "금", "수"]
                    .map((k) => {
                      const v = Math.round((elements[k] || 0) * 10) / 10;
                      const avg = totalSum / 5;
                      const diff = Math.round((v - avg) * 10) / 10;
                      const sign = diff >= 0 ? "+" : "";
                      const color =
                        diff >= 0 ? "var(--accent)" : "rgba(15, 23, 42, 0.6)";
                      return `<td style="text-align: center; vertical-align: middle; font-weight: 700; color: ${color};">${sign}${diff}</td>`;
                    })
                    .join("")}
                  <td style="text-align: center; vertical-align: middle;">—</td>
                </tr>
              </tbody>
            </table>
            ${
              breakdown
                ? `
              <table class="report-table" style="font-size: 12px; margin-bottom: 12px;">
                <thead>
                  <tr>
                    <th style="width: 100px;">구분</th>
                    <th style="width: 80px; text-align: center;">목</th>
                    <th style="width: 80px; text-align: center;">화</th>
                    <th style="width: 80px; text-align: center;">토</th>
                    <th style="width: 80px; text-align: center;">금</th>
                    <th style="width: 80px; text-align: center;">수</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>천간</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.stems[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.stems[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  <tr>
                    <th>지지 본기</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.branches[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.branches[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  ${
                    meta.hiddenMode === "on"
                      ? `
                  <tr>
                    <th>장간</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.hidden[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.hidden[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                  `
                      : ""
                  }
                  <tr>
                    <th>월령 가중</th>
                    ${["목", "화", "토", "금", "수"]
                      .map((k) => {
                        const v =
                          Math.round((breakdown.season[k] || 0) * 10) / 10;
                        const p =
                          Math.round(
                            ((breakdown.season[k] || 0) / totalSum) * 1000
                          ) / 10;
                        return `<td style="text-align: center; font-size: 11px;">${v}(${p}%)</td>`;
                      })
                      .join("")}
                  </tr>
                </tbody>
              </table>
            `
                : ""
            }
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
              <div class="chip" style="padding: 8px 12px;">
                <strong>강:</strong> ${profile.strong || "—"}
              </div>
              <div class="chip" style="padding: 8px 12px;">
                <strong>중:</strong> ${profile.mid || "—"}
              </div>
              <div class="chip" style="padding: 8px 12px;">
                <strong>약:</strong> ${profile.weak || "—"}
              </div>
            </div>
            ${
              evidenceLine
                ? `<p class="mini" style="padding: 8px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; margin-bottom: 12px;"><strong>근거:</strong> ${escapeHtml(
                    evidenceLine
                  )}</p>`
                : ""
            }
          </div>
        `;

        const detailLines = [
          `강한 ${top}: 집중/추진 쪽으로 쓰면 성과가 빨라져. 특히 ${top} 기운은 현재 전체의 약 ${Math.round(
            (values[topIdx] / totalSum) * 100
          )}% 수준이야.`,
          `약한 ${low}: 루틴/환경 보완으로 충분히 메꿀 수 있어. ${low} 기운은 지금 가장 낮은 구간이라 의식적으로 챙기는 게 좋아.`,
          `성향 요약: ${personality.replace(
            "흥이 떨어지면 동력이 급감할 수 있어.",
            "흥이 떨어지면 동력이 줄 수 있어."
          )}`,
          ...elementAdvice(profile),
          meta.includeHour === false
            ? "시주 미포함: 시간 정보가 없어 시주의 영향은 제외했어."
            : meta.includeHour === "partial"
            ? "시주 일부 미포함: 한쪽은 시간 정보가 없어 시주가 제외됐어."
            : null,
          meta.boundaryText ? meta.boundaryText : null,
          `균형 팁: 상생 흐름으로 ${top} 기운을 살리고, ${low} 기운을 받쳐줄 생활 습관 하나만 고정하면 흐름이 안정돼.`,
        ].filter(Boolean);
        const detailText = detailLines
          .map((l) => escapeHtml(l))
          .filter(Boolean)
          .join("<br/>");

        elementsDetail.innerHTML = anchorInfoHtml
          ? anchorInfoHtml + elementsTableHtml + "<br/>" + detailText
          : elementsTableHtml + "<br/>" + detailText;
      }

      function getElementPersonality(top, low) {
        const topMap = {
          목: "확장형. 아이디어/개척에 강하고, 빠르게 움직여.",
          화: "표현형. 추진/열정이 강하고, 분위기를 주도해.",
          토: "안정형. 조율/관리 중심이며, 신뢰가 자산이야.",
          금: "정밀형. 기준/원칙이 뚜렷하고, 결정이 빠른 편이야.",
          수: "분석형. 정보/흐름을 읽고, 유연하게 대응해.",
        };
        const lowMap = {
          목: "새로운 시도는 쉬는데 마무리가 약해질 수 있어.",
          화: "흥이 떨어지면 동력이 급감할 수 있어.",
          토: "루틴이 흐트러지면 불안정해질 수 있어.",
          금: "결정 기준이 흔들리면 스트레스가 커질 수 있어.",
          수: "과한 정보 탐색으로 결정이 늦어질 수 있어.",
        };
        const topLine = topMap[top] || "기질의 중심이 되는 성향이 또렷해.";
        const lowLine = lowMap[low] || "약한 축을 보완하면 안정감이 올라가.";
        return `${topLine} ${lowLine}`;
      }

      function renderElementsRadar(elements) {
        const svg = elementsRadarSvg;
        const keys = ["목", "화", "토", "금", "수"];
        const values = keys.map((k) => elements[k] || 0);
        const maxVal = Math.max(...values, 1);
        const vals = values.map((v) => clamp01(v / maxVal));
        const cx = 160;
        const cy = 160;
        const R = 110;
        svg.innerHTML = "";

        const ang = (i) => ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const pt = (v, i) => [
          cx + R * v * Math.cos(ang(i)),
          cy + R * v * Math.sin(ang(i)),
        ];
        const polyPoints = (arr, scale = 1) =>
          arr
            .map((v, i) =>
              pt(v * scale, i)
                .map((n) => n.toFixed(2))
                .join(",")
            )
            .join(" ");

        const el = (name, attrs = {}) => {
          const e = document.createElementNS(
            "http://www.w3.org/2000/svg",
            name
          );
          Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
          return e;
        };

        for (let r = 1; r <= 4; r++) {
          svg.appendChild(
            el("polygon", {
              points: polyPoints([r / 4, r / 4, r / 4, r / 4, r / 4]),
              fill: "none",
              stroke: "rgba(15,23,42,0.14)",
              "stroke-width": "1",
            })
          );
        }

        keys.forEach((name, i) => {
          const [x, y] = pt(1, i);
          svg.appendChild(
            el("line", {
              x1: cx,
              y1: cy,
              x2: x,
              y2: y,
              stroke: "rgba(15,23,42,0.22)",
              "stroke-width": "1",
            })
          );
          const [lx, ly] = pt(1.18, i);
          const text = el("text", {
            x: lx,
            y: ly,
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-size": "13",
            "font-weight": "900",
            fill: "#0f172a",
          });
          text.textContent = `${name} ${
            Math.round((elements[name] || 0) * 10) / 10
          }`;
          svg.appendChild(text);
        });

        const poly = el("polygon", {
          points: polyPoints(vals, 0.02),
          fill: "rgba(245,158,11,0.25)",
          stroke: "rgba(217,119,6,0.95)",
          "stroke-width": "2",
          "stroke-linejoin": "round",
        });
        svg.appendChild(poly);

        const dots = vals.map((v, i) => {
          const dot = el("circle", {
            cx: cx,
            cy: cy,
            r: "3.5",
            fill: "rgba(217,119,6,0.95)",
          });
          svg.appendChild(dot);
          return { dot, v, i };
        });

        let p = 0.02;
        function anim() {
          p += 0.05;
          if (p > 1) p = 1;
          poly.setAttribute("points", polyPoints(vals, p));
          dots.forEach(({ dot, v, i }) => {
            const [dx, dy] = pt(v * p, i);
            dot.setAttribute("cx", dx.toFixed(2));
            dot.setAttribute("cy", dy.toFixed(2));
          });
          if (p < 1) requestAnimationFrame(anim);
        }
        requestAnimationFrame(anim);
      }

      function getGenerator(elem) {
        const map = { 화: "목", 토: "화", 금: "토", 수: "금", 목: "수" };
        return map[elem] || "";
      }

      function getOvercomeElem(elem) {
        const entries = Object.entries(OVERCOME);
        const found = entries.find(([, v]) => v === elem);
        return found ? found[0] : "";
      }

      function getYongshinSuggestion(person) {
        const suggestions = [];
        const genWeak = getGenerator(person.weakElem);
        const controlTop = getOvercomeElem(person.topElem);
        if (person.weakScore <= 0.8 && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `약한 ${person.weakElem} 보완`,
          });
        }
        if (person.topScore >= 1.4 && controlTop) {
          suggestions.push({
            elem: controlTop,
            reason: `강한 ${person.topElem} 조절`,
          });
        }
        if (!suggestions.length && genWeak) {
          suggestions.push({
            elem: genWeak,
            reason: `균형 유지`,
          });
        }
        return suggestions;
      }

      function calcStrength(elements, dayElem, seasonElem) {
        if (!dayElem) return "중간";
        const total = Object.values(elements).reduce((a, b) => a + b, 0);
        const avg = total / 5;
        let score = elements[dayElem] || 0;
        if (seasonElem === dayElem) score += 0.6;
        if (GENERATE[seasonElem] === dayElem) score += 0.3;
        if (OVERCOME[seasonElem] === dayElem) score -= 0.3;
        if (score >= avg + 0.2) return "신강";
        if (score <= avg - 0.2) return "신약";
        return "중간";
      }

      function listInternalPairs(branches, table) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (hasPair(branches[i], branches[j], table)) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function listInternalHyeong(branches) {
        const out = [];
        for (let i = 0; i < branches.length; i++) {
          for (let j = i + 1; j < branches.length; j++) {
            if (
              HYEONG.some(
                ([a, b]) =>
                  (branches[i] === a && branches[j] === b) ||
                  (branches[i] === b && branches[j] === a)
              )
            ) {
              out.push(`${branches[i]}-${branches[j]}`);
            }
          }
        }
        return out;
      }

      function renderDeepAnalysisCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderDeepBlock("A", a));
        if (b) blocks.push(renderDeepBlock("B", b));
        deepAnalysis.innerHTML = blocks.join("");
      }

      function renderDeepBlock(label, person) {
        const yongshin = getYongshinSuggestion(person);
        const yongText = yongshin.length
          ? yongshin.map((y) => `${y.elem}(${y.reason})`).join(", ")
          : "—";
        const season =
          person.monthBranch && person.seasonTopElem
            ? `${person.monthBranch}(${person.seasonTopElem})`
            : "—";
        const seasonLine =
          person.seasonTopElem && person.topElem === person.seasonTopElem
            ? "월령과 강점이 같아서 자연스럽게 힘이 실리는 흐름이야."
            : "월령과 강점이 달라서 조율과 보완이 중요해.";
        const currentLine = formatElemLine("현재 오행:", person.elements);
        const dayStemLine = person.dayStem
          ? `일간: ${person.dayStem}(${person.dayElem}) · ${person.strength}`
          : "일간: —";
        const branches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const hap = listInternalPairs(branches, LIUHE);
        const chung = listInternalPairs(branches, CHUNG);
        const hyeong = listInternalHyeong(branches);
        const relationLine = `합: ${hap.length ? hap.join(", ") : "—"} · 충: ${
          chung.length ? chung.join(", ") : "—"
        } · 형: ${hyeong.length ? hyeong.join(", ") : "—"}`;
        const relationExplain = `합은 서로 돕는 결이라 호흡이 부드럽고, 충은 부딪힘이 생겨 타이밍 조절이 필요해. 형은 마찰이나 긴장이 생기기 쉬운 결이야. ${
          hyeong.length
            ? `현재 형: ${hyeong.join(
                ", "
              )}이니까 말투/속도를 줄이면 충돌이 줄어들어.`
            : "형이 적어서 큰 마찰은 덜해."
        }`;
        return `
          <div class="rule-card">
            <div class="mini">${escapeHtml(dayStemLine)}</div>
            <div class="mini">용신: ${escapeHtml(yongText)}</div>
            <div class="mini">격국: 월지 ${escapeHtml(
              season
            )} 중심. ${escapeHtml(seasonLine)}</div>
            <div class="mini">${escapeHtml(currentLine)}</div>
            <div class="mini">${escapeHtml(relationLine)}</div>
            <div class="mini">${escapeHtml(relationExplain)}</div>
          </div>
        `;
      }

      function getHourRangeText(branch) {
        const map = {
          자: "00:00~01:30",
          축: "01:31~03:30",
          인: "03:31~05:30",
          묘: "05:31~07:30",
          진: "07:31~09:30",
          사: "09:31~11:30",
          오: "11:31~13:30",
          미: "13:31~15:30",
          신: "15:31~17:30",
          유: "17:31~19:30",
          술: "19:31~21:30",
          해: "21:31~23:30",
        };
        return map[branch] || "—";
      }

      function makeYearNarrative(person, targetYear) {
        const pillar = ganzhiYear(targetYear);
        const yearElem = STEM_ELEM[pillar.stem];
        const yearTenGod = person.dayStem
          ? tenGod(person.dayStem, pillar.stem)
          : "";
        const mode = yearModeText(
          pickYearMode(
            relationElem(yearElem, person.topElem),
            relationElem(yearElem, person.weakElem)
          )
        );
        const relYearTop = relationElem(yearElem, person.topElem);
        const relYearWeak = relationElem(yearElem, person.weakElem);

        // 총론 생성
        let totalParts = [];
        if (relYearTop === "생" || relYearTop === "동") {
          totalParts.push(
            "위기 가운데 기회가 있으니 어려움 중에 얻음이 큰 해입니다."
          );
          totalParts.push(
            "경험을 통해 얻은 것이니 결과가 단단하며 보기에 좋습니다."
          );
        } else if (relYearTop === "극" || relYearTop === "눌림") {
          totalParts.push(
            "신중이 곧 복인 해입니다. 서두르면 손해를 보니 확인을 거듭해야 합니다."
          );
          totalParts.push(
            "지키는 자에게 복이 머물러 안정을 추구하면 길합니다."
          );
        } else {
          totalParts.push("기본을 지키면 안정이 따르는 해입니다.");
          totalParts.push(
            "작은 성실이 큰 복으로 돌아오니 꾸준함이 요체입니다."
          );
        }

        if (yearTenGod === "정관" || yearTenGod === "편관") {
          totalParts.push(
            "능력을 얻었으니 나를 바라보는 시선이 많아지는 해입니다."
          );
          totalParts.push("인기가 많으니 명예는 저절로 얻게 됩니다.");
        } else if (yearTenGod === "정재" || yearTenGod === "편재") {
          totalParts.push(
            "큰 재물은 아니어도 소소함이 있을 것이니 끊이지 않게 하여 근심을 막을 것입니다."
          );
          totalParts.push(
            "필요한 정도는 얻을 것이니 욕심으로 화를 조장하면 안 됩니다."
          );
        } else if (yearTenGod === "정인" || yearTenGod === "편인") {
          totalParts.push("복은 인연과 겸손을 통해 찾아옵니다.");
          totalParts.push(
            "나의 것이 아닌 것을 바라면 되려 흉사가 될 것이니 반드시 노력을 통해 얻어야 함을 명심하기 바랍니다."
          );
        }

        totalParts.push(
          "지위와 명예는 실리를 동반해야 하며 재물은 노력이 수반되어야 합니다."
        );
        totalParts.push(
          "투자를 통해서 얻는 재물은 없을 것이니 공연히 낭패 보는 일이 없도록 하시고 책임만 주어진 감투는 각별히 사양하시기 바랍니다."
        );
        totalParts.push(
          "기회에 저해요소가 될 것이니 명예를 얻고도 일은 허사가 될 수 있습니다."
        );
        totalParts.push(
          "길성이 문 앞을 비출 것이니 취하는 자의 노력에 따라 얻음이 달라집니다."
        );
        totalParts.push(
          "노력하면 이상을 얻게 되는 해이나 앉아서 들어오는 재물은 없습니다."
        );
        totalParts.push(
          "노력 없이 재물을 탐하면 실이 될 것이니 명심해야 합니다."
        );
        totalParts.push(
          "도움 주는 인연이 나타날 것이니 작은 인연도 소중히 해야 합니다."
        );
        totalParts.push(
          "근심은 작고 기쁨은 큰 해이니 무모함으로 좋은 복을 날리는 일이 없도록 하세요."
        );
        totalParts.push("일이 생기면 피하지 말아야 합니다.");

        const total = casualizeText(totalParts.join(" "));

        // 재물운 생성
        let moneyParts = [];
        if (relYearWeak === "생" || relYearWeak === "동") {
          moneyParts.push(
            "일을 진행하고 재물을 얻으려면 한번은 크게 모험을 하게 되는 시기입니다."
          );
          moneyParts.push(
            "마음속에 고민과 갈등이 많아지게 되며 중요한 결정을 내리게 되는 시기이군요."
          );
          moneyParts.push(
            "다행히 길성이 비추고 월덕과 천을이 함께하게 되니 좋은 결과가 기대할 수 있겠습니다."
          );
        } else {
          moneyParts.push("재물은 꾸준함에서 나옵니다.");
          moneyParts.push(
            "급하게 큰돈을 탐하면 손실로 돌아올 수 있으니 신중해야 합니다."
          );
        }
        moneyParts.push(
          "횡재나 행운으로 얻어지는 재물은 많지 않고 일이 잘 풀리고 성장하여 좋은 성과를 올리게 될 때 얻게 되는 재물이 많을 것입니다."
        );
        moneyParts.push(
          "본업으로 얻는 수익보다 본업 이외의 분야에서 들어오는 수익이 더 클 것이니 다소 균형이 맞지 않아서 선택의 기로에서 갈등이 있겠지만 재물이 쌓여가는 즐거움과 행복함이 크게 느껴질 것입니다."
        );
        moneyParts.push(
          "나를 위해 도움을 주는 의인이 있어 나의 손실을 막아주고 생활의 변화가 있으면서 절약하는 생활을 하게 될 것입니다."
        );
        moneyParts.push(
          "그래도 지출이 상당히 많은 성향이 있으므로 재물이 나가는 것을 잘 관리한다면 결국 들어오는 재물이 나가는 재물보다 많아지게 되어 재물을 축적할 수가 있을 것입니다."
        );
        const money = casualizeText(moneyParts.join(" "));

        // 직장/사업운 생성
        let workParts = [];
        if (relYearTop === "생" || relYearTop === "동") {
          workParts.push(
            "큰 일을 성사시켜 자신의 관록과 명성이 크게 높아지는 시기입니다."
          );
          workParts.push(
            "직장에서는 지위를 크게 얻거나 큰 포상을 받을 뿐만 아니라 소속된 곳에 공여하는 바가 크고 자신이 느끼는 행복감도 커질 것입니다."
          );
        } else {
          workParts.push("안정을 추구하는 시기입니다.");
          workParts.push(
            "무리한 확장보다는 기존의 것을 다듬는 것이 유리합니다."
          );
        }
        workParts.push(
          "자신의 능력이 점차 알려지게 되면서 다른 곳으로부터 좋은 제의를 받거나 나를 부를 것이니 나의 진가와 능력이 크게 돋보이는 시기입니다."
        );
        workParts.push(
          "바깥으로 활동하는 사람은 잠시의 여유도 없을 정도로 일이 끊이지 않을 것입니다."
        );
        workParts.push(
          "장사를 하면 대길의 운수가 크게 일어날 것이지만 굳이 새로운 장사를 시작할 필요는 없습니다."
        );
        workParts.push(
          "장사보다는 무슨 일을 하든지 운의 중심이 나에게 있으므로 내가 주도적으로 할 수 있고 자신의 머리와 손을 거쳐서 하는 일을 하시기 바랍니다."
        );
        workParts.push(
          "사업적으로는 기반이 탄탄해질 것이며, 거래처가 크게 늘어날 것입니다."
        );
        workParts.push(
          "확장의 준비를 해야 하지만 무리하지 말고 치밀하게 계획하고 천천히 여유를 갖고 진행하시기 바랍니다."
        );
        const work = casualizeText(workParts.join(" "));

        // 가정/건강운 생성
        let familyParts = [];
        familyParts.push(
          "가족 중에서 근심이 많은 사람이 있으니 마음으로 위로를 해야 할 일이 생기겠습니다."
        );
        familyParts.push("가족 간의 갈등이 예상되는 시기입니다.");
        familyParts.push(
          "하늘이 나에게 내린 좋은 운의 기운이 찾아오기 전의 사소한 갈등으로 발생할 것이니 상대의 입장을 먼저 이해해 주고 큰 다툼이 되지 않도록 주의하시기 바랍니다."
        );
        familyParts.push(
          "가족끼리 다투게 되면 천금을 얻는다 하여도 아무런 소용이 없습니다."
        );
        familyParts.push(
          "봄을 지나면 모두가 해결이 될 것이니 그때부터는 화목과 평안이 클 것입니다."
        );
        familyParts.push(
          "소원성취의 운이 크게 일어나니 믿으면 믿은 만큼 보답할 것입니다."
        );
        familyParts.push(
          "위아래가 이제부터 모두 제 역할을 할 것이니 서로가 공손해져 화목이 더해집니다."
        );
        familyParts.push(
          "웃음이 끊이지 않을 것이니 큰 경사가 생길 징조도 보이는군요."
        );
        familyParts.push("웃어른의 건강에 문제가 생깁니다.");
        familyParts.push(
          "병원에 오래 계시지 않도록 각별히 신경 쓰시고 증세가 오면 반드시 병원을 찾아 병을 키우는 일이 없도록 하시기 바랍니다."
        );
        const family = casualizeText(familyParts.join(" "));

        // 이성/대인관계 생성
        let relationParts = [];
        relationParts.push(
          "아주 좋은 대길의 인연과 매우 좋지 않은 인연이 동시에 찾아오는 시기입니다."
        );
        relationParts.push(
          "사람과의 인연에 대해서 생각을 많이 하게 될 것입니다."
        );
        relationParts.push(
          "그러나, 좋은 운으로 이끄는 하늘의 기운이 나를 더욱 강하게 보호하고 있으니 머지않아 사람의 인연이 복을 가져오기 시작할 것입니다."
        );
        relationParts.push(
          "일과 관련된 만남이나 이성적인 만남에서 사람을 구분하고 선택하는데 다소 어려움과 고민이 있겠지만 크게 신경을 쓰지 않아도 되겠습니다."
        );
        relationParts.push(
          "재물과 관련된 제의를 하거나 자신의 금전적인 이익을 목적으로 하면서 접근하는 만남은 큰 화를 당하게 될 수 있는 좋지 않은 인연으로 생각하시면 되며, 일과 상관없이 일상적인 만남 중에서 이루어지는 만남은 좋은 인연을 만날 수 있는 징조입니다."
        );
        relationParts.push(
          "일 이외의 일상적인 만남이나 이성적인 만남은 좋은 운을 만드는 시발점이기 때문에 만남을 통해서 도움을 주어야 할 사람은 도움을 베풀어 주어야 합니다."
        );
        relationParts.push(
          "내가 도움을 주는 사람은 좋은 인연으로 남을 것이고 나중에 반드시 보은을 입게 될 것입니다."
        );
        relationParts.push(
          "다만, 이 시기에 만나는 사람들 중에 자신에게 좋은 말만 하거나 달콤한 제의를 하면서 다가오는 사람은 반드시 경계하고 주의가 필요한 사람이 될 것입니다."
        );
        relationParts.push(
          "이성과의 애정이 타오를 수 있는 시기이니 이성을 새롭게 만나면 짧은 시간 안에 정을 느끼고 사랑의 감정이 싹틀 것입니다."
        );
        relationParts.push(
          "애정이 깊어지고 사랑이 두터워져서 서로가 정신적으로 위로를 해주고 의지하게 될 것입니다."
        );
        relationParts.push(
          "청춘 남녀는 올해에 좋은 인연을 만나게 될 수 있고 애정관계로 발전하지 않더라도 좋은 친구나 좋은 인간관계로 지속될 수가 있을 것입니다."
        );
        const relation = casualizeText(relationParts.join(" "));

        return { total, money, work, family, relation };
      }

      function makeReportKeywords(person) {
        const out = [];
        if (person.topElem) out.push(`강점 ${person.topElem}`);
        if (person.weakElem) out.push(`보완 ${person.weakElem}`);
        if (person.dayStem) out.push(`일간 ${person.dayStem}`);
        if (person.strength) out.push(`강약 ${person.strength}`);
        if (person.seasonTopElem) out.push(`월령 ${person.seasonTopElem}`);
        return out.length ? out.join(" · ") : "—";
      }

      function makeActionTips(person) {
        return {
          total: `핵심 행동: ${person.topElem} 기운 중심으로 한 가지 목표만 잡고 끝까지 밀어.`,
          money: `지출 관리: ${person.weakElem} 보완 루틴 하나만 고정하면 새는 돈이 줄어.`,
          work: `업무 전략: ${person.topElem} 강점을 살릴 수 있는 역할을 먼저 맡아.`,
          family: `건강 루틴: 수면/식사 중 하나만 고정해도 체력과 마음이 안정돼.`,
          relation: `관계 팁: 선을 분명히 하고 약속 지키면 오해가 줄어.`,
        };
      }

      const ELEM_MEANING = {
        목: "성장/기획",
        화: "추진/표현",
        토: "안정/관리",
        금: "결과/보상",
        수: "정보/환경",
      };
      function elemMeaning(elem) {
        return ELEM_MEANING[elem] || "기운";
      }
      function hasFinalConsonant(word) {
        if (!word) return false;
        const last = word[word.length - 1];
        const code = last.charCodeAt(0);
        if (code < 0xac00 || code > 0xd7a3) return false;
        return (code - 0xac00) % 28 !== 0;
      }
      function topicParticle(word) {
        return hasFinalConsonant(word) ? "은" : "는";
      }
      function subjectParticle(word) {
        return hasFinalConsonant(word) ? "이" : "가";
      }
      function objectParticle(word) {
        return hasFinalConsonant(word) ? "을" : "를";
      }
      function scaleElements(elements, targetTotal = 150) {
        const keys = ["목", "화", "토", "금", "수"];
        const sum = keys.reduce((acc, k) => acc + (elements[k] || 0), 0);
        if (!sum) {
          return {
            scaled: { 목: 0, 화: 0, 토: 0, 금: 0, 수: 0 },
            total: targetTotal,
            sum: 0,
          };
        }
        const scale = targetTotal / sum;
        const scaled = {};
        let scaledSum = 0;
        keys.forEach((k) => {
          const v = Math.round((elements[k] || 0) * scale);
          scaled[k] = v;
          scaledSum += v;
        });
        const diff = targetTotal - scaledSum;
        if (diff !== 0) {
          const topKey = keys.sort(
            (a, b) => (elements[b] || 0) - (elements[a] || 0)
          )[0];
          scaled[topKey] = Math.max(0, (scaled[topKey] || 0) + diff);
        }
        return { scaled, total: targetTotal, sum };
      }
      function formatScaledElements(scaled) {
        const order = ["목", "화", "토", "금", "수"];
        return order.map((k) => `${k} ${scaled[k] ?? 0}`).join(" · ");
      }
      function elementPercent(elements, elem) {
        const total = Object.values(elements).reduce((a, b) => a + b, 0) || 1;
        return Math.round(((elements[elem] || 0) / total) * 100);
      }
      function getTenGodStats(person) {
        const stems = [
          person.yearStem,
          person.monthStem,
          person.dayStem,
          person.hourStem,
        ].filter(Boolean);
        const counts = {};
        stems.forEach((stem) => {
          const tg = tenGod(person.dayStem, stem);
          if (!tg) return;
          counts[tg] = (counts[tg] || 0) + 1;
        });
        const gwanCount = (counts["정관"] || 0) + (counts["편관"] || 0);
        const jaeCount = (counts["정재"] || 0) + (counts["편재"] || 0);
        const hasSikshin = (counts["식신"] || 0) > 0;
        const hasJeongGwan = (counts["정관"] || 0) > 0;
        const hasPyeonGwan = (counts["편관"] || 0) > 0;
        return {
          counts,
          gwanCount,
          jaeCount,
          hasSikshin,
          gwanMix: hasJeongGwan && hasPyeonGwan,
        };
      }
      function yearModeFor(person, year) {
        const pillar = ganzhiYear(year);
        const yearElem = STEM_ELEM[pillar.stem];
        const mode = pickYearMode(
          relationElem(yearElem, person.topElem),
          relationElem(yearElem, person.weakElem)
        );
        const yearTenGod = person.dayStem
          ? tenGod(person.dayStem, pillar.stem)
          : "";
        return { year, pillar, yearElem, mode, yearTenGod };
      }
      function yearStrategy(mode) {
        if (mode === "push") return { todo: "확장/추진", avoid: "우유부단" };
        if (mode === "pushPlus")
          return { todo: "확장+회복 동시", avoid: "무리한 확장" };
        if (mode === "recover")
          return { todo: "정리/회복", avoid: "새 판 벌리기" };
        if (mode === "brake") return { todo: "속도 조절", avoid: "과속/모험" };
        return { todo: "기본 유지", avoid: "급변" };
      }
      function renderStructuredReport(person, result) {
        const scaled = scaleElements(person.elements, 150);
        const profile = makeElementProfile(person.elements);
        const tenStats = getTenGodStats(person);
        const gwanSummary =
          tenStats.gwanCount >= 2
            ? "관(정관/편관) 다수"
            : tenStats.gwanCount === 1
            ? "관 존재"
            : "관 약함";
        const jaeSummary = tenStats.jaeCount <= 1 ? "재성 약함" : "재성 보통";
        const gwanSalSummary = tenStats.gwanMix ? "관살혼잡" : "관살 단정";
        const sikSummary = tenStats.hasSikshin ? "식신 존재" : "식신 약함";
        const waterPct = elementPercent(person.elements, "수");
        const genderLabel = person.gender === "female" ? "여자" : "남자";

        const branches = [
          person.yearBranch,
          person.monthBranch,
          person.dayBranch,
          person.hourBranch,
        ].filter(Boolean);
        const hap = listInternalPairs(branches, LIUHE);
        const chung = listInternalPairs(branches, CHUNG);
        const hyeong = listInternalHyeong(branches);
        const relationLine = `합 ${hap.length ? hap.join(", ") : "—"} · 충 ${
          chung.length ? chung.join(", ") : "—"
        } · 형 ${hyeong.length ? hyeong.join(", ") : "—"}`;

        const topMeaning = elemMeaning(person.topElem);
        const coreDef = `이 사주는 ${person.topElem} 기운이 두드러지고 ${
          person.weakElem
        } 기운이 약한 구조로, ${topMeaning}${topicParticle(
          topMeaning
        )} 강점이지만 ${elemMeaning(
          person.weakElem
        )}에서 반복 갈등이 생기는 형이다.`;
        const coreEvidence = `근거: 오행 분포 ${formatScaledElements(
          scaled.scaled
        )} (총점 ${scaled.total} 기준). 강/중/약 ${profile.strong} / ${
          profile.mid
        } / ${profile.weak}.`;
        const coreDerived = `파생: ${person.topElem} 기운 쪽으로 몰려 반응은 빠르지만, ${person.weakElem} 기운의 약점이 드러나는 순간 판단이 흔들린다.`;

        const weakMeaning = elemMeaning(person.weakElem);
        const conflictOne = `${person.topElem} 기운이 강해서 ${elemMeaning(
          person.topElem
        )}에 의존하려는 습관이 커진다. 그런데 ${
          person.weakElem
        } 기운이 약해서 ${weakMeaning}${subjectParticle(
          weakMeaning
        )} 흔들릴 때 선택이 뒤집힌다.`;
        const conflictTwo = tenStats.gwanMix
          ? "관이 혼잡하니까 규칙을 지키려는 마음과 벗어나려는 마음이 동시에 올라와 결정이 갈라진다."
          : tenStats.gwanCount >= 2
          ? "관이 많아서 책임을 떠안는 방향으로 굳어지는데, 신강이면 통제 집착이 생겨 갈등이 반복된다."
          : "관이 약한 편이면 기준이 쉽게 흔들려 관계/직업 선택이 들쭉날쭉해진다.";

        const moneyRisk = `재물: ${
          person.weakElem === "금" || tenStats.jaeCount <= 1
            ? "보상 체감이 약해서 돈이 새기 쉽다."
            : "수입은 들어오는데 관리가 느슨해지기 쉽다."
        } 근거: ${jaeSummary} · ${
          person.weakElem
        } 기운 약. 행동: 월 기준 수치화 + 고정 정산 루틴을 만들어.`;
        const workRisk = `직업: ${
          tenStats.gwanCount >= 2
            ? "책임이 과도하게 몰리고 역할이 확장된다."
            : "역할 경계가 흐려져 잡무로 소모된다."
        } 근거: ${gwanSummary}. 행동: 역할 범위를 문서로 고정하고, 아닌 일은 거절해.`;
        const relationRisk = `관계: ${
          hyeong.length || chung.length
            ? "마찰 포인트가 반복돼 감정이 쉽게 상한다."
            : "큰 충돌은 적지만 작은 불씨가 쌓인다."
        } 근거: ${relationLine}. 행동: 감정은 24시간 뒤에 정리해서 말해.`;

        const strongElem =
          profile.strong !== "—" ? profile.strong : person.topElem;
        const midElem = profile.mid !== "—" ? profile.mid : person.topElem;
        const strengthUse = `강한 오행(${strongElem})은 ${strongElem
          .split(" · ")
          .map((e) => elemMeaning(e))
          .join(
            "·"
          )}에 쓰면 효율이 높다. 중간 오행(${midElem})은 실행 속도와 유지력을 보조하는 쪽으로 붙여.`;
        const workStyle = `일 처리 방식은 "정보를 모으고 -> 기준을 자르고 -> 한 번에 밀어붙이기"가 맞다. 커리어는 반복성과 구조가 있는 기획/운영/관리 쪽이 유리하다.`;

        const romanceReason = `연애가 어려운 이유는 ${jaeSummary}과 ${person.topElem} 기운 과다로 확신이 늦게 붙고, 반응이 과해지기 때문이다.`;
        const matchCondition = `잘 맞는 상대는 감정 기복이 적고 생활 리듬이 일정하며, 말보다 약속을 지키는 사람이다.`;

        const jobDirection = `안정적인 직장이 유리한 이유는 ${gwanSummary} 구조가 규칙 안에서 성과를 내는 방식이기 때문이다.`;
        const moneyDirection = `투자/모험이 불리한 이유는 ${
          person.weakElem === "금" || tenStats.jaeCount <= 1
            ? "결과 체감이 약해 손익 판단이 늦어지기 때문"
            : "리스크 관리가 느슨해지기 때문"
        }이다. 재물은 속도가 아니라 구조로 늘린다: 지출 기준, 수입 분배, 정산 주기를 고정해.`;

        const tzOffsetMinutes = person.tzOffsetMinutes ?? 540;
        const dstMode = person.dstMode || "off";
        const flows = buildYearFlows(person, tzOffsetMinutes, dstMode);
        const decades = summarizeDecades(flows).slice(0, 2);
        const decadeLines = decades.map((d) => {
          const strategy = yearStrategy(d.mode);
          return `${d.range}: ${yearModeText(d.mode)}. 해야 할 것: ${
            strategy.todo
          }. 피해야 할 것: ${strategy.avoid}.`;
        });
        const y2026 = yearModeFor(person, 2026);
        const y2026Strategy = yearStrategy(y2026.mode);
        const yearLine2026 = `2026년: ${yearModeText(
          y2026.mode
        )}. 해야 할 것: ${y2026Strategy.todo}. 피해야 할 것: ${
          y2026Strategy.avoid
        }.`;

        const finalAttitudes = [
          "판단 기준은 감정이 아니라 룰로 고정해.",
          "속도보다 루틴을 고정해.",
          "관계는 약속 지키고 선을 분명히 하면 유지돼.",
        ];

        return `
          <div class="rule-card">
            <div class="section-title">본질 리포트</div>
            <div class="mini">기본 정보: ${genderLabel} · 일간 ${
          person.dayStem || "—"
        }(${person.dayElem || "—"}) · 강약 ${
          person.strength || "—"
        } · ${relationLine}</div>
            <br>
            <div class="report-section">
              <h3>1️⃣ 사주 구조 핵심 요약</h3>
              <p class="mini">${escapeHtml(softenText(coreDef))}</p>
              <p class="mini">${escapeHtml(softenText(coreEvidence))}</p>
              <p class="mini">${escapeHtml(softenText(coreDerived))}</p>
              <p class="mini">정리된 구조를 알면 방향이 더 선명해져.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>2️⃣ 이 사주의 평생 핵심 과제</h3>
              <p class="mini">1) ${escapeHtml(softenText(conflictOne))}</p>
              <p class="mini">2) ${escapeHtml(softenText(conflictTwo))}</p>
              <p class="mini">과제를 알면 선택이 더 부드러워져.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>3️⃣ 꼭 챙겨야 할 포인트 3가지</h3>
              <p class="mini">${escapeHtml(softenText(moneyRisk))}</p>
              <p class="mini">${escapeHtml(softenText(workRisk))}</p>
              <p class="mini">${escapeHtml(softenText(relationRisk))}</p>
              <p class="mini">지킬 포인트를 잡으면 운이 더 안정돼.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>4️⃣ 강점 활용 전략 (현실 적용)</h3>
              <p class="mini">${escapeHtml(softenText(strengthUse))}</p>
              <p class="mini">${escapeHtml(softenText(workStyle))}</p>
              <p class="mini">${escapeHtml(
                softenText(
                  `수 기운 비중: ${waterPct}% · 이 비중은 환경/상황 영향이 큰 편이라 기준을 먼저 잡아야 흔들림이 줄어.`
                )
              )}</p>
              <p class="mini">강점을 살리면 성과가 자연스럽게 따라와.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>5️⃣ 관계 해석 (중요)</h3>
              <p class="mini">${escapeHtml(softenText(romanceReason))}</p>
              <p class="mini">${escapeHtml(softenText(matchCondition))}</p>
              <p class="mini">관계는 천천히 다져도 충분히 좋아져.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>6️⃣ 직업·재물 방향</h3>
              <p class="mini">${escapeHtml(softenText(jobDirection))}</p>
              <p class="mini">${escapeHtml(softenText(moneyDirection))}</p>
              <p class="mini">좋은 방향을 고르면 흐름이 더 편안해져.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>7️⃣ 대운·세운 해석 (전략 중심)</h3>
              <p class="mini">${escapeHtml(
                softenText(decadeLines.join(" "))
              )}</p>
              <p class="mini">${escapeHtml(softenText(yearLine2026))}</p>
              <p class="mini">흐름을 읽으면 기회가 더 잘 보여.</p>
            </div>
            <br>
            <div class="report-section">
              <h3>8️⃣ 최종 총평 (현실적인 조언)</h3>
              <p class="mini">${escapeHtml(
                softenText(finalAttitudes.join(" "))
              )}</p>
              <p class="mini">차분히 걸어가도 좋은 결과가 쌓여.</p>
            </div>
          </div>
        `;
      }

      const ELEM_CLASS = {
        목: "wood",
        화: "fire",
        토: "earth",
        금: "metal",
        수: "water",
      };
      function elemClass(elem) {
        return ELEM_CLASS[elem] ? `e-${ELEM_CLASS[elem]}` : "";
      }
      function tenGodChip(label, text, elem) {
        const cls = elemClass(elem);
        return `<span class="chip ${cls}"><b>${escapeHtml(
          label
        )}</b> ${escapeHtml(text)}</span>`;
      }

      function renderReportCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderReportBlock(a, state.aResult));
        if (b) blocks.push(renderReportBlock(b, state.bResult));
        reportContent.innerHTML = blocks.join("");

        // 월별 세운 카드의 공유 버튼 이벤트 리스너 추가
        setTimeout(() => {
          reportContent.querySelectorAll("[data-month]").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const monthIndex = parseInt(btn.getAttribute("data-month-index"));
              const person = a || b;
              if (person) {
                const monthData = makeMonthlyLuck(person)[monthIndex];
                await shareMonthlyCard(monthData);
              }
            });
          });
        }, 100);
      }

      function renderReportBlock(person, result) {
        if (!result) return "";
        return renderStructuredReport(person, result);
      }

      function getLocalNowYear(tzOffsetMinutes, dstMode) {
        const parts = toLocalDateParts(new Date(), tzOffsetMinutes, dstMode);
        return parts.y;
      }

      function pickYearMode(relTop, relWeak) {
        let mode = "steady";
        if (relTop === "생" || relTop === "동") mode = "push";
        if (relWeak === "생" || relWeak === "동")
          mode = mode === "push" ? "pushPlus" : "recover";
        if (relTop === "극" || relTop === "눌림") mode = "brake";
        return mode;
      }

      function yearModeText(mode) {
        const map = {
          push: "확장/추진에 유리",
          pushPlus: "성과+회복 동시",
          recover: "정리/회복에 유리",
          brake: "속도 조절 추천",
          steady: "기본 유지",
        };
        return map[mode] || "기본 유지";
      }

      function monthModeText(mode) {
        const map = {
          push: "추진",
          pushPlus: "추진+회복",
          recover: "회복",
          brake: "조절",
          steady: "유지",
        };
        return map[mode] || "유지";
      }

      function formatMonthTags(tags) {
        if (!tags || !Array.isArray(tags) || tags.length < 3) return "";
        const [luckTag, mode, seasonElem] = tags;
        const luckText =
          luckTag === "길" ? "길운" : luckTag === "흉" ? "흉운" : "중운";
        const modeText = monthModeText(mode);
        const elemText = `${seasonElem} 기운`;

        // 색상 클래스 결정
        const luckClass =
          luckTag === "길"
            ? "chip e-wood"
            : luckTag === "흉"
            ? "chip e-fire"
            : "chip";
        const elemClassKey =
          ELEM_CLASS && ELEM_CLASS[seasonElem] ? ELEM_CLASS[seasonElem] : "";
        const elemClass = elemClassKey ? `chip e-${elemClassKey}` : "chip";

        return `
          <span class="${luckClass}" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${luckText}</span>
          <span class="chip" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${modeText}</span>
          <span class="${elemClass}" style="font-size: 11px; padding: 4px 10px; white-space: nowrap;">${elemText}</span>
        `;
      }

      function buildYearFlows(person, tzOffsetMinutes, dstMode) {
        const startYear = getLocalNowYear(tzOffsetMinutes, dstMode);
        const flows = [];
        for (let i = 0; i < 10; i++) {
          const year = startYear + i;
          const pillar = ganzhiYear(year);
          const yearElem = STEM_ELEM[pillar.stem];
          const relTop = relationElem(yearElem, person.topElem);
          const relWeak = relationElem(yearElem, person.weakElem);
          const mode = pickYearMode(relTop, relWeak);
          const yearTenGod = person.dayStem
            ? tenGod(person.dayStem, pillar.stem)
            : "";
          flows.push({
            year,
            pillar,
            yearElem,
            mode,
            yearTenGod,
          });
        }
        return flows;
      }

      function summarizeDecades(flows) {
        const buckets = {};
        flows.forEach((f) => {
          const start = f.year - (f.year % 10);
          if (!buckets[start]) buckets[start] = [];
          buckets[start].push(f);
        });
        return Object.entries(buckets).map(([start, list]) => {
          const counts = list.reduce((acc, cur) => {
            acc[cur.mode] = (acc[cur.mode] || 0) + 1;
            return acc;
          }, {});
          const topMode = Object.entries(counts).sort(
            (a, b) => b[1] - a[1]
          )[0][0];
          return {
            range: `${start}~${Number(start) + 9}`,
            mode: topMode,
          };
        });
      }

      function renderLuckFlowCard(a, b) {
        const blocks = [];
        if (a) blocks.push(renderLuckBlock(a));
        if (b) blocks.push(renderLuckBlock(b));
        luckFlow.innerHTML = blocks.join("");
      }

      function renderLuckBlock(person) {
        const tzOffsetMinutes = person.tzOffsetMinutes ?? 540;
        const dstMode = person.dstMode || "off";
        const flows = buildYearFlows(person, tzOffsetMinutes, dstMode);
        const decades = summarizeDecades(flows);
        const decadeSummary = decades
          .map((d) => `${d.range}: ${yearModeText(d.mode)}`)
          .join(" · ");
        const daewoonNarrative = `대운은 10년 단위로 흐르는 큰 물줄기야. ${
          decadeSummary || "—"
        }의 결이 이어지니까, 이 시기에는 방향을 크게 잡고 흔들림을 줄여야 해. 큰 결정은 대운 흐름에 맞춰야 길이 열려.`;
        const yearLines = flows
          .map(
            (f) =>
              `${f.year}년 ${f.pillar.text}(${f.yearElem}) · ${yearModeText(
                f.mode
              )}`
          )
          .join("<br/>");
        const sewoonNarrative =
          "세운은 해마다 결이 달라지는 흐름이야. 강한 해에는 확장과 실행을, 약한 해에는 정리와 회복을 택해야 실이 적어. 해마다 기운이 바뀌니까 같은 방법을 고집하지 말고 흐름에 맞춰 조율하는 게 좋아.";

        return `
          <div class="rule-card">
            <div class="mini">대운(10년): ${escapeHtml(daewoonNarrative)}</div>
            <div class="mini">세운(10년): ${yearLines}</div>
            <div class="mini">${escapeHtml(sewoonNarrative)}</div>
          </div>
        `;
      }

      function setResultVisibility(mode) {
        if (mode === "today") {
          // 오늘 운세 모드: 오늘 운세 카드만 표시
          resultElementsCard.classList.add("hidden");
          resultDeepCard.classList.add("hidden");
          resultLuckCard.classList.add("hidden");
          resultTodayCard.classList.remove("hidden");
          resultRadarCard.classList.add("hidden");
          resultABCard.classList.add("hidden");
          resultRulesCard.classList.add("hidden");
          resultMonthlyCard.classList.add("hidden");
          resultReportCard.classList.add("hidden");
          resultSummaryCard.classList.add("hidden");
        } else {
          resultElementsCard.classList.toggle("hidden", !state.A);
          resultDeepCard.classList.toggle("hidden", !state.A);
          resultLuckCard.classList.toggle("hidden", !state.A);
          resultTodayCard.classList.toggle("hidden", mode === "newyear");
          resultRadarCard.classList.toggle("hidden", mode !== "compat");
          resultABCard.classList.toggle("hidden", mode !== "compat");
          resultRulesCard.classList.toggle("hidden", mode !== "compat");
          resultMonthlyCard.classList.toggle("hidden", mode !== "newyear");
          resultReportCard.classList.toggle("hidden", mode === "today");
          resultSummaryCard.classList.toggle("hidden", mode === "today");
        }
      }

      function renderCompat() {
        const a = buildPerson(state.A);
        const b = buildPerson(state.B);
        const firedRules = evaluateRules(a, b);
        const sectionScores = calcSectionScores(firedRules);
        const totalScore = calcTotalFromSections(sectionScores);
        const coupleElements = combineElements(a.elements, b.elements);
        const coupleBreakdown = combineBreakdown(
          state.aResult?.elements?.breakdown,
          state.bResult?.elements?.breakdown
        );
        const coupleStats = getTopWeak(coupleElements);

        resultTitle.textContent = "궁합 요약";
        const includeHourMode =
          state.A?.includeHour === state.B?.includeHour
            ? Boolean(state.A?.includeHour)
            : "partial";
        renderElementsAnalysis(coupleElements, coupleBreakdown, {
          hiddenMode:
            state.aResult?.input?.hiddenMode === "on" ||
            state.bResult?.input?.hiddenMode === "on"
              ? "on"
              : "off",
          includeHour: includeHourMode,
        });
        renderDeepAnalysisCard(a, b);
        renderLuckFlowCard(a, b);
        renderSummary(totalScore, firedRules, null, coupleElements);
        renderTodayCoupleBox(a, b);
        renderRadar(sectionScores);
        renderRules(firedRules, null, {
          topElem: coupleStats.top,
          weakElem: coupleStats.weak,
          A_topElem: a.topElem,
          B_topElem: b.topElem,
          A_weakElem: a.weakElem,
          B_weakElem: b.weakElem,
          A_branch: a.dayBranch,
          B_branch: b.dayBranch,
          A_season: a.seasonTopElem,
          B_season: b.seasonTopElem,
        });
        // 궁합 모드에서는 월별 신년운세를 노출하지 않음
        renderReportCard(a, b);
        renderPillars(aPillarsEl, state.aResult);
        renderPillars(bPillarsEl, state.bResult);

        return { totalScore, firedRules, coupleElements };
      }

      function renderNewYear() {
        const a = buildPerson(state.A);
        const { top, weak } = getTopWeak(a.elements);
        resultTitle.textContent = "신년운세 요약";
        renderElementsAnalysis(a.elements, state.aResult?.elements?.breakdown, {
          hiddenMode: state.aResult?.input?.hiddenMode,
          includeHour: state.A?.includeHour,
          boundaryText: state.A?.boundaryText,
          birthText: state.aResult?.input?.local
            ? `${state.aResult.input.local} (${state.A?.hourBranch || "—"})`
            : "",
          anchorKey: state.aResult?.elements?.anchor?.key,
          anchorApplied: state.aResult?.elements?.anchor?.applied,
          dayElem: a.dayElem,
        });
        renderDeepAnalysisCard(a, null);
        renderLuckFlowCard(a, null);
        totalScoreEl.textContent = "—";
        summarySub.textContent = "2026 흐름 · 상세 해석";
        summaryMain.textContent = `2026년은 ${top} 기운이 힘을 얻고, ${weak}을(를) 보완하면 복이 따르는 해야. 일간 ${
          a.dayStem || "—"
        }의 강약은 ${
          a.strength
        }이니까, 무리한 확장보다 기준을 세우고 한 가지 목표를 끝까지 밀어야 실이 적어. 세운의 결을 읽고 속도를 조절하면 기회가 쌓이고 결과가 단단해져.`;
        summaryPills.innerHTML = [
          `핵심 오행: ${top}`,
          `약한 오행: ${weak}`,
          "2026 월별 흐름",
        ]
          .map((p) => `<span class="pill">${escapeHtml(p)}</span>`)
          .join("");

        todayCoupleLine.textContent = "—";
        todayCoupleMeta.textContent = "";
        renderMonthly(a);
        renderReportCard(a, null);
        renderPillars(aPillarsEl, state.aResult);
        bPillarsEl.textContent = "";

        return { totalScore: null, coupleElements: a.elements };
      }

      function renderTodayOnly() {
        const a = buildPerson(state.A);
        const todayLuck = todayLuckLine(a);

        // 오늘 운세 카드에 상세 내용 표시
        todayCoupleLine.textContent = todayLuck.main;
        todayCoupleMeta.innerHTML = `
          <div style="margin-top: 20px; padding: 20px; background: rgba(99, 102, 241, 0.04); border-radius: 12px; border-left: 4px solid var(--accent);">
            <p style="font-size: 16px; line-height: 1.9; margin: 0 0 16px 0; color: rgba(15, 23, 42, 0.9); text-align: left;">
              ${escapeHtml(todayLuck.detail)}
            </p>
            <div style="margin-top: 16px; padding: 14px; background: rgba(34, 197, 94, 0.08); border-radius: 8px; border-left: 3px solid rgba(34, 197, 94, 0.5);">
              <p style="font-size: 15px; margin: 0; line-height: 1.8; font-weight: 600; color: rgba(15, 23, 42, 0.9); text-align: left;">
                ${escapeHtml(todayLuck.tip)}
              </p>
            </div>
            <div style="margin-top: 16px; padding: 12px; background: rgba(255, 255, 255, 0.6); border-radius: 8px; border: 1px solid rgba(15, 23, 42, 0.08);">
              <p style="font-size: 14px; margin: 0; line-height: 1.8; color: rgba(15, 23, 42, 0.8); text-align: left;">
                <strong style="color: rgba(15, 23, 42, 0.9);">오늘 오행:</strong> ${escapeHtml(
                  todayLuck.todayElem
                )}<br/>
                <strong style="color: rgba(15, 23, 42, 0.9);">내 강점:</strong> ${escapeHtml(
                  a.topElem
                )} · <strong style="color: rgba(15, 23, 42, 0.9);">내 약점:</strong> ${escapeHtml(
          a.weakElem
        )}
              </p>
            </div>
          </div>
        `;
      }

      function renderAll() {
        if (!state.A) return;
        setResultVisibility(state.mode);
        if (state.mode === "compat") return renderCompat();
        if (state.mode === "newyear") return renderNewYear();
        return renderTodayOnly();
      }

      /* ======================================================
  10. 공유 카드
====================================================== */
      function roundRect(ctx, x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let lineCount = 1;
        let currentY = y;
        for (let i = 0; i < words.length; i++) {
          const test = line + words[i] + " ";
          if (ctx.measureText(test).width > maxWidth && i > 0) {
            ctx.fillText(line, x, currentY);
            line = words[i] + " ";
            currentY += lineHeight;
            lineCount++;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, currentY);
        return lineCount;
      }

      async function generateShareCard(payload) {
        const c = document.getElementById("shareCanvas");
        const ctx = c.getContext("2d");

        const g = ctx.createLinearGradient(0, 0, 0, c.height);
        g.addColorStop(0, "#0b1621");
        g.addColorStop(0.5, "#101f2e");
        g.addColorStop(1, "#14273b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, c.width, c.height);

        const pad = 70;
        const cardX = pad;
        const cardY = pad;
        const cardW = c.width - pad * 2;
        const cardH = c.height - pad * 2;
        roundRect(
          ctx,
          cardX,
          cardY,
          cardW,
          cardH,
          40,
          "rgba(255,255,255,0.92)"
        );

        let currentY = cardY + 80;

        // 신년운세 카드 레이아웃
        if (payload.mode === "newyear") {
          ctx.fillStyle = "#0f172a";
          ctx.font = "800 52px IBM Plex Sans KR";
          ctx.fillText(payload.title, cardX + 50, cardY + 100);

          let y = cardY + 180;
          if (payload.summary) {
            ctx.font = "700 28px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.9)";
            const summaryLines = wrapText(
              ctx,
              payload.summary,
              cardX + 50,
              y,
              cardW - 100,
              38
            );
            y += summaryLines * 38 + 40;
          }

          if (payload.lines && payload.lines.length) {
            payload.lines.forEach((line) => {
              if (!line || line.trim() === "") {
                y += 16; // 빈 줄은 간격만 추가
                return;
              }
              // "📅 월별 흐름:" 같은 제목은 더 크게
              if (line.includes("📅") || line.includes("월별")) {
                ctx.font = "700 26px IBM Plex Sans KR";
                ctx.fillStyle = "rgba(15,23,42,0.9)";
                y += 12;
              } else if (line.includes("월:")) {
                // 월별 항목은 작게
                ctx.font = "500 20px IBM Plex Sans KR";
                ctx.fillStyle = "rgba(15,23,42,0.75)";
              } else {
                ctx.font = "600 24px IBM Plex Sans KR";
                ctx.fillStyle = "rgba(15,23,42,0.82)";
              }
              const lineCount = wrapText(
                ctx,
                line.includes("월:") ? `  ${line}` : `• ${line}`,
                cardX + 50,
                y,
                cardW - 100,
                line.includes("월:") ? 28 : 34
              );
              y +=
                lineCount * (line.includes("월:") ? 28 : 34) +
                (line.includes("월:") ? 6 : 12);
            });
          }

          // 오행 정보를 하단 중앙에 배치
          if (payload.topElem && payload.weakElem) {
            ctx.font = "600 22px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.7)";
            const elemText = `핵심 오행: ${payload.topElem} · 약한 오행: ${payload.weakElem}`;
            const elemWidth = ctx.measureText(elemText).width;
            ctx.fillText(
              elemText,
              cardX + (cardW - elemWidth) / 2,
              cardY + cardH - 100
            );
          }

          // funnyfunny.cloud를 오른쪽 하단에 배치
          ctx.font = "600 20px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.5)";
          const brandText = "funnyfunny.cloud";
          const brandWidth = ctx.measureText(brandText).width;
          ctx.fillText(
            brandText,
            cardX + cardW - brandWidth - 50,
            cardY + cardH - 50
          );
        } else if (payload.main && payload.detail && payload.tip) {
          // 오늘 운세 모드일 때 깔끔한 레이아웃
          // 제목
          ctx.fillStyle = "#0f172a";
          ctx.font = "800 56px IBM Plex Sans KR";
          ctx.fillText("🔮 " + payload.title, cardX + 50, currentY);
          currentY += 100;

          // 메인 텍스트
          ctx.font = "700 36px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.95)";
          const mainLines = wrapText(
            ctx,
            payload.main,
            cardX + 50,
            currentY,
            cardW - 100,
            50
          );
          currentY += mainLines * 50 + 40;

          // 상세 설명
          ctx.font = "600 28px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.85)";
          const detailLines = wrapText(
            ctx,
            payload.detail,
            cardX + 50,
            currentY,
            cardW - 100,
            42
          );
          currentY += detailLines * 42 + 30;

          // 팁
          ctx.font = "700 26px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.9)";
          const tipLines = wrapText(
            ctx,
            payload.tip,
            cardX + 50,
            currentY,
            cardW - 100,
            38
          );
          currentY += tipLines * 38 + 40;

          // 오행 정보
          ctx.font = "600 24px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.75)";
          ctx.fillText(`오늘 오행: ${payload.todayElem}`, cardX + 50, currentY);
          currentY += 35;
          ctx.fillText(
            `내 강점: ${payload.topElem} · 내 약점: ${payload.weakElem}`,
            cardX + 50,
            currentY
          );

          // funnyfunny.cloud를 오른쪽 하단에 배치
          ctx.font = "600 20px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.5)";
          const brandText = "funnyfunny.cloud";
          const brandWidth = ctx.measureText(brandText).width;
          ctx.fillText(
            brandText,
            cardX + cardW - brandWidth - 50,
            cardY + cardH - 50
          );
        } else {
          // 기존 레이아웃 (궁합, 신년운세)
          ctx.fillStyle = "#0f172a";
          ctx.font = "800 52px IBM Plex Sans KR";
          ctx.fillText(payload.title, cardX + 50, cardY + 120);

          if (payload.toneLabel) {
            ctx.font = "700 30px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.7)";
            ctx.fillText(payload.toneLabel, cardX + 50, cardY + 170);
          }

          if (payload.scoreText && payload.scoreText !== "—") {
            ctx.font = "800 110px IBM Plex Sans KR";
            ctx.fillStyle = "#0f172a";
            ctx.fillText(String(payload.scoreText), cardX + 50, cardY + 300);
            ctx.font = "700 30px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.7)";
            ctx.fillText(payload.scoreLabel, cardX + 50, cardY + 350);
          }

          if (payload.topElem) {
            ctx.font = "700 32px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.85)";
            ctx.fillText(
              `핵심 오행: ${payload.topElem}`,
              cardX + 50,
              cardY + 430
            );
          }

          if (payload.summary) {
            ctx.font = "700 32px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.9)";
            wrapText(
              ctx,
              `요약: ${payload.summary}`,
              cardX + 50,
              cardY + 510,
              cardW - 100,
              44
            );
          }

          if (payload.todayLine) {
            ctx.font = "700 28px IBM Plex Sans KR";
            ctx.fillStyle = "rgba(15,23,42,0.78)";
            wrapText(
              ctx,
              payload.todayLine,
              cardX + 50,
              cardY + 700,
              cardW - 100,
              40
            );
          }

          // funnyfunny.cloud를 오른쪽 하단에 배치
          ctx.font = "600 20px IBM Plex Sans KR";
          ctx.fillStyle = "rgba(15,23,42,0.5)";
          const brandText = "funnyfunny.cloud";
          const brandWidth = ctx.measureText(brandText).width;
          ctx.fillText(
            brandText,
            cardX + cardW - brandWidth - 50,
            cardY + cardH - 50
          );
        }

        return new Promise((resolve) => c.toBlob(resolve, "image/png", 1.0));
      }

      function getSharePayload(snapshot) {
        if (state.mode === "compat") {
          return {
            title: "궁합 리포트",
            scoreText: snapshot.totalScore,
            scoreLabel: "궁합 점수",
            summary: summaryMain.textContent,
            todayLine: todayCoupleLine.textContent,
            topElem: getTopWeak(snapshot.coupleElements).top,
          };
        }
        if (state.mode === "newyear") {
          const a = buildPerson(state.A);
          const { top, weak } = getTopWeak(state.A.elements);
          const y2026 = yearModeFor(a, 2026);
          const strategy = yearStrategy(y2026.mode);
          const monthlyData = makeMonthlyLuck(a);

          // 월별 운세를 간단히 요약 (카드에 맞게 간결하게)
          const monthlySummary = monthlyData
            .map((m) => {
              const modeText = monthModeText(m.mode);
              const luckText =
                m.tags?.[0] === "길"
                  ? "길"
                  : m.tags?.[0] === "흉"
                  ? "흉"
                  : "중";
              // 요약 텍스트를 20자 이내로 줄이기
              let summary = m.summary || "";
              if (summary.length > 20) {
                // 문장의 핵심만 추출
                const shortSummary = summary
                  .replace(/오늘은|이번 달은|이 시기는/g, "")
                  .replace(/\.\.\./g, "")
                  .trim();
                summary =
                  shortSummary.length > 20
                    ? shortSummary.substring(0, 17) + "..."
                    : shortSummary;
              }
              return `${m.month}월: ${luckText}운 · ${modeText} · ${summary}`;
            })
            .slice(0, 12); // 12개월 모두 포함

          return {
            mode: "newyear",
            title: "신년운세 리포트",
            summary: summaryMain.textContent,
            lines: [
              `2026년 ${y2026.pillar.text}(${y2026.yearElem}) · ${yearModeText(
                y2026.mode
              )}`,
              `해야 할 것: ${strategy.todo}`,
              `피해야 할 것: ${strategy.avoid}`,
              "",
              "📅 월별 흐름:",
              ...monthlySummary,
            ],
            topElem: top,
            weakElem: weak,
          };
        }
        const a = buildPerson(state.A);
        const todayLuck = todayLuckLine(a);
        const topElem = getTopWeak(state.A.elements).top;
        return {
          title: "오늘의 운세",
          main: todayLuck.main,
          detail: todayLuck.detail,
          tip: todayLuck.tip,
          todayElem: todayLuck.todayElem,
          topElem: a.topElem,
          weakElem: a.weakElem,
        };
      }

      async function shareCard() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }

        // 신년운세 모드는 텍스트 공유
        if (state.mode === "newyear") {
          const a = buildPerson(state.A);
          const { top, weak } = getTopWeak(state.A.elements);
          const y2026 = yearModeFor(a, 2026);
          const strategy = yearStrategy(y2026.mode);
          const monthlyData = makeMonthlyLuck(a);

          let text = `🔮 2026 신년운세\n\n`;
          text += `${summaryMain.textContent}\n\n`;
          text += `2026년 ${y2026.pillar.text}(${
            y2026.yearElem
          }) · ${yearModeText(y2026.mode)}\n`;
          text += `해야 할 것: ${strategy.todo}\n`;
          text += `피해야 할 것: ${strategy.avoid}\n\n`;
          text += `핵심 오행: ${top} · 약한 오행: ${weak}\n\n`;
          text += `📅 월별 흐름:\n`;

          monthlyData.forEach((m) => {
            const modeText = monthModeText(m.mode);
            const luckText =
              m.tags?.[0] === "길"
                ? "길운"
                : m.tags?.[0] === "흉"
                ? "흉운"
                : "중운";
            text += `${m.month}월: ${luckText} · ${modeText} · ${m.summary}\n`;
          });

          text += `\n🔮 사주풀이 서비스: https://saju.funnyfunny.cloud/`;

          try {
            await navigator.clipboard.writeText(text);
            shareStatus.textContent = "신년운세가 클립보드에 복사되었어.";
          } catch (err) {
            // 클립보드 API가 없거나 실패한 경우
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.style.position = "fixed";
            textarea.style.opacity = "0";
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand("copy");
              shareStatus.textContent = "신년운세가 클립보드에 복사되었어.";
            } catch (e) {
              prompt("복사할 내용:", text);
              shareStatus.textContent = "텍스트를 확인해줘.";
            }
            document.body.removeChild(textarea);
          }
          return;
        }

        // 오늘운세, 궁합 모드는 기존 카드 공유
        const snapshot = renderAll() || {
          totalScore: "—",
          coupleElements: state.A.elements,
        };
        const blob = await generateShareCard(getSharePayload(snapshot));

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;

        // 모드별 파일명 설정
        const dateStr = new Date().toISOString().slice(0, 10);
        let fileName;
        if (state.mode === "today") {
          fileName = `오늘의운세카드_${dateStr}.png`;
        } else {
          fileName = `궁합카드_${dateStr}.png`;
        }
        a.download = fileName;
        a.click();

        try {
          await navigator.clipboard.write([
            new ClipboardItem({ "image/png": blob }),
          ]);
          shareStatus.textContent = "카드를 생성하고 클립보드에 복사했어.";
        } catch {
          shareStatus.textContent = "카드를 생성했어. 다운로드를 확인해줘.";
        }
      }

      /* ======================================================
  11. PDF 저장 (html2canvas + jsPDF)
====================================================== */
      async function savePdfPretty() {
        if (!state.A) {
          alert("입력 후 계산해줘.");
          return;
        }
        if (!window.html2canvas || !window.jspdf) {
          alert("PDF 라이브러리가 준비되지 않았어.");
          return;
        }

        const area = document.getElementById("pdfArea");
        const canvas = await html2canvas(area, {
          scale: 1.5,
          backgroundColor: "#ffffff",
          useCORS: true,
          logging: false,
          ignoreElements: (element) => {
            // hidden 클래스가 있는 요소는 제외
            return element.classList?.contains("hidden");
          },
        });

        const imgData = canvas.toDataURL("image/jpeg", 0.82);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "p",
          unit: "mm",
          format: "a4",
          compress: true,
        });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;

        // 이미지를 PDF에 추가 (여러 페이지로 나누기)
        if (imgH <= pageH) {
          pdf.addImage(imgData, "JPEG", 0, 0, imgW, imgH);
        } else {
          let y = 0;
          let remaining = imgH;
          while (remaining > 0) {
            pdf.addImage(imgData, "JPEG", 0, -y, imgW, imgH);
            remaining -= pageH;
            y += pageH;
            if (remaining > 0) pdf.addPage();
          }
        }

        // 모드별 파일명 설정
        const dateStr = new Date().toISOString().slice(0, 10);
        let fileName;
        if (state.mode === "today") {
          fileName = `오늘의운세_${dateStr}.pdf`;
        } else if (state.mode === "newyear") {
          fileName = `신년운세_${dateStr}.pdf`;
        } else {
          fileName = `궁합리포트_${dateStr}.pdf`;
        }

        pdf.save(fileName);
      }

      /* ======================================================
  12. 입력/계산 파이프라인
====================================================== */
      function loadInputs() {
        try {
          return JSON.parse(localStorage.getItem(INPUT_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function saveInputs(data) {
        localStorage.setItem(INPUT_KEY, JSON.stringify(data));
      }

      function setInputs(data) {
        if (!data) return;
        aDate.value = data.aDate || "";
        aHourBranch.value = data.aHourBranch || "자";
        aTimeUnknown.checked = Boolean(data.aTimeUnknown);
        aGender.value = data.aGender || "male";
        aDaewoonStart.value = data.aDaewoonStart || "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = data.aTzOffset ?? "9";
        aDstMode.value = data.aDstMode || "off";
        bDate.value = data.bDate || "";
        bHourBranch.value = data.bHourBranch || "자";
        bTimeUnknown.checked = Boolean(data.bTimeUnknown);
        bGender.value = data.bGender || "female";
        bDaewoonStart.value = data.bDaewoonStart || "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = data.bTzOffset ?? "9";
        bDstMode.value = data.bDstMode || "off";
      }

      function getInputData() {
        return {
          aDate: aDate.value,
          aHourBranch: aHourBranch.value,
          aTimeUnknown: aTimeUnknown.checked,
          aGender: aGender.value,
          aLunar: "",
          aDaewoonStart: aDaewoonStart.value,
          aHiddenMode: "on",
          aTzOffset: aTzOffset.value,
          aDstMode: aDstMode.value,
          bDate: bDate.value,
          bHourBranch: bHourBranch.value,
          bTimeUnknown: bTimeUnknown.checked,
          bGender: bGender.value,
          bLunar: "",
          bDaewoonStart: bDaewoonStart.value,
          bHiddenMode: "on",
          bTzOffset: bTzOffset.value,
          bDstMode: bDstMode.value,
          mode: state.mode,
        };
      }

      function configureInputForMode(mode) {
        const gridContainer = panelA.parentElement;
        if (mode === "compat") {
          inputTitle.textContent = "궁합 입력";
          inputDesc.textContent = "A/B 출생 정보 입력 → 궁합 계산";
          panelB.classList.remove("hidden");
          gridContainer.style.display = "grid";
          gridContainer.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
          gridContainer.style.justifyItems = "stretch";
          panelA.style.maxWidth = "none";
        } else if (mode === "newyear") {
          inputTitle.textContent = "신년운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 2026 흐름";
          panelB.classList.add("hidden");
          gridContainer.style.display = "flex";
          gridContainer.style.justifyContent = "center";
          panelA.style.maxWidth = "500px";
        } else {
          inputTitle.textContent = "오늘운세 입력";
          inputDesc.textContent = "한 사람 출생 정보 입력 → 오늘 한 줄";
          panelB.classList.add("hidden");
          gridContainer.style.display = "flex";
          gridContainer.style.justifyContent = "center";
          panelA.style.maxWidth = "500px";
        }
      }

      function showStep(name) {
        stepMenu.classList.toggle("active", name === "menu");
        stepInput.classList.toggle("active", name === "input");
        stepResult.classList.toggle("active", name === "result");
      }

      async function computePair() {
        try {
          const data = getInputData();
          if (!data.aDate || !data.aHourBranch) {
            alert("A 날짜와 12간지를 선택해줘.");
            return;
          }
          if (state.mode === "compat" && (!data.bDate || !data.bHourBranch)) {
            alert("B 날짜와 12간지를 선택해줘.");
            return;
          }
          saveInputs(data);

          loadingOverlay.classList.add("active");
          loadingOverlay.setAttribute("aria-hidden", "false");
          await new Promise((r) => setTimeout(r, 700));

          const aOffsetMin = parseTzOffsetMinutes(data.aTzOffset, 540);
          const aIncludeHour = !data.aTimeUnknown;
          const aTimeStr = aIncludeHour
            ? hourBranchToTime(data.aHourBranch)
            : "12:00";
          if (!data.aDate) {
            throw new Error("A 날짜가 비어 있어.");
          }
          const aBirth = parseLocalDateTime(
            data.aDate,
            aTimeStr,
            aOffsetMin,
            data.aDstMode
          );
          if (!aBirth || isNaN(aBirth.getTime())) {
            throw new Error(
              "A 날짜/시간 파싱 실패: " + data.aDate + " " + aTimeStr
            );
          }
          const aHourBranch = aIncludeHour ? data.aHourBranch : null;
          const aResult = computeSajuFiveElements(aBirth, {
            ziMode: "2300",
            hiddenMode: "on", // 항상 on으로 고정
            tzOffsetMinutes: aOffsetMin,
            dstMode: data.aDstMode,
            includeHour: aIncludeHour,
            hourBranchOverride: aHourBranch,
          });
          if (!aResult || !aResult.elements || !aResult.pillars) {
            throw new Error("A 사주 계산 실패");
          }
          state.aResult = aResult;
          state.A = {
            name: "A",
            elements: aResult.elements.raw,
            dayBranch: aResult.pillars.day.branch,
            monthBranch: aResult.pillars.month.branch,
            yearBranch: aResult.pillars.year.branch,
            yearStem: aResult.pillars.year.stem,
            monthStem: aResult.pillars.month.stem,
            dayStem: aResult.pillars.day.stem,
            hourStem: aResult.pillars.hour ? aResult.pillars.hour.stem : "",
            tzOffsetMinutes: aOffsetMin,
            dstMode: data.aDstMode,
            includeHour: aIncludeHour,
            hourBranch: aHourBranch,
            boundaryText: makeBoundaryText(),
            altResult: null,
            gender: data.aGender,
            lunarDate: data.aLunar,
            daewoonStartAge: data.aDaewoonStart,
          };

          if (state.mode === "compat") {
            const bOffsetMin = parseTzOffsetMinutes(data.bTzOffset, 540);
            const bIncludeHour = !data.bTimeUnknown;
            const bTimeStr = bIncludeHour
              ? hourBranchToTime(data.bHourBranch)
              : "12:00";
            if (!data.bDate) {
              throw new Error("B 날짜가 비어 있어.");
            }
            const bBirth = parseLocalDateTime(
              data.bDate,
              bTimeStr,
              bOffsetMin,
              data.bDstMode
            );
            if (!bBirth || isNaN(bBirth.getTime())) {
              throw new Error(
                "B 날짜/시간 파싱 실패: " + data.bDate + " " + bTimeStr
              );
            }
            const bHourBranch = bIncludeHour ? data.bHourBranch : null;
            const bResult = computeSajuFiveElements(bBirth, {
              ziMode: "2300",
              hiddenMode: "on", // 항상 on으로 고정
              tzOffsetMinutes: bOffsetMin,
              dstMode: data.bDstMode,
              includeHour: bIncludeHour,
              hourBranchOverride: bHourBranch,
            });
            if (!bResult || !bResult.elements || !bResult.pillars) {
              throw new Error("B 사주 계산 실패");
            }
            state.bResult = bResult;
            state.B = {
              name: "B",
              elements: bResult.elements.raw,
              dayBranch: bResult.pillars.day.branch,
              monthBranch: bResult.pillars.month.branch,
              yearBranch: bResult.pillars.year.branch,
              yearStem: bResult.pillars.year.stem,
              monthStem: bResult.pillars.month.stem,
              dayStem: bResult.pillars.day.stem,
              hourStem: bResult.pillars.hour ? bResult.pillars.hour.stem : "",
              tzOffsetMinutes: bOffsetMin,
              dstMode: data.bDstMode,
              includeHour: bIncludeHour,
              hourBranch: bHourBranch,
              boundaryText: makeBoundaryText(),
              altResult: null,
              gender: data.bGender,
              lunarDate: data.bLunar,
              daewoonStartAge: data.bDaewoonStart,
            };
          } else {
            state.bResult = null;
            state.B = null;
          }

          showStep("result");
          renderAll();

          await new Promise((r) => setTimeout(r, 400));
        } catch (error) {
          console.error("계산 중 오류 발생:", error);
          alert(
            "계산 중 오류가 생겼어. 입력값 확인해줘.\n오류: " + error.message
          );
        } finally {
          loadingOverlay.classList.remove("active");
          loadingOverlay.setAttribute("aria-hidden", "true");
        }
      }

      /* ======================================================
  INIT
====================================================== */
      function init() {
        const saved = loadInputs();
        setInputs(saved);
        // 항상 메뉴 화면을 먼저 표시
        showStep("menu");
        // 저장된 모드가 있으면 해당 모드로 입력 화면 설정만 해두기 (화면은 메뉴 유지)
        if (saved.mode) {
          state.mode = saved.mode === "compat" ? "newyear" : saved.mode;
          configureInputForMode(state.mode);
        }
      }

      document.querySelectorAll(".menu-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          state.mode = btn.dataset.mode;
          configureInputForMode(state.mode);
          showStep("input");
        });
      });

      backToMenu.addEventListener("click", () => showStep("menu"));
      clearSaved.addEventListener("click", () => {
        localStorage.removeItem(INPUT_KEY);
        aDate.value = "";
        aHourBranch.value = "자";
        aTimeUnknown.checked = false;
        aGender.value = "male";
        aDaewoonStart.value = "";
        aHiddenMode.value = "on";
        aHiddenMode.disabled = true;
        aTzOffset.value = "9";
        aDstMode.value = "off";
        bDate.value = "";
        bHourBranch.value = "자";
        bTimeUnknown.checked = false;
        bGender.value = "female";
        bDaewoonStart.value = "";
        bHiddenMode.value = "on";
        bHiddenMode.disabled = true;
        bTzOffset.value = "9";
        bDstMode.value = "off";
        alert("저장된 입력을 초기화했어.");
      });
      backToInput.addEventListener("click", () => showStep("input"));
      restartFlow.addEventListener("click", () => showStep("menu"));

      shareBtn.addEventListener("click", shareCard);
      pdfBtn.addEventListener("click", savePdfPretty);
      calcBtn.addEventListener("click", computePair);

      init();
    </script>
  </body>
</html>
